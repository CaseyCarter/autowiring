<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Autowiring: ObjectPool&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_object_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ObjectPool&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Allows the management of a pool of objects based on an embedded factory  
 <a href="class_object_pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_object_pool_8h_source.html">ObjectPool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a651ec014fd16a517f2fcd26c0dcf6760"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_pool.html#a651ec014fd16a517f2fcd26c0dcf6760">ObjectPool</a> (size_t limit=~0, size_t maxPooled=~0, const std::function&lt; T *()&gt; &amp;alloc=&amp;DefaultCreate&lt; T &gt;, const std::function&lt; void(T &amp;)&gt; &amp;initial=&amp;DefaultInitialize&lt; T &gt;, const std::function&lt; void(T &amp;)&gt; &amp;final=&amp;DefaultFinalize&lt; T &gt;)</td></tr>
<tr class="separator:a651ec014fd16a517f2fcd26c0dcf6760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61ef3a9eb31d2c48598b171286b5be7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab61ef3a9eb31d2c48598b171286b5be7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_pool.html#ab61ef3a9eb31d2c48598b171286b5be7">ObjectPool</a> (const std::function&lt; T *()&gt; &amp;alloc, const std::function&lt; void(T &amp;)&gt; &amp;initial=&amp;DefaultInitialize&lt; T &gt;, const std::function&lt; void(T &amp;)&gt; &amp;final=&amp;DefaultFinalize&lt; T &gt;, size_t limit=~0, size_t maxPooled=~0)</td></tr>
<tr class="memdesc:ab61ef3a9eb31d2c48598b171286b5be7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The maximum number of objects this pool will allow to be outstanding at any time</td></tr>
  </table>
  </dd>
</dl>
<br /></td></tr>
<tr class="separator:ab61ef3a9eb31d2c48598b171286b5be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11377cc6e4ef91349e2f89b9cfecaec0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11377cc6e4ef91349e2f89b9cfecaec0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ObjectPool</b> (<a class="el" href="class_object_pool.html">ObjectPool</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a11377cc6e4ef91349e2f89b9cfecaec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771e48d3f6b7eac257d268fd20c4c818"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a771e48d3f6b7eac257d268fd20c4c818"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetOutstanding</b> (void) const </td></tr>
<tr class="separator:a771e48d3f6b7eac257d268fd20c4c818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50530f8e5da23ab6bc22ac6a86ad81e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa50530f8e5da23ab6bc22ac6a86ad81e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetCached</b> (void) const </td></tr>
<tr class="separator:aa50530f8e5da23ab6bc22ac6a86ad81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80600afe44b2eeb27226e0eaa2f04e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae80600afe44b2eeb27226e0eaa2f04e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsEmpty</b> (void) const </td></tr>
<tr class="separator:ae80600afe44b2eeb27226e0eaa2f04e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa561f08c3ff66bcf37267d46deeea614"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa561f08c3ff66bcf37267d46deeea614"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetAlloc</b> (const std::function&lt; T *()&gt; &amp;alloc)</td></tr>
<tr class="separator:aa561f08c3ff66bcf37267d46deeea614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d450d153ef20a765f1ccd642d5fe72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_pool.html#a91d450d153ef20a765f1ccd642d5fe72">ClearCachedEntities</a> (void)</td></tr>
<tr class="memdesc:a91d450d153ef20a765f1ccd642d5fe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards all entities currently saved in the pool  <a href="#a91d450d153ef20a765f1ccd642d5fe72">More...</a><br /></td></tr>
<tr class="separator:a91d450d153ef20a765f1ccd642d5fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae9ccf4a099b1253c902c617d7c21de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_pool.html#a7ae9ccf4a099b1253c902c617d7c21de">SetMaximumPooledEntities</a> (size_t maxPooled)</td></tr>
<tr class="memdesc:a7ae9ccf4a099b1253c902c617d7c21de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets the maximum number of entities that the pool will cache to satisfy a later allocation request  <a href="#a7ae9ccf4a099b1253c902c617d7c21de">More...</a><br /></td></tr>
<tr class="separator:a7ae9ccf4a099b1253c902c617d7c21de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e23f3edb585cb05dabc116790840d17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_pool.html#a8e23f3edb585cb05dabc116790840d17">SetOutstandingLimit</a> (size_t limit)</td></tr>
<tr class="memdesc:a8e23f3edb585cb05dabc116790840d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of objects this pool will permit to be outstanding at time  <a href="#a8e23f3edb585cb05dabc116790840d17">More...</a><br /></td></tr>
<tr class="separator:a8e23f3edb585cb05dabc116790840d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc712c96e394694c68b0449e2dc26d3"><td class="memTemplParams" colspan="2">template&lt;class Duration &gt; </td></tr>
<tr class="memitem:a9dc712c96e394694c68b0449e2dc26d3"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_object_pool.html#a9dc712c96e394694c68b0449e2dc26d3">WaitFor</a> (Duration duration)</td></tr>
<tr class="memdesc:a9dc712c96e394694c68b0449e2dc26d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until an object becomes available from the pool, or the timeout has elapsed  <a href="#a9dc712c96e394694c68b0449e2dc26d3">More...</a><br /></td></tr>
<tr class="separator:a9dc712c96e394694c68b0449e2dc26d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877409f6b738265196568fc80b90b022"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_pool.html#a877409f6b738265196568fc80b90b022">Wait</a> (void)</td></tr>
<tr class="memdesc:a877409f6b738265196568fc80b90b022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until an object becomes available from the pool  <a href="#a877409f6b738265196568fc80b90b022">More...</a><br /></td></tr>
<tr class="separator:a877409f6b738265196568fc80b90b022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c935af506a2677886174fa5abf6334"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_pool.html#ab1c935af506a2677886174fa5abf6334">Preallocate</a> (size_t reservation)</td></tr>
<tr class="memdesc:ab1c935af506a2677886174fa5abf6334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the pool's internal cache to hold at least the requested number of items  <a href="#ab1c935af506a2677886174fa5abf6334">More...</a><br /></td></tr>
<tr class="separator:ab1c935af506a2677886174fa5abf6334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a418b2e21c6760683f4184bede5e85b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_pool.html#a7a418b2e21c6760683f4184bede5e85b">operator()</a> (std::shared_ptr&lt; T &gt; &amp;rs)</td></tr>
<tr class="memdesc:a7a418b2e21c6760683f4184bede5e85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of type T and places it in the passed shared pointer  <a href="#a7a418b2e21c6760683f4184bede5e85b">More...</a><br /></td></tr>
<tr class="separator:a7a418b2e21c6760683f4184bede5e85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8582d71e35f43f9accfc8f927959924e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_pool.html#a8582d71e35f43f9accfc8f927959924e">operator()</a> ()</td></tr>
<tr class="memdesc:a8582d71e35f43f9accfc8f927959924e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload of operator()  <a href="#a8582d71e35f43f9accfc8f927959924e">More...</a><br /></td></tr>
<tr class="separator:a8582d71e35f43f9accfc8f927959924e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1df5534546bb89608f220855896178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_pool.html#a1e1df5534546bb89608f220855896178">Rundown</a> (void)</td></tr>
<tr class="memdesc:a1e1df5534546bb89608f220855896178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until all outstanding entries have been returned, and prevents the issuance of any new items  <a href="#a1e1df5534546bb89608f220855896178">More...</a><br /></td></tr>
<tr class="separator:a1e1df5534546bb89608f220855896178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e286fe319ae380206e06544963946e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44e286fe319ae380206e06544963946e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt; &amp;)=delete</td></tr>
<tr class="separator:a44e286fe319ae380206e06544963946e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d389bc2b72c3892d6aff6a8cce27714"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d389bc2b72c3892d6aff6a8cce27714"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="separator:a2d389bc2b72c3892d6aff6a8cce27714"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac5a92c29d141fc40e3620f13276df392"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_pool.html#ac5a92c29d141fc40e3620f13276df392">Wrap</a> (T *pObj)</td></tr>
<tr class="memdesc:ac5a92c29d141fc40e3620f13276df392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shared pointer to wrap the specified object while it is issued  <a href="#ac5a92c29d141fc40e3620f13276df392">More...</a><br /></td></tr>
<tr class="separator:ac5a92c29d141fc40e3620f13276df392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79a75fe6be19617b7cbdfeb4650c6cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad79a75fe6be19617b7cbdfeb4650c6cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Return</b> (size_t poolVersion, std::unique_ptr&lt; T &gt; &amp;unique)</td></tr>
<tr class="separator:ad79a75fe6be19617b7cbdfeb4650c6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7650e1fed5efc0473d95a7e533661160"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_object_pool.html#a7650e1fed5efc0473d95a7e533661160">ObtainElementUnsafe</a> (std::unique_lock&lt; std::mutex &gt; &amp;lk)</td></tr>
<tr class="memdesc:a7650e1fed5efc0473d95a7e533661160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains an element from the object queue, assumes exterior synchronization  <a href="#a7650e1fed5efc0473d95a7e533661160">More...</a><br /></td></tr>
<tr class="separator:a7650e1fed5efc0473d95a7e533661160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7fc33725f55d1070a492db1bb3a21d4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fc33725f55d1070a492db1bb3a21d4b"></a>
std::shared_ptr<br class="typebreak" />
&lt; <a class="el" href="class_object_pool_monitor.html">ObjectPoolMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_monitor</b></td></tr>
<tr class="separator:a7fc33725f55d1070a492db1bb3a21d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffddc8b9e8aada6c70225ed004ff5d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ffddc8b9e8aada6c70225ed004ff5d9"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><b>m_setCondition</b></td></tr>
<tr class="separator:a3ffddc8b9e8aada6c70225ed004ff5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc9b7b74c85edbfe765af48996f8736"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcc9b7b74c85edbfe765af48996f8736"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_poolVersion</b></td></tr>
<tr class="separator:adcc9b7b74c85edbfe765af48996f8736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac189b1bc3fe82bac4bcda42fa47c927"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac189b1bc3fe82bac4bcda42fa47c927"></a>
std::vector&lt; std::unique_ptr&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_objs</b></td></tr>
<tr class="separator:aac189b1bc3fe82bac4bcda42fa47c927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d6c566398a15565b534e80a509bbb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08d6c566398a15565b534e80a509bbb1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_maxPooled</b></td></tr>
<tr class="separator:a08d6c566398a15565b534e80a509bbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1f6f88b1f10063c55649979c9ddead"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c1f6f88b1f10063c55649979c9ddead"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_limit</b></td></tr>
<tr class="separator:a5c1f6f88b1f10063c55649979c9ddead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb655efd75c57dcfe23b0cdc1187c80e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb655efd75c57dcfe23b0cdc1187c80e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_outstanding</b></td></tr>
<tr class="separator:abb655efd75c57dcfe23b0cdc1187c80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8381bc67c7e5992ee840c87b5ad506"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b8381bc67c7e5992ee840c87b5ad506"></a>
std::function&lt; void(T &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_initial</b></td></tr>
<tr class="separator:a6b8381bc67c7e5992ee840c87b5ad506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3ff26245cd07111aa5ff0683985e8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d3ff26245cd07111aa5ff0683985e8f"></a>
std::function&lt; void(T &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_final</b></td></tr>
<tr class="separator:a9d3ff26245cd07111aa5ff0683985e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadee381f2886dae889b85eba5a430f89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadee381f2886dae889b85eba5a430f89"></a>
std::function&lt; T *()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_alloc</b></td></tr>
<tr class="separator:aadee381f2886dae889b85eba5a430f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class ObjectPool&lt; T &gt;</h3>

<p>Allows the management of a pool of objects based on an embedded factory </p>
<p>&lt;param name="T&gt;The type to be pooled&lt;/param&gt;
&lt;param name="_Rx"&gt;A function object which resets instances returned to the pool</p>
<p>This class is a type of factory that creates an object of type T. The object pool creates a shared pointer for the consumer to use, and when the last shared pointer for that object is destroyed, the wrapped object is returned to this pool rather than being deleted. Returned objects may satisfy subsequent requests for construction.</p>
<p>All object pool methods are thread safe.</p>
<p>Issued pool members must be released before the pool goes out of scope </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a651ec014fd16a517f2fcd26c0dcf6760"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt;::<a class="el" href="class_object_pool.html">ObjectPool</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>~0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPooled</em> = <code>~0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; T *()&gt; &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>&amp;DefaultCreate&lt;T&gt;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>initial</em> = <code>&amp;DefaultInitialize&lt;T&gt;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>final</em> = <code>&amp;DefaultFinalize&lt;T&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The maximum number of objects this pool will allow to be outstanding at any time</td></tr>
    <tr><td class="paramname">maxPooled</td><td>The maximum number of objects cached by the pool</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a91d450d153ef20a765f1ccd642d5fe72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt;::ClearCachedEntities </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards all entities currently saved in the pool </p>
<p>This method will also cause currently outstanding entities to be freed. Eventually, once all objects return to the pool, the set of objects managed by this pool will be distinct from those objects created prior to this call. </p>

</div>
</div>
<a class="anchor" id="a7650e1fed5efc0473d95a7e533661160"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; <a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt;::ObtainElementUnsafe </td>
          <td>(</td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt; &amp;&#160;</td>
          <td class="paramname"><em>lk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains an element from the object queue, assumes exterior synchronization </p>
<p>This method will unconditionally increment the outstanding count and will not attempt to perform bounds checking to ensure that the desired element may be issued </p>

</div>
</div>
<a class="anchor" id="a7a418b2e21c6760683f4184bede5e85b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new instance of type T and places it in the passed shared pointer </p>
<p>If the outstanding count is set to anything except -1, this method could potentially fail and the passed shared_ptr will have a null value. Callers who use a nonnegative outstanding limit should be careful to check the return of this function. </p>

</div>
</div>
<a class="anchor" id="a8582d71e35f43f9accfc8f927959924e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; <a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience overload of operator() </p>

</div>
</div>
<a class="anchor" id="ab1c935af506a2677886174fa5abf6334"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt;::Preallocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reservation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes the pool's internal cache to hold at least the requested number of items </p>
<p>The preallocation routine is an optimization routine similar to vector::reserve. Calling this routine can reduce the expense of pointer requests made later, because no allocation has to take place at that point.</p>
<p>If the caller requests a reservation that is greater than the maximum pool limit, the number of objects allocated will be equal to the maximum pool limit. </p>

</div>
</div>
<a class="anchor" id="a1e1df5534546bb89608f220855896178"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt;::Rundown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks until all outstanding entries have been returned, and prevents the issuance of any new items </p>
<p>This method is idempotent </p>

</div>
</div>
<a class="anchor" id="a7ae9ccf4a099b1253c902c617d7c21de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt;::SetMaximumPooledEntities </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPooled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This sets the maximum number of entities that the pool will cache to satisfy a later allocation request </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxPooled</td><td>The new maximum cache count</td></tr>
  </table>
  </dd>
</dl>
<p>If the value of maxPooled is greater than the maximum outstanding limit, it will be made equal to the maximum outstanding limit. </p>

</div>
</div>
<a class="anchor" id="a8e23f3edb585cb05dabc116790840d17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt;::SetOutstandingLimit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum number of objects this pool will permit to be outstanding at time </p>
<p>A user may assign the limit to a value lower than the current limit. In this case, Wait will block until the number of outstanding entities falls below the current count.</p>
<p>If the limit is set to zero, it may not be changed. Attempting to change the limit in this case will result in an exception. Setting the outstanding limit to zero is guaranteed to never throw an exception. </p>

</div>
</div>
<a class="anchor" id="a877409f6b738265196568fc80b90b022"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; <a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt;::Wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks until an object becomes available from the pool </p>
<p>This method will throw an <a class="el" href="classautowiring__error.html">autowiring_error</a> if an attempt is made to obtain an element from a pool with a limit of zero </p>

</div>
</div>
<a class="anchor" id="a9dc712c96e394694c68b0449e2dc26d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; <a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt;::WaitFor </td>
          <td>(</td>
          <td class="paramtype">Duration&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks until an object becomes available from the pool, or the timeout has elapsed </p>
<p>This method will throw an <a class="el" href="classautowiring__error.html">autowiring_error</a> if an attempt is made to obtain an element from a pool with a limit of zero </p>

</div>
</div>
<a class="anchor" id="ac5a92c29d141fc40e3620f13276df392"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; <a class="el" href="class_object_pool.html">ObjectPool</a>&lt; T &gt;::Wrap </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a shared pointer to wrap the specified object while it is issued </p>
<p>The Initialize is applied immediate when Wrap is called. The Finalize function will be applied is in the shared_ptr destructor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autowiring/<a class="el" href="_object_pool_8h_source.html">ObjectPool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 7 2014 11:13:20 for Autowiring by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
