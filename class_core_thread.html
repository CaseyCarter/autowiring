<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Autowiring: CoreThread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.7.7</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Developer's&#160;Guide</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_core_thread.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_core_thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CoreThread Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the order added.  
 <a href="class_core_thread.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_core_thread_8h_source.html">CoreThread.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CoreThread:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_core_thread.png" usemap="#CoreThread_map" alt=""/>
  <map id="CoreThread_map" name="CoreThread_map">
<area href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. " alt="BasicThread" shape="rect" coords="55,56,155,80"/>
<area href="class_dispatch_queue.html" title="This is an asynchronous queue of zero-argument functions " alt="DispatchQueue" shape="rect" coords="165,56,265,80"/>
<area href="class_context_member.html" title="A class that must be inherited in order to be a member of a context heriarchy " alt="ContextMember" shape="rect" coords="0,0,100,24"/>
<area href="class_core_runnable.html" title="Provides the interface for threads that should receive start and stop notifications in a context ..." alt="CoreRunnable" shape="rect" coords="110,0,210,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a710618147be29bbee10455141ac9f713"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_thread.html#a710618147be29bbee10455141ac9f713">CoreThread</a> (const char *pName=nullptr)</td></tr>
<tr class="separator:a710618147be29bbee10455141ac9f713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d06e78e0b2365c429c05bde674b1bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_thread.html#ab4d06e78e0b2365c429c05bde674b1bc">OnStop</a> (void) override</td></tr>
<tr class="memdesc:ab4d06e78e0b2365c429c05bde674b1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when the thread should stop. Implement this method to perform any needed cleanup.  <a href="#ab4d06e78e0b2365c429c05bde674b1bc">More...</a><br /></td></tr>
<tr class="separator:ab4d06e78e0b2365c429c05bde674b1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa00cb32629cf5f71d1dfe27342769a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_thread.html#aaa00cb32629cf5f71d1dfe27342769a8">OnStop</a> (bool graceful) override final</td></tr>
<tr class="memdesc:aaa00cb32629cf5f71d1dfe27342769a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when the thread should stop. Override to perform custom handling when the thread is told to stop.  <a href="#aaa00cb32629cf5f71d1dfe27342769a8">More...</a><br /></td></tr>
<tr class="separator:aaa00cb32629cf5f71d1dfe27342769a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3268ba6d9cb6ff14272ba50a17e9fe9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_thread.html#a3268ba6d9cb6ff14272ba50a17e9fe9f">Run</a> (void) override</td></tr>
<tr class="memdesc:a3268ba6d9cb6ff14272ba50a17e9fe9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins thread execution.  <a href="#a3268ba6d9cb6ff14272ba50a17e9fe9f">More...</a><br /></td></tr>
<tr class="separator:a3268ba6d9cb6ff14272ba50a17e9fe9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_basic_thread"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_basic_thread')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_basic_thread.html">BasicThread</a></td></tr>
<tr class="memitem:aefcc009fa192036be9ea4d11218612a4 inherit pub_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#aefcc009fa192036be9ea4d11218612a4">BasicThread</a> (const char *pName=nullptr)</td></tr>
<tr class="separator:aefcc009fa192036be9ea4d11218612a4 inherit pub_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6274398126caa21fe3d9e37a46360ca7 inherit pub_methods_class_basic_thread"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a6274398126caa21fe3d9e37a46360ca7 inherit pub_methods_class_basic_thread"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a6274398126caa21fe3d9e37a46360ca7">AddTeardownListener</a> (Fx &amp;&amp;listener)</td></tr>
<tr class="memdesc:a6274398126caa21fe3d9e37a46360ca7 inherit pub_methods_class_basic_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a function object which will be called when this <a class="el" href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. ">BasicThread</a> stops running or is destroyed  <a href="#a6274398126caa21fe3d9e37a46360ca7">More...</a><br /></td></tr>
<tr class="separator:a6274398126caa21fe3d9e37a46360ca7 inherit pub_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f756d73ea97f88a9d12f6e0708f1cf8 inherit pub_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a6f756d73ea97f88a9d12f6e0708f1cf8">GetCreationTime</a> (void)</td></tr>
<tr class="memdesc:a6f756d73ea97f88a9d12f6e0708f1cf8 inherit pub_methods_class_basic_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread creation time.  <a href="#a6f756d73ea97f88a9d12f6e0708f1cf8">More...</a><br /></td></tr>
<tr class="separator:a6f756d73ea97f88a9d12f6e0708f1cf8 inherit pub_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643d476885ee38306b061d7fb37c126f inherit pub_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a643d476885ee38306b061d7fb37c126f">GetThreadTimes</a> (std::chrono::milliseconds &amp;kernelTime, std::chrono::milliseconds &amp;userTime)</td></tr>
<tr class="memdesc:a643d476885ee38306b061d7fb37c126f inherit pub_methods_class_basic_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports kernel and user mode running times for this thread.  <a href="#a643d476885ee38306b061d7fb37c126f">More...</a><br /></td></tr>
<tr class="separator:a643d476885ee38306b061d7fb37c126f inherit pub_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6d0e971236f28d25eaef0bffb6181e inherit pub_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a2c6d0e971236f28d25eaef0bffb6181e">IsCompleted</a> (void) const </td></tr>
<tr class="separator:a2c6d0e971236f28d25eaef0bffb6181e inherit pub_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_context_member"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_context_member')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_context_member.html">ContextMember</a></td></tr>
<tr class="memitem:a256451cd0e6dfb1b9c6312cd2b0a4129 inherit pub_methods_class_context_member"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_context_member.html#a256451cd0e6dfb1b9c6312cd2b0a4129">GetContext</a> (void) const </td></tr>
<tr class="memdesc:a256451cd0e6dfb1b9c6312cd2b0a4129 inherit pub_methods_class_context_member"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the context associated with this object.  <a href="#a256451cd0e6dfb1b9c6312cd2b0a4129">More...</a><br /></td></tr>
<tr class="separator:a256451cd0e6dfb1b9c6312cd2b0a4129 inherit pub_methods_class_context_member"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84efe78dbb81bfa94bb46eaf466a6f77 inherit pub_methods_class_context_member"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a84efe78dbb81bfa94bb46eaf466a6f77 inherit pub_methods_class_context_member"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_context_member.html#a84efe78dbb81bfa94bb46eaf466a6f77">GetSelf</a> (void) const </td></tr>
<tr class="memdesc:a84efe78dbb81bfa94bb46eaf466a6f77 inherit pub_methods_class_context_member"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer that refers to ourselves  <a href="#a84efe78dbb81bfa94bb46eaf466a6f77">More...</a><br /></td></tr>
<tr class="separator:a84efe78dbb81bfa94bb46eaf466a6f77 inherit pub_methods_class_context_member"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57af82464416e1763e1d04c50b4c89c inherit pub_methods_class_context_member"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac57af82464416e1763e1d04c50b4c89c inherit pub_methods_class_context_member"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_context_member.html#ac57af82464416e1763e1d04c50b4c89c">GetSelf</a> (void)</td></tr>
<tr class="memdesc:ac57af82464416e1763e1d04c50b4c89c inherit pub_methods_class_context_member"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer that refers to ourselves  <a href="#ac57af82464416e1763e1d04c50b4c89c">More...</a><br /></td></tr>
<tr class="separator:ac57af82464416e1763e1d04c50b4c89c inherit pub_methods_class_context_member"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e73ac0659e22117582b903b81d2b18 inherit pub_methods_class_context_member"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_context_member.html#a34e73ac0659e22117582b903b81d2b18">NotifyContextTeardown</a> (void)</td></tr>
<tr class="memdesc:a34e73ac0659e22117582b903b81d2b18 inherit pub_methods_class_context_member"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by the parent context when the parent context is about to be destroyed  <a href="#a34e73ac0659e22117582b903b81d2b18">More...</a><br /></td></tr>
<tr class="separator:a34e73ac0659e22117582b903b81d2b18 inherit pub_methods_class_context_member"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_core_runnable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_core_runnable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_core_runnable.html">CoreRunnable</a></td></tr>
<tr class="memitem:ab13799735ef39ebe372f9851395a7f53 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab13799735ef39ebe372f9851395a7f53"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#ab13799735ef39ebe372f9851395a7f53">IsRunning</a> (void) const </td></tr>
<tr class="memdesc:ab13799735ef39ebe372f9851395a7f53 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this runnable is currently running. <br /></td></tr>
<tr class="separator:ab13799735ef39ebe372f9851395a7f53 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144421b84f8b8fee45838fbe2be6e5c6 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a144421b84f8b8fee45838fbe2be6e5c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a144421b84f8b8fee45838fbe2be6e5c6">ShouldStop</a> (void) volatile const </td></tr>
<tr class="memdesc:a144421b84f8b8fee45838fbe2be6e5c6 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this runnable should stop. <br /></td></tr>
<tr class="separator:a144421b84f8b8fee45838fbe2be6e5c6 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5e7e482f70200b82d8f0d489eedd12 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a4f5e7e482f70200b82d8f0d489eedd12">Start</a> (std::shared_ptr&lt; CoreObject &gt; outstanding)</td></tr>
<tr class="memdesc:a4f5e7e482f70200b82d8f0d489eedd12 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes this runnable to begin processing.  <a href="#a4f5e7e482f70200b82d8f0d489eedd12">More...</a><br /></td></tr>
<tr class="separator:a4f5e7e482f70200b82d8f0d489eedd12 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c3338adf9bf7222b13bbafb564dabb inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a41c3338adf9bf7222b13bbafb564dabb">Stop</a> (bool graceful=true)</td></tr>
<tr class="memdesc:a41c3338adf9bf7222b13bbafb564dabb inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops this runnable.  <a href="#a41c3338adf9bf7222b13bbafb564dabb">More...</a><br /></td></tr>
<tr class="separator:a41c3338adf9bf7222b13bbafb564dabb inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaa1a6490b1b7d16fa63b64a012a9f0 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a0aaa1a6490b1b7d16fa63b64a012a9f0">ThreadSleep</a> (std::chrono::nanoseconds timeout)</td></tr>
<tr class="memdesc:a0aaa1a6490b1b7d16fa63b64a012a9f0 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeps this thread for the specified duration.  <a href="#a0aaa1a6490b1b7d16fa63b64a012a9f0">More...</a><br /></td></tr>
<tr class="separator:a0aaa1a6490b1b7d16fa63b64a012a9f0 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3c019cfe57942e293c9cec805828e7 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#acb3c019cfe57942e293c9cec805828e7">Wait</a> (void)</td></tr>
<tr class="memdesc:acb3c019cfe57942e293c9cec805828e7 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits indefinitely. Returns when this runnable stops.  <a href="#acb3c019cfe57942e293c9cec805828e7">More...</a><br /></td></tr>
<tr class="separator:acb3c019cfe57942e293c9cec805828e7 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4856481bde70b25d28bac86876cadf88 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a4856481bde70b25d28bac86876cadf88">WaitFor</a> (std::chrono::nanoseconds timeout)</td></tr>
<tr class="memdesc:a4856481bde70b25d28bac86876cadf88 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the specified amount of time.  <a href="#a4856481bde70b25d28bac86876cadf88">More...</a><br /></td></tr>
<tr class="separator:a4856481bde70b25d28bac86876cadf88 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b6ac4ade1032ea1411680a04592d87 inherit pub_methods_class_core_runnable"><td class="memTemplParams" colspan="2">template&lt;typename TimeType &gt; </td></tr>
<tr class="memitem:aa8b6ac4ade1032ea1411680a04592d87 inherit pub_methods_class_core_runnable"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#aa8b6ac4ade1032ea1411680a04592d87">WaitUntil</a> (TimeType timepoint)</td></tr>
<tr class="memdesc:aa8b6ac4ade1032ea1411680a04592d87 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the specified time.  <a href="#aa8b6ac4ade1032ea1411680a04592d87">More...</a><br /></td></tr>
<tr class="separator:aa8b6ac4ade1032ea1411680a04592d87 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7811af34bc57739faeefbf64415f819c inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7811af34bc57739faeefbf64415f819c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a7811af34bc57739faeefbf64415f819c">WasStarted</a> (void) volatile const </td></tr>
<tr class="memdesc:a7811af34bc57739faeefbf64415f819c inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this runnable was ever started. <br /></td></tr>
<tr class="separator:a7811af34bc57739faeefbf64415f819c inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_dispatch_queue"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_dispatch_queue')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_dispatch_queue.html">DispatchQueue</a></td></tr>
<tr class="memitem:aa62c1140f05c7513bc80668aa724684c inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#aa62c1140f05c7513bc80668aa724684c">~DispatchQueue</a> (void)</td></tr>
<tr class="memdesc:aa62c1140f05c7513bc80668aa724684c inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs down the dispatch queue without calling anything  <a href="#aa62c1140f05c7513bc80668aa724684c">More...</a><br /></td></tr>
<tr class="separator:aa62c1140f05c7513bc80668aa724684c inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3193aa5422bf9e1aa80e1c1e9a913016 inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a3193aa5422bf9e1aa80e1c1e9a913016">Abort</a> (void)</td></tr>
<tr class="memdesc:a3193aa5422bf9e1aa80e1c1e9a913016 inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the current dispatch queue to be dumped if it's non-empty  <a href="#a3193aa5422bf9e1aa80e1c1e9a913016">More...</a><br /></td></tr>
<tr class="separator:a3193aa5422bf9e1aa80e1c1e9a913016 inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecb6036d42a7b56e960713f4f9630a0 inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a1ecb6036d42a7b56e960713f4f9630a0">AddExisting</a> (std::unique_ptr&lt; DispatchThunkBase &gt; &amp;&amp;pBase)</td></tr>
<tr class="memdesc:a1ecb6036d42a7b56e960713f4f9630a0 inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit overload for already-constructed dispatch thunk types  <a href="#a1ecb6036d42a7b56e960713f4f9630a0">More...</a><br /></td></tr>
<tr class="separator:a1ecb6036d42a7b56e960713f4f9630a0 inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee3c640b1c46dc87157d7e1186db9bc inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a9ee3c640b1c46dc87157d7e1186db9bc">AreAnyDispatchersReady</a> (void) const </td></tr>
<tr class="separator:a9ee3c640b1c46dc87157d7e1186db9bc inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dd84e1f8c210b971b9b08f89b8af10 inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a36dd84e1f8c210b971b9b08f89b8af10">Barrier</a> (std::chrono::nanoseconds timeout)</td></tr>
<tr class="memdesc:a36dd84e1f8c210b971b9b08f89b8af10 inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until all dispatchers on the <a class="el" href="class_dispatch_queue.html" title="This is an asynchronous queue of zero-argument functions ">DispatchQueue</a> at the time of the call have been dispatched  <a href="#a36dd84e1f8c210b971b9b08f89b8af10">More...</a><br /></td></tr>
<tr class="separator:a36dd84e1f8c210b971b9b08f89b8af10 inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202af0ec4502042b5fb32c0dfc4cdfa8 inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a202af0ec4502042b5fb32c0dfc4cdfa8">Barrier</a> (void)</td></tr>
<tr class="memdesc:a202af0ec4502042b5fb32c0dfc4cdfa8 inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the timed version of Barrier, but does not time out  <a href="#a202af0ec4502042b5fb32c0dfc4cdfa8">More...</a><br /></td></tr>
<tr class="separator:a202af0ec4502042b5fb32c0dfc4cdfa8 inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94131c04ad4d1513cc411870fc6b002 inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#af94131c04ad4d1513cc411870fc6b002">DispatchAllEvents</a> (void)</td></tr>
<tr class="memdesc:af94131c04ad4d1513cc411870fc6b002 inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to DispatchEvent, but will attempt to dispatch all events currently queued  <a href="#af94131c04ad4d1513cc411870fc6b002">More...</a><br /></td></tr>
<tr class="separator:af94131c04ad4d1513cc411870fc6b002 inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cf0ed4b428ecbee03fb64a0e705ce7 inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#ae4cf0ed4b428ecbee03fb64a0e705ce7">DispatchEvent</a> (void)</td></tr>
<tr class="memdesc:ae4cf0ed4b428ecbee03fb64a0e705ce7 inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to WaitForEvent, but does not block  <a href="#ae4cf0ed4b428ecbee03fb64a0e705ce7">More...</a><br /></td></tr>
<tr class="separator:ae4cf0ed4b428ecbee03fb64a0e705ce7 inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead80f32b70b6c6ee5acffb2b083724a inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#aead80f32b70b6c6ee5acffb2b083724a">GetDispatchQueueLength</a> (void) const </td></tr>
<tr class="separator:aead80f32b70b6c6ee5acffb2b083724a inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993c2a6b31496f06d47079a56086a507 inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a993c2a6b31496f06d47079a56086a507">operator+=</a> (<a class="el" href="class_dispatch_queue.html">DispatchQueue</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a993c2a6b31496f06d47079a56086a507 inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the contents of the dispatch queue on the right-hand side for handling by this queue  <a href="#a993c2a6b31496f06d47079a56086a507">More...</a><br /></td></tr>
<tr class="separator:a993c2a6b31496f06d47079a56086a507 inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef60c207a481b40c252b120ff366fe5 inherit pub_methods_class_dispatch_queue"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:a4ef60c207a481b40c252b120ff366fe5 inherit pub_methods_class_dispatch_queue"><td class="memTemplItemLeft" align="right" valign="top">DispatchThunkDelayedExpressionRel&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a4ef60c207a481b40c252b120ff366fe5">operator+=</a> (std::chrono::duration&lt; Rep, Period &gt; rhs)</td></tr>
<tr class="memdesc:a4ef60c207a481b40c252b120ff366fe5 inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for the introduction of a delayed dispatch thunk  <a href="#a4ef60c207a481b40c252b120ff366fe5">More...</a><br /></td></tr>
<tr class="separator:a4ef60c207a481b40c252b120ff366fe5 inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef21ddeababdb9cc0fffa7f9f5d557f inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">DispatchThunkDelayedExpressionAbs&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a5ef21ddeababdb9cc0fffa7f9f5d557f">operator+=</a> (std::chrono::steady_clock::time_point rhs)</td></tr>
<tr class="memdesc:a5ef21ddeababdb9cc0fffa7f9f5d557f inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for absolute-time based delayed dispatch thunk  <a href="#a5ef21ddeababdb9cc0fffa7f9f5d557f">More...</a><br /></td></tr>
<tr class="separator:a5ef21ddeababdb9cc0fffa7f9f5d557f inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada43ba9a08cec6888a103f94f6e2dabb inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#ada43ba9a08cec6888a103f94f6e2dabb">operator+=</a> (DispatchThunkDelayed &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ada43ba9a08cec6888a103f94f6e2dabb inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly pends a delayed dispatch thunk  <a href="#ada43ba9a08cec6888a103f94f6e2dabb">More...</a><br /></td></tr>
<tr class="separator:ada43ba9a08cec6888a103f94f6e2dabb inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfd34970fbfca53f0d3b10cbb9c433c inherit pub_methods_class_dispatch_queue"><td class="memTemplParams" colspan="2">template&lt;class _Fx &gt; </td></tr>
<tr class="memitem:a8dfd34970fbfca53f0d3b10cbb9c433c inherit pub_methods_class_dispatch_queue"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a8dfd34970fbfca53f0d3b10cbb9c433c">operator+=</a> (_Fx &amp;&amp;fx)</td></tr>
<tr class="memdesc:a8dfd34970fbfca53f0d3b10cbb9c433c inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic overload which will pend an arbitrary dispatch type  <a href="#a8dfd34970fbfca53f0d3b10cbb9c433c">More...</a><br /></td></tr>
<tr class="separator:a8dfd34970fbfca53f0d3b10cbb9c433c inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457e780c30d55fffc706892e1ebb160a inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a457e780c30d55fffc706892e1ebb160a">SuggestSoonestWakeupTimeUnsafe</a> (std::chrono::steady_clock::time_point latestTime) const </td></tr>
<tr class="memdesc:a457e780c30d55fffc706892e1ebb160a inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recommends a point in time to wake up to check for events  <a href="#a457e780c30d55fffc706892e1ebb160a">More...</a><br /></td></tr>
<tr class="separator:a457e780c30d55fffc706892e1ebb160a inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304588a65ecc0712c3aafe0461c73f1b inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a304588a65ecc0712c3aafe0461c73f1b">WaitForEvent</a> (void)</td></tr>
<tr class="memdesc:a304588a65ecc0712c3aafe0461c73f1b inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until a lambda function is ready to run in this thread's dispatch queue, dispatches the function, and then returns.  <a href="#a304588a65ecc0712c3aafe0461c73f1b">More...</a><br /></td></tr>
<tr class="separator:a304588a65ecc0712c3aafe0461c73f1b inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa284e235b0971d36bd858dc320c1a853 inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#aa284e235b0971d36bd858dc320c1a853">WaitForEvent</a> (std::chrono::milliseconds milliseconds)</td></tr>
<tr class="memdesc:aa284e235b0971d36bd858dc320c1a853 inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until a lambda function in the dispatch queue is ready to run or the specified time period elapses, whichever comes first.  <a href="#aa284e235b0971d36bd858dc320c1a853">More...</a><br /></td></tr>
<tr class="separator:aa284e235b0971d36bd858dc320c1a853 inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e2d4588e439c8a0425ce0c50dc0f25 inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#ad9e2d4588e439c8a0425ce0c50dc0f25">WaitForEvent</a> (std::chrono::steady_clock::time_point wakeTime)</td></tr>
<tr class="memdesc:ad9e2d4588e439c8a0425ce0c50dc0f25 inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until a lambda function in the dispatch queue is ready to run or the specified time is reached, whichever comes first.  <a href="#ad9e2d4588e439c8a0425ce0c50dc0f25">More...</a><br /></td></tr>
<tr class="separator:ad9e2d4588e439c8a0425ce0c50dc0f25 inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3293e212f176ae7a11cbb4690cce71 inherit pub_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#afd3293e212f176ae7a11cbb4690cce71">WakeAllWaitingThreads</a> (void)</td></tr>
<tr class="memdesc:afd3293e212f176ae7a11cbb4690cce71 inherit pub_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes all calls to WaitForEvent to return control to their callers  <a href="#afd3293e212f176ae7a11cbb4690cce71">More...</a><br /></td></tr>
<tr class="separator:afd3293e212f176ae7a11cbb4690cce71 inherit pub_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a90d73c0f622ae1cdb94a7a1ccb355a83"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_thread.html#a90d73c0f622ae1cdb94a7a1ccb355a83">DoRunLoopCleanup</a> (std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; &amp;&amp;ctxt, std::shared_ptr&lt; CoreObject &gt; &amp;&amp;refTracker) override</td></tr>
<tr class="memdesc:a90d73c0f622ae1cdb94a7a1ccb355a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overridden here so we can rundown the dispatch queue  <a href="#a90d73c0f622ae1cdb94a7a1ccb355a83">More...</a><br /></td></tr>
<tr class="separator:a90d73c0f622ae1cdb94a7a1ccb355a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_basic_thread"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_basic_thread')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_basic_thread.html">BasicThread</a></td></tr>
<tr class="memitem:aec8c9fa548fc917627ab1806309c5747 inherit pro_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#aec8c9fa548fc917627ab1806309c5747">DoAdditionalWait</a> (void) override</td></tr>
<tr class="memdesc:aec8c9fa548fc917627ab1806309c5747 inherit pro_methods_class_basic_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Untimed variant of DoAdditionalWait  <a href="#aec8c9fa548fc917627ab1806309c5747">More...</a><br /></td></tr>
<tr class="separator:aec8c9fa548fc917627ab1806309c5747 inherit pro_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a1abcadf00639a64c02fc0ab2785f3 inherit pro_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a43a1abcadf00639a64c02fc0ab2785f3">DoAdditionalWait</a> (std::chrono::nanoseconds timeout) override</td></tr>
<tr class="memdesc:a43a1abcadf00639a64c02fc0ab2785f3 inherit pro_methods_class_basic_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked just before control is returned to the user.  <a href="#a43a1abcadf00639a64c02fc0ab2785f3">More...</a><br /></td></tr>
<tr class="separator:a43a1abcadf00639a64c02fc0ab2785f3 inherit pro_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac69a4f359aab347371e9e1c11a9dd41 inherit pro_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#aac69a4f359aab347371e9e1c11a9dd41">DoRun</a> (std::shared_ptr&lt; CoreObject &gt; &amp;&amp;refTracker)</td></tr>
<tr class="memdesc:aac69a4f359aab347371e9e1c11a9dd41 inherit pro_methods_class_basic_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine that sets up the necessary extranea before a call to Run  <a href="#aac69a4f359aab347371e9e1c11a9dd41">More...</a><br /></td></tr>
<tr class="separator:aac69a4f359aab347371e9e1c11a9dd41 inherit pro_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208ccf918f0a440e2c6c53c2ac835a37 inherit pro_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">std::mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a208ccf918f0a440e2c6c53c2ac835a37">GetLock</a> (void) const </td></tr>
<tr class="memdesc:a208ccf918f0a440e2c6c53c2ac835a37 inherit pro_methods_class_basic_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers a general lock used to synchronize entities in this thread internally.  <a href="#a208ccf918f0a440e2c6c53c2ac835a37">More...</a><br /></td></tr>
<tr class="separator:a208ccf918f0a440e2c6c53c2ac835a37 inherit pro_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64061568019d519e3a27d1d3a840c741 inherit pro_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a64061568019d519e3a27d1d3a840c741">OnStart</a> () override</td></tr>
<tr class="memdesc:a64061568019d519e3a27d1d3a840c741 inherit pro_methods_class_basic_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a new thread to be created in which the Run method will be invoked  <a href="#a64061568019d519e3a27d1d3a840c741">More...</a><br /></td></tr>
<tr class="separator:a64061568019d519e3a27d1d3a840c741 inherit pro_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fa3d56f8a17a6a8244aeab10fff577 inherit pro_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#ac6fa3d56f8a17a6a8244aeab10fff577">PerformStatusUpdate</a> (const std::function&lt; void()&gt; &amp;fn) const </td></tr>
<tr class="memdesc:ac6fa3d56f8a17a6a8244aeab10fff577 inherit pro_methods_class_basic_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a mutex, invokes the specified lambda function, and then updates the basic thread's state condition.  <a href="#ac6fa3d56f8a17a6a8244aeab10fff577">More...</a><br /></td></tr>
<tr class="separator:ac6fa3d56f8a17a6a8244aeab10fff577 inherit pro_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d8803cdc6ab28b1d79740b115487c5 inherit pro_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#aa6d8803cdc6ab28b1d79740b115487c5">SetCurrentThreadName</a> (void) const </td></tr>
<tr class="memdesc:aa6d8803cdc6ab28b1d79740b115487c5 inherit pro_methods_class_basic_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a name to the thread, displayed in debuggers.  <a href="#aa6d8803cdc6ab28b1d79740b115487c5">More...</a><br /></td></tr>
<tr class="separator:aa6d8803cdc6ab28b1d79740b115487c5 inherit pro_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8057883725bfbfedd44b2f4ab471a6 inherit pro_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a4b8057883725bfbfedd44b2f4ab471a6">WaitForStateUpdate</a> (const std::function&lt; bool()&gt; &amp;fn) const </td></tr>
<tr class="memdesc:a4b8057883725bfbfedd44b2f4ab471a6 inherit pro_methods_class_basic_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the specified lambda function returns true or the thread shuts down.  <a href="#a4b8057883725bfbfedd44b2f4ab471a6">More...</a><br /></td></tr>
<tr class="separator:a4b8057883725bfbfedd44b2f4ab471a6 inherit pro_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_core_runnable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_core_runnable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_core_runnable.html">CoreRunnable</a></td></tr>
<tr class="memitem:a7d2c7498d9db4e8f76dc2b6a69d8f1bc inherit pro_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; CoreObject &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a7d2c7498d9db4e8f76dc2b6a69d8f1bc">GetOutstanding</a> (void) const </td></tr>
<tr class="separator:a7d2c7498d9db4e8f76dc2b6a69d8f1bc inherit pro_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_dispatch_queue"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_dispatch_queue')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_dispatch_queue.html">DispatchQueue</a></td></tr>
<tr class="memitem:a7c909a2f706599e2aeaea163afc43d2a inherit pro_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a7c909a2f706599e2aeaea163afc43d2a">DispatchEventUnsafe</a> (std::unique_lock&lt; std::mutex &gt; &amp;lk)</td></tr>
<tr class="memdesc:a7c909a2f706599e2aeaea163afc43d2a inherit pro_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to DispatchEvent, except assumes that the dispatch lock is currently held  <a href="#a7c909a2f706599e2aeaea163afc43d2a">More...</a><br /></td></tr>
<tr class="separator:a7c909a2f706599e2aeaea163afc43d2a inherit pro_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7d922485f14bdbb72559df2e009b40 inherit pro_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a6c7d922485f14bdbb72559df2e009b40">OnPended</a> (std::unique_lock&lt; std::mutex &gt; &amp;&amp;lk)</td></tr>
<tr class="memdesc:a6c7d922485f14bdbb72559df2e009b40 inherit pro_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility virtual, called whenever a new event is deferred  <a href="#a6c7d922485f14bdbb72559df2e009b40">More...</a><br /></td></tr>
<tr class="separator:a6c7d922485f14bdbb72559df2e009b40 inherit pro_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6603bb739523587631367935af2aea36 inherit pro_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a6603bb739523587631367935af2aea36">PendExisting</a> (std::unique_lock&lt; std::mutex &gt; &amp;&amp;lk, DispatchThunkBase *thunk)</td></tr>
<tr class="memdesc:a6603bb739523587631367935af2aea36 inherit pro_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches an element to the end of the dispatch queue without any checks.  <a href="#a6603bb739523587631367935af2aea36">More...</a><br /></td></tr>
<tr class="separator:a6603bb739523587631367935af2aea36 inherit pro_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad392c934d343fb56f8c233d2fbd6243b inherit pro_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#ad392c934d343fb56f8c233d2fbd6243b">PromoteReadyDispatchersUnsafe</a> (void)</td></tr>
<tr class="memdesc:ad392c934d343fb56f8c233d2fbd6243b inherit pro_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all ready events from the delayed queue into the dispatch queue  <a href="#ad392c934d343fb56f8c233d2fbd6243b">More...</a><br /></td></tr>
<tr class="separator:ad392c934d343fb56f8c233d2fbd6243b inherit pro_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e455ffdaece9c129717211f13752fa3 inherit pro_methods_class_dispatch_queue"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a6e455ffdaece9c129717211f13752fa3">SetDispatcherCap</a> (size_t dispatchCap)</td></tr>
<tr class="memdesc:a6e455ffdaece9c129717211f13752fa3 inherit pro_methods_class_dispatch_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the upper bound on the number of allowed pending dispatchers  <a href="#a6e455ffdaece9c129717211f13752fa3">More...</a><br /></td></tr>
<tr class="separator:a6e455ffdaece9c129717211f13752fa3 inherit pro_methods_class_dispatch_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_class_basic_thread"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_basic_thread')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_basic_thread.html">BasicThread</a></td></tr>
<tr class="memitem:ae9d8f1216df2a3f93b3b3a6a4c454fa0 inherit pub_static_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#ae9d8f1216df2a3f93b3b3a6a4c454fa0">ForceCoreThreadReidentify</a> (void)</td></tr>
<tr class="memdesc:ae9d8f1216df2a3f93b3b3a6a4c454fa0 inherit pub_static_methods_class_basic_thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces all Autowiring threads to reidentify themselves.  <a href="#ae9d8f1216df2a3f93b3b3a6a4c454fa0">More...</a><br /></td></tr>
<tr class="separator:ae9d8f1216df2a3f93b3b3a6a4c454fa0 inherit pub_static_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fbc237ea2f1034509db47d0ed2f639 inherit pub_static_methods_class_basic_thread"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#aa5fbc237ea2f1034509db47d0ed2f639">IsMainThread</a> (void)</td></tr>
<tr class="separator:aa5fbc237ea2f1034509db47d0ed2f639 inherit pub_static_methods_class_basic_thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the order added. </p>
<p>Create a <a class="el" href="class_core_thread.html" title="Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the ...">CoreThread</a> object by autowiring it to a context. You can then use the overloaded "+=" operator to add lambda functions to the dispatch queue. The core thread instance executes the functions in order.</p>
<div class="fragment"><div class="line"><a class="code" href="class_auto_create_context_t.html">AutoCreateContext</a> ctxt;</div>
<div class="line"><a class="code" href="class_current_context_pusher.html">CurrentContextPusher</a> pusher(ctxt);</div>
<div class="line"></div>
<div class="line"><a class="code" href="class_auto_required.html">AutoRequired&lt;CoreThread&gt;</a> runner;</div>
<div class="line">ctxt-&gt;Initiate();</div>
<div class="line"></div>
<div class="line">*runner += []{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Job ran.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> x = 0;</div>
<div class="line"><span class="keyword">auto</span> func = [&amp;x]{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Value of x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line">};</div>
<div class="line">x = 4;</div>
<div class="line">*runner += func;</div>
<div class="line">ctxt-&gt;SignalShutdown(<span class="keyword">true</span>);</div>
</div><!-- fragment --><p>When the <a class="el" href="class_core_thread.html" title="Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the ...">CoreThread</a> object receives the signal to shutdown, i.e from CoreContext::SignalShutdown(bool graceful), shutdown behavior depends on the graceful parameter. For graceful shutdown, the class completes the current job queue, but does not allow new jobs to be added to the queue. For immediate shutdown, the job queue is abandoned and the current job aborted. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_auto_net_example_8cpp-example.html#_a0">AutoNetExample.cpp</a>, and <a class="el" href="_thread_example_8cpp-example.html#_a2">ThreadExample.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a710618147be29bbee10455141ac9f713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CoreThread::CoreThread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pName</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a core thread object with an optional name.</p>
<p>The name assigned to a thread is visible in some debuggers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pName</td><td>An optional name for this thread.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a90d73c0f622ae1cdb94a7a1ccb355a83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CoreThread::DoRunLoopCleanup </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; CoreObject &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>refTracker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overridden here so we can rundown the dispatch queue </p>

<p>Reimplemented from <a class="el" href="class_basic_thread.html#afffae6629cda8683d6706e319bb81038">BasicThread</a>.</p>

</div>
</div>
<a class="anchor" id="ab4d06e78e0b2365c429c05bde674b1bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreThread::OnStop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when the thread should stop. Implement this method to perform any needed cleanup. </p>
<p>This method is called before the dispatch queue is aborted or run down. Users wishing to perform operations gracefully during termination should pend these operations as lambdas to the thread's dispatch queue; these lambdas will be invoked if graceful termination is requested, and destroyed without invocation otherwise.</p>
<p>Do not perform any time-consuming operations in this callback; the method may be called from a time-sensitive context and unacceptable system performance could result if long-duration operations are undertaken here.</p>
<p>The base implementation of this method is guaranteed to do nothing. </p>

<p>Reimplemented from <a class="el" href="class_basic_thread.html#a1186558c53eb71abc32af737376b44f3">BasicThread</a>.</p>

</div>
</div>
<a class="anchor" id="aaa00cb32629cf5f71d1dfe27342769a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreThread::OnStop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>graceful</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when the thread should stop. Override to perform custom handling when the thread is told to stop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graceful</td><td>Set to true to rundown the dispatch queue before quitting.</td></tr>
  </table>
  </dd>
</dl>
<p>This method is called when the thread should stop. When invoked, the value of <a class="el" href="class_core_runnable.html#a144421b84f8b8fee45838fbe2be6e5c6" title="Reports whether this runnable should stop. ">CoreThread::ShouldStop</a> is guaranteed to be true.</p>
<p>The default behavior is to terminate the job queue immediately if graceful is false. Otherwise, existing jobs in the queue are executed, but no new functions can be added to the dispatch queue.</p>
<p>Derived classes are not required to call <a class="el" href="class_core_thread.html#ab4d06e78e0b2365c429c05bde674b1bc" title="Invoked when the thread should stop. Implement this method to perform any needed cleanup. ">CoreThread::OnStop</a>. </p>

<p>Reimplemented from <a class="el" href="class_basic_thread.html#abb056d8402460ea96e350e2b9dcc2f4d">BasicThread</a>.</p>

</div>
</div>
<a class="anchor" id="a3268ba6d9cb6ff14272ba50a17e9fe9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreThread::Run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins thread execution. </p>
<p>Implement this function to perform the work to be done by this thread. Your <a class="el" href="class_core_thread.html#a3268ba6d9cb6ff14272ba50a17e9fe9f" title="Begins thread execution. ">Run()</a> function implementation must exit when <a class="el" href="class_core_runnable.html#a144421b84f8b8fee45838fbe2be6e5c6" title="Reports whether this runnable should stop. ">ShouldStop()</a> becomes true.</p>
<p>BasicThreads can be stopped gracefully or immediately. Override <a class="el" href="class_core_thread.html#aaa00cb32629cf5f71d1dfe27342769a8" title="Invoked when the thread should stop. Override to perform custom handling when the thread is told to s...">OnStop(bool graceful)</a> to implement different behavior for these two shutdown modes. For example, if the shutdown mode is immediate, you might abort any actions in progress, but if the mode is graceful, you might take time to save files, etc. This behavior is application defined. Autowiring does not impose its own requirements. You can also perform custom shutdown cleanup in an <a class="el" href="class_core_thread.html#ab4d06e78e0b2365c429c05bde674b1bc" title="Invoked when the thread should stop. Implement this method to perform any needed cleanup. ">OnStop()</a> implementation.</p>
<p>The default implementation of Run will simply call WaitForEvent in a loop until it's told to quit. </p>

<p>Implements <a class="el" href="class_basic_thread.html#aca183b811e4f93dfce70a449649b3033">BasicThread</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autowiring/<a class="el" href="_core_thread_8h_source.html">CoreThread.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_core_thread.html">CoreThread</a></li>
    <li class="footer">Generated on Wed Jan 6 2016 16:25:20 for Autowiring by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
