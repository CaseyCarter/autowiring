<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Autowiring: BasicThread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.7.6</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Developer's&#160;Guide</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_basic_thread.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_basic_thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BasicThread Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstract class for creating a thread with a single Run method.  
 <a href="class_basic_thread.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_basic_thread_8h_source.html">BasicThread.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BasicThread:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_basic_thread.png" usemap="#BasicThread_map" alt=""/>
  <map id="BasicThread_map" name="BasicThread_map">
<area href="class_context_member.html" title="A class that must be inherited in order to be a member of a context heriarchy " alt="ContextMember" shape="rect" coords="0,0,100,24"/>
<area href="class_core_runnable.html" title="Provides the interface for threads that should receive start and stop notifications in a context ..." alt="CoreRunnable" shape="rect" coords="110,0,210,24"/>
<area href="class_core_thread.html" title="Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the ..." alt="CoreThread" shape="rect" coords="55,112,155,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aefcc009fa192036be9ea4d11218612a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#aefcc009fa192036be9ea4d11218612a4">BasicThread</a> (const char *pName=nullptr)</td></tr>
<tr class="separator:aefcc009fa192036be9ea4d11218612a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6274398126caa21fe3d9e37a46360ca7"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a6274398126caa21fe3d9e37a46360ca7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a6274398126caa21fe3d9e37a46360ca7">AddTeardownListener</a> (Fx &amp;&amp;listener)</td></tr>
<tr class="memdesc:a6274398126caa21fe3d9e37a46360ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a function object which will be called when this <a class="el" href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. ">BasicThread</a> stops running or is destroyed  <a href="#a6274398126caa21fe3d9e37a46360ca7">More...</a><br /></td></tr>
<tr class="separator:a6274398126caa21fe3d9e37a46360ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f756d73ea97f88a9d12f6e0708f1cf8"><td class="memItemLeft" align="right" valign="top">std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a6f756d73ea97f88a9d12f6e0708f1cf8">GetCreationTime</a> (void)</td></tr>
<tr class="memdesc:a6f756d73ea97f88a9d12f6e0708f1cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread creation time.  <a href="#a6f756d73ea97f88a9d12f6e0708f1cf8">More...</a><br /></td></tr>
<tr class="separator:a6f756d73ea97f88a9d12f6e0708f1cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643d476885ee38306b061d7fb37c126f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a643d476885ee38306b061d7fb37c126f">GetThreadTimes</a> (std::chrono::milliseconds &amp;kernelTime, std::chrono::milliseconds &amp;userTime)</td></tr>
<tr class="memdesc:a643d476885ee38306b061d7fb37c126f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports kernel and user mode running times for this thread.  <a href="#a643d476885ee38306b061d7fb37c126f">More...</a><br /></td></tr>
<tr class="separator:a643d476885ee38306b061d7fb37c126f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6d0e971236f28d25eaef0bffb6181e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a2c6d0e971236f28d25eaef0bffb6181e">IsCompleted</a> (void) const </td></tr>
<tr class="separator:a2c6d0e971236f28d25eaef0bffb6181e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1186558c53eb71abc32af737376b44f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a1186558c53eb71abc32af737376b44f3">OnStop</a> (void)</td></tr>
<tr class="memdesc:a1186558c53eb71abc32af737376b44f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by the base class <a class="el" href="class_core_runnable.html#a41c3338adf9bf7222b13bbafb564dabb" title="Stops this runnable. ">Stop()</a> method. Implement this method to perform any needed cleanup.  <a href="#a1186558c53eb71abc32af737376b44f3">More...</a><br /></td></tr>
<tr class="separator:a1186558c53eb71abc32af737376b44f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca183b811e4f93dfce70a449649b3033"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#aca183b811e4f93dfce70a449649b3033">Run</a> ()=0</td></tr>
<tr class="memdesc:aca183b811e4f93dfce70a449649b3033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins thread execution.  <a href="#aca183b811e4f93dfce70a449649b3033">More...</a><br /></td></tr>
<tr class="separator:aca183b811e4f93dfce70a449649b3033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_context_member"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_context_member')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_context_member.html">ContextMember</a></td></tr>
<tr class="memitem:a256451cd0e6dfb1b9c6312cd2b0a4129 inherit pub_methods_class_context_member"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_context_member.html#a256451cd0e6dfb1b9c6312cd2b0a4129">GetContext</a> (void) const </td></tr>
<tr class="memdesc:a256451cd0e6dfb1b9c6312cd2b0a4129 inherit pub_methods_class_context_member"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the context associated with this object.  <a href="#a256451cd0e6dfb1b9c6312cd2b0a4129">More...</a><br /></td></tr>
<tr class="separator:a256451cd0e6dfb1b9c6312cd2b0a4129 inherit pub_methods_class_context_member"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57af82464416e1763e1d04c50b4c89c inherit pub_methods_class_context_member"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac57af82464416e1763e1d04c50b4c89c inherit pub_methods_class_context_member"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_context_member.html#ac57af82464416e1763e1d04c50b4c89c">GetSelf</a> (void)</td></tr>
<tr class="memdesc:ac57af82464416e1763e1d04c50b4c89c inherit pub_methods_class_context_member"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer that refers to ourselves  <a href="#ac57af82464416e1763e1d04c50b4c89c">More...</a><br /></td></tr>
<tr class="separator:ac57af82464416e1763e1d04c50b4c89c inherit pub_methods_class_context_member"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e73ac0659e22117582b903b81d2b18 inherit pub_methods_class_context_member"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_context_member.html#a34e73ac0659e22117582b903b81d2b18">NotifyContextTeardown</a> (void)</td></tr>
<tr class="memdesc:a34e73ac0659e22117582b903b81d2b18 inherit pub_methods_class_context_member"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by the parent context when the parent context is about to be destroyed  <a href="#a34e73ac0659e22117582b903b81d2b18">More...</a><br /></td></tr>
<tr class="separator:a34e73ac0659e22117582b903b81d2b18 inherit pub_methods_class_context_member"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_core_runnable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_core_runnable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_core_runnable.html">CoreRunnable</a></td></tr>
<tr class="memitem:ab13799735ef39ebe372f9851395a7f53 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab13799735ef39ebe372f9851395a7f53"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#ab13799735ef39ebe372f9851395a7f53">IsRunning</a> (void) const </td></tr>
<tr class="memdesc:ab13799735ef39ebe372f9851395a7f53 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this runnable is currently running. <br /></td></tr>
<tr class="separator:ab13799735ef39ebe372f9851395a7f53 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144421b84f8b8fee45838fbe2be6e5c6 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a144421b84f8b8fee45838fbe2be6e5c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a144421b84f8b8fee45838fbe2be6e5c6">ShouldStop</a> (void) volatile const </td></tr>
<tr class="memdesc:a144421b84f8b8fee45838fbe2be6e5c6 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this runnable should stop. <br /></td></tr>
<tr class="separator:a144421b84f8b8fee45838fbe2be6e5c6 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5e7e482f70200b82d8f0d489eedd12 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a4f5e7e482f70200b82d8f0d489eedd12">Start</a> (std::shared_ptr&lt; CoreObject &gt; outstanding)</td></tr>
<tr class="memdesc:a4f5e7e482f70200b82d8f0d489eedd12 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes this runnable to begin processing.  <a href="#a4f5e7e482f70200b82d8f0d489eedd12">More...</a><br /></td></tr>
<tr class="separator:a4f5e7e482f70200b82d8f0d489eedd12 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c3338adf9bf7222b13bbafb564dabb inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a41c3338adf9bf7222b13bbafb564dabb">Stop</a> (bool graceful=true)</td></tr>
<tr class="memdesc:a41c3338adf9bf7222b13bbafb564dabb inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops this runnable.  <a href="#a41c3338adf9bf7222b13bbafb564dabb">More...</a><br /></td></tr>
<tr class="separator:a41c3338adf9bf7222b13bbafb564dabb inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaa1a6490b1b7d16fa63b64a012a9f0 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a0aaa1a6490b1b7d16fa63b64a012a9f0">ThreadSleep</a> (std::chrono::nanoseconds timeout)</td></tr>
<tr class="memdesc:a0aaa1a6490b1b7d16fa63b64a012a9f0 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeps this thread for the specified duration.  <a href="#a0aaa1a6490b1b7d16fa63b64a012a9f0">More...</a><br /></td></tr>
<tr class="separator:a0aaa1a6490b1b7d16fa63b64a012a9f0 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3c019cfe57942e293c9cec805828e7 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#acb3c019cfe57942e293c9cec805828e7">Wait</a> (void)</td></tr>
<tr class="memdesc:acb3c019cfe57942e293c9cec805828e7 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits indefinitely. Returns when this runnable stops.  <a href="#acb3c019cfe57942e293c9cec805828e7">More...</a><br /></td></tr>
<tr class="separator:acb3c019cfe57942e293c9cec805828e7 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4856481bde70b25d28bac86876cadf88 inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a4856481bde70b25d28bac86876cadf88">WaitFor</a> (std::chrono::nanoseconds timeout)</td></tr>
<tr class="memdesc:a4856481bde70b25d28bac86876cadf88 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the specified amount of time.  <a href="#a4856481bde70b25d28bac86876cadf88">More...</a><br /></td></tr>
<tr class="separator:a4856481bde70b25d28bac86876cadf88 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b6ac4ade1032ea1411680a04592d87 inherit pub_methods_class_core_runnable"><td class="memTemplParams" colspan="2">template&lt;typename TimeType &gt; </td></tr>
<tr class="memitem:aa8b6ac4ade1032ea1411680a04592d87 inherit pub_methods_class_core_runnable"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#aa8b6ac4ade1032ea1411680a04592d87">WaitUntil</a> (TimeType timepoint)</td></tr>
<tr class="memdesc:aa8b6ac4ade1032ea1411680a04592d87 inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the specified time.  <a href="#aa8b6ac4ade1032ea1411680a04592d87">More...</a><br /></td></tr>
<tr class="separator:aa8b6ac4ade1032ea1411680a04592d87 inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7811af34bc57739faeefbf64415f819c inherit pub_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7811af34bc57739faeefbf64415f819c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a7811af34bc57739faeefbf64415f819c">WasStarted</a> (void) volatile const </td></tr>
<tr class="memdesc:a7811af34bc57739faeefbf64415f819c inherit pub_methods_class_core_runnable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this runnable was ever started. <br /></td></tr>
<tr class="separator:a7811af34bc57739faeefbf64415f819c inherit pub_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae9d8f1216df2a3f93b3b3a6a4c454fa0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#ae9d8f1216df2a3f93b3b3a6a4c454fa0">ForceCoreThreadReidentify</a> (void)</td></tr>
<tr class="memdesc:ae9d8f1216df2a3f93b3b3a6a4c454fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces all Autowiring threads to reidentify themselves.  <a href="#ae9d8f1216df2a3f93b3b3a6a4c454fa0">More...</a><br /></td></tr>
<tr class="separator:ae9d8f1216df2a3f93b3b3a6a4c454fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fbc237ea2f1034509db47d0ed2f639"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#aa5fbc237ea2f1034509db47d0ed2f639">IsMainThread</a> (void)</td></tr>
<tr class="separator:aa5fbc237ea2f1034509db47d0ed2f639"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aec8c9fa548fc917627ab1806309c5747"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#aec8c9fa548fc917627ab1806309c5747">DoAdditionalWait</a> (void) override</td></tr>
<tr class="memdesc:aec8c9fa548fc917627ab1806309c5747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Untimed variant of DoAdditionalWait  <a href="#aec8c9fa548fc917627ab1806309c5747">More...</a><br /></td></tr>
<tr class="separator:aec8c9fa548fc917627ab1806309c5747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a1abcadf00639a64c02fc0ab2785f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a43a1abcadf00639a64c02fc0ab2785f3">DoAdditionalWait</a> (std::chrono::nanoseconds timeout) override</td></tr>
<tr class="memdesc:a43a1abcadf00639a64c02fc0ab2785f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked just before control is returned to the user.  <a href="#a43a1abcadf00639a64c02fc0ab2785f3">More...</a><br /></td></tr>
<tr class="separator:a43a1abcadf00639a64c02fc0ab2785f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac69a4f359aab347371e9e1c11a9dd41"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#aac69a4f359aab347371e9e1c11a9dd41">DoRun</a> (std::shared_ptr&lt; CoreObject &gt; &amp;&amp;refTracker)</td></tr>
<tr class="memdesc:aac69a4f359aab347371e9e1c11a9dd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine that sets up the necessary extranea before a call to Run  <a href="#aac69a4f359aab347371e9e1c11a9dd41">More...</a><br /></td></tr>
<tr class="separator:aac69a4f359aab347371e9e1c11a9dd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffae6629cda8683d6706e319bb81038"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#afffae6629cda8683d6706e319bb81038">DoRunLoopCleanup</a> (std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; &amp;&amp;ctxt, std::shared_ptr&lt; CoreObject &gt; &amp;&amp;refTracker)</td></tr>
<tr class="memdesc:afffae6629cda8683d6706e319bb81038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs all cleanup operations that must take place after <a class="el" href="class_basic_thread.html#aac69a4f359aab347371e9e1c11a9dd41" title="Routine that sets up the necessary extranea before a call to Run ">DoRun()</a>  <a href="#afffae6629cda8683d6706e319bb81038">More...</a><br /></td></tr>
<tr class="separator:afffae6629cda8683d6706e319bb81038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208ccf918f0a440e2c6c53c2ac835a37"><td class="memItemLeft" align="right" valign="top">std::mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a208ccf918f0a440e2c6c53c2ac835a37">GetLock</a> (void) const </td></tr>
<tr class="memdesc:a208ccf918f0a440e2c6c53c2ac835a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers a general lock used to synchronize entities in this thread internally.  <a href="#a208ccf918f0a440e2c6c53c2ac835a37">More...</a><br /></td></tr>
<tr class="separator:a208ccf918f0a440e2c6c53c2ac835a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64061568019d519e3a27d1d3a840c741"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a64061568019d519e3a27d1d3a840c741">OnStart</a> () override</td></tr>
<tr class="memdesc:a64061568019d519e3a27d1d3a840c741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a new thread to be created in which the Run method will be invoked  <a href="#a64061568019d519e3a27d1d3a840c741">More...</a><br /></td></tr>
<tr class="separator:a64061568019d519e3a27d1d3a840c741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb056d8402460ea96e350e2b9dcc2f4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#abb056d8402460ea96e350e2b9dcc2f4d">OnStop</a> (bool graceful) override</td></tr>
<tr class="memdesc:abb056d8402460ea96e350e2b9dcc2f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by the base class <a class="el" href="class_core_runnable.html#a41c3338adf9bf7222b13bbafb564dabb" title="Stops this runnable. ">Stop()</a> method. Override this method to perform any needed cleanup.  <a href="#abb056d8402460ea96e350e2b9dcc2f4d">More...</a><br /></td></tr>
<tr class="separator:abb056d8402460ea96e350e2b9dcc2f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fa3d56f8a17a6a8244aeab10fff577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#ac6fa3d56f8a17a6a8244aeab10fff577">PerformStatusUpdate</a> (const std::function&lt; void()&gt; &amp;fn) const </td></tr>
<tr class="memdesc:ac6fa3d56f8a17a6a8244aeab10fff577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a mutex, invokes the specified lambda function, and then updates the basic thread's state condition.  <a href="#ac6fa3d56f8a17a6a8244aeab10fff577">More...</a><br /></td></tr>
<tr class="separator:ac6fa3d56f8a17a6a8244aeab10fff577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d8803cdc6ab28b1d79740b115487c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#aa6d8803cdc6ab28b1d79740b115487c5">SetCurrentThreadName</a> (void) const </td></tr>
<tr class="memdesc:aa6d8803cdc6ab28b1d79740b115487c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a name to the thread, displayed in debuggers.  <a href="#aa6d8803cdc6ab28b1d79740b115487c5">More...</a><br /></td></tr>
<tr class="separator:aa6d8803cdc6ab28b1d79740b115487c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8057883725bfbfedd44b2f4ab471a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_basic_thread.html#a4b8057883725bfbfedd44b2f4ab471a6">WaitForStateUpdate</a> (const std::function&lt; bool()&gt; &amp;fn) const </td></tr>
<tr class="memdesc:a4b8057883725bfbfedd44b2f4ab471a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the specified lambda function returns true or the thread shuts down.  <a href="#a4b8057883725bfbfedd44b2f4ab471a6">More...</a><br /></td></tr>
<tr class="separator:a4b8057883725bfbfedd44b2f4ab471a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_core_runnable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_core_runnable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_core_runnable.html">CoreRunnable</a></td></tr>
<tr class="memitem:a7d2c7498d9db4e8f76dc2b6a69d8f1bc inherit pro_methods_class_core_runnable"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; CoreObject &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a7d2c7498d9db4e8f76dc2b6a69d8f1bc">GetOutstanding</a> (void) const </td></tr>
<tr class="separator:a7d2c7498d9db4e8f76dc2b6a69d8f1bc inherit pro_methods_class_core_runnable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An abstract class for creating a thread with a single Run method. </p>
<p>This is an abstract class that has a single <a class="el" href="class_basic_thread.html#aca183b811e4f93dfce70a449649b3033" title="Begins thread execution. ">Run()</a> method for implementation by derived classes. A <a class="el" href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. ">BasicThread</a> instance remains in the context as long as the thread is running, even if there are no other references to it.</p>
<p>To create a thread, extend <a class="el" href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. ">BasicThread</a> and implement the desired <a class="el" href="class_basic_thread.html#aca183b811e4f93dfce70a449649b3033" title="Begins thread execution. ">Run()</a> method. To start the thread, wire your thread object to a context and Initiate() the context. When the SignalShutown() or SignalTermination() methods of the owning context are called, or you call the <a class="el" href="class_basic_thread.html#a1186558c53eb71abc32af737376b44f3" title="Invoked by the base class Stop() method. Implement this method to perform any needed cleanup...">BasicThread::OnStop()</a> function, the <a class="el" href="class_core_runnable.html#a144421b84f8b8fee45838fbe2be6e5c6" title="Reports whether this runnable should stop. ">ShouldStop()</a> function will evaluate to true. It is your <a class="el" href="class_basic_thread.html#aca183b811e4f93dfce70a449649b3033" title="Begins thread execution. ">Run()</a> implementation's responsibility to terminate when <a class="el" href="class_core_runnable.html#a144421b84f8b8fee45838fbe2be6e5c6" title="Reports whether this runnable should stop. ">ShouldStop()</a> becomes true.</p>
<p>The following example prints out the sequence of prime numbers until the context signals that threads should shutdown:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PrimeGenerator : <span class="keyword">public</span> <a class="code" href="class_basic_thread.html">BasicThread</a> {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="class_basic_thread.html#aca183b811e4f93dfce70a449649b3033">Run</a>()<span class="keyword"> override </span>{</div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> test = 2;</div>
<div class="line">            <span class="keywordflow">while</span> (!<a class="code" href="class_core_runnable.html#a144421b84f8b8fee45838fbe2be6e5c6">ShouldStop</a>())</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> i = test/2; i &gt; 0 ; --i) {</div>
<div class="line">                    <span class="keywordflow">if</span> (i == 1) {</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;Prime: &quot;</span> &lt;&lt; test &lt;&lt; std::endl;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">if</span> (test % i == 0) {<span class="keywordflow">break</span>;}</div>
<div class="line">                }</div>
<div class="line">                test++;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="class_auto_create_context_t.html">AutoCreateContext</a> ctxt;</div>
<div class="line"><a class="code" href="class_current_context_pusher.html">CurrentContextPusher</a> pusher(ctxt);</div>
<div class="line"><a class="code" href="class_auto_required.html">AutoRequired&lt;PrimeGenerator&gt;</a> generator;</div>
<div class="line"></div>
<div class="line">ctxt-&gt;Initiate();</div>
<div class="line">ctxt-&gt;Wait(std::chrono::milliseconds(100));</div>
<div class="line">ctxt-&gt;SignalShutdown(<span class="keyword">true</span>);</div>
</div><!-- fragment --> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="_thread_example_8cpp-example.html#_a0">ThreadExample.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aefcc009fa192036be9ea4d11218612a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BasicThread::BasicThread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pName</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. ">BasicThread</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pName</td><td>An optional name for this thread. The name is visible in some debuggers.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6274398126caa21fe3d9e37a46360ca7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BasicThread::AddTeardownListener </td>
          <td>(</td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a function object which will be called when this <a class="el" href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. ">BasicThread</a> stops running or is destroyed </p>
<p>The listener is invoked before the destruction of this <a class="el" href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. ">BasicThread</a> and also immediately after the <a class="el" href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. ">BasicThread</a> instance has transitioned to the Stopped state.</p>
<p>Users who attach a teardown listener MUST NOT attempt to invoke any methods not defined by <a class="el" href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. ">BasicThread</a>, and MUST NOT attempt to invoke any non-final virtual functions available here. The object itself may be partially destroyed by the time the listener is invoked, and virtual methods may not have the expected behavior.</p>
<p>It is guaranteed to be safe to call any non-virtual method defined by <a class="el" href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. ">BasicThread</a> from a teardown listener. </p>

</div>
</div>
<a class="anchor" id="aec8c9fa548fc917627ab1806309c5747"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BasicThread::DoAdditionalWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Untimed variant of DoAdditionalWait </p>

<p>Reimplemented from <a class="el" href="class_core_runnable.html#af3c2a762acf2fd367f09fff1100231da">CoreRunnable</a>.</p>

</div>
</div>
<a class="anchor" id="a43a1abcadf00639a64c02fc0ab2785f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BasicThread::DoAdditionalWait </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked just before control is returned to the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The maximum amount of time to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the wait succeeded, false if a timeout occurred</dd></dl>
<p>This virtual method provides implementors with a way to add further constraints to the wait operation beyond the condition variable held internally by this <a class="el" href="class_core_runnable.html" title="Provides the interface for threads that should receive start and stop notifications in a context ...">CoreRunnable</a>.</p>
<p>This method must return true if the timeout is indefinite. </p>

<p>Reimplemented from <a class="el" href="class_core_runnable.html#acfcf01282cf908f91218bfdd5601678c">CoreRunnable</a>.</p>

</div>
</div>
<a class="anchor" id="aac69a4f359aab347371e9e1c11a9dd41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BasicThread::DoRun </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; CoreObject &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>refTracker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Routine that sets up the necessary extranea before a call to Run </p>
<p>Clients who wish to trigger teardown may release the reference to the passed refTracker instance. If this thread is the last thread holding a reference to this context, then after the point where the reference is released, [this] will be deleted. Clients should be careful to hold their own references to refTracker before calling DoRun if they intend to reference member data on function return. This method will always release the shared pointer passed to it, typically as a last step before return, potentially triggering the case described above. </p>

</div>
</div>
<a class="anchor" id="afffae6629cda8683d6706e319bb81038"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BasicThread::DoRunLoopCleanup </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; CoreObject &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>refTracker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs all cleanup operations that must take place after <a class="el" href="class_basic_thread.html#aac69a4f359aab347371e9e1c11a9dd41" title="Routine that sets up the necessary extranea before a call to Run ">DoRun()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>The last reference to the enclosing context held by this thread</td></tr>
    <tr><td class="paramname">refTracker</td><td>A reference tracker held for as long as the cleanup operation is incomplete</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_core_thread.html#a90d73c0f622ae1cdb94a7a1ccb355a83">CoreThread</a>.</p>

</div>
</div>
<a class="anchor" id="ae9d8f1216df2a3f93b3b3a6a4c454fa0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void BasicThread::ForceCoreThreadReidentify </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces all Autowiring threads to reidentify themselves. </p>
<p>Calls SetThreadName() for each thread. </p>

</div>
</div>
<a class="anchor" id="a6f756d73ea97f88a9d12f6e0708f1cf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::steady_clock::time_point BasicThread::GetCreationTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The thread creation time. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the time when this thread was created. </dd></dl>
<p>If the thread has not yet run, this routine returns std::steady_clock::time_point::min </p>

</div>
</div>
<a class="anchor" id="a208ccf918f0a440e2c6c53c2ac835a37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex&amp; BasicThread::GetLock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers a general lock used to synchronize entities in this thread internally. </p>

</div>
</div>
<a class="anchor" id="a643d476885ee38306b061d7fb37c126f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BasicThread::GetThreadTimes </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>kernelTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>userTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports kernel and user mode running times for this thread. </p>
<p>This function is intended for debugging and performance reporting. It is used by the AutoNet server.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PrimeGenerator : <span class="keyword">public</span> <a class="code" href="class_basic_thread.html">BasicThread</a>{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">void</span> <a class="code" href="class_basic_thread.html#aca183b811e4f93dfce70a449649b3033">Run</a>()<span class="keyword"> override </span>{</div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> test = 2;</div>
<div class="line">            <span class="keywordflow">while</span> (!<a class="code" href="class_core_runnable.html#a144421b84f8b8fee45838fbe2be6e5c6">ShouldStop</a>())</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> i = test/2; i &gt; 0 ; --i) {</div>
<div class="line">                    <span class="keywordflow">if</span> (i == 1) {</div>
<div class="line">                        std::chrono::milliseconds kernelTime, userTime;</div>
<div class="line">                        this-&gt;<a class="code" href="class_basic_thread.html#a643d476885ee38306b061d7fb37c126f">GetThreadTimes</a>(kernelTime, userTime);</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;Calculated primes up to: &quot;</span> &lt;&lt; test</div>
<div class="line">                                  &lt;&lt; <span class="stringliteral">&quot; in &quot;</span> &lt;&lt; (&amp;kernelTime)-&gt;count() &lt;&lt; <span class="stringliteral">&quot; kernel ms &quot;</span></div>
<div class="line">                                  &lt;&lt; <span class="stringliteral">&quot;and &quot;</span> &lt;&lt; (&amp;userTime)-&gt;count() &lt;&lt; <span class="stringliteral">&quot; user ms.&quot;</span></div>
<div class="line">                                  &lt;&lt; std::endl;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">if</span> (test % i == 0) {<span class="keywordflow">break</span>;}</div>
<div class="line">                }</div>
<div class="line">                test++;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="class_auto_create_context_t.html">AutoCreateContext</a> ctxt;</div>
<div class="line"><a class="code" href="class_current_context_pusher.html">CurrentContextPusher</a> pusher(ctxt);</div>
<div class="line"></div>
<div class="line"><a class="code" href="class_auto_required.html">AutoRequired&lt;PrimeGenerator&gt;</a> timedPrimer;</div>
<div class="line">ctxt-&gt;Initiate();</div>
<div class="line">ctxt-&gt;Wait(std::chrono::milliseconds(100));</div>
<div class="line">ctxt-&gt;SignalShutdown(<span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2c6d0e971236f28d25eaef0bffb6181e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BasicThread::IsCompleted </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this thread has transitioned to a completed state </dd></dl>

</div>
</div>
<a class="anchor" id="aa5fbc237ea2f1034509db47d0ed2f639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool BasicThread::IsMainThread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the calling thread is the main thread </dd></dl>

</div>
</div>
<a class="anchor" id="a64061568019d519e3a27d1d3a840c741"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BasicThread::OnStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes a new thread to be created in which the Run method will be invoked </p>
<dl class="section return"><dt>Returns</dt><dd>True to indicate that the thread was started successfully, false if it was already started or cancelled</dd></dl>
<p>Note that this operation has an inherit race condition. Be careful to ensure that Start will not be called from more than one place on the same object. The thread will be invoked from the context which was active at the time the thread was created. </p>

<p>Reimplemented from <a class="el" href="class_core_runnable.html#aa72398f9348bd2b63fd9e040ee21f7e9">CoreRunnable</a>.</p>

</div>
</div>
<a class="anchor" id="abb056d8402460ea96e350e2b9dcc2f4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BasicThread::OnStop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>graceful</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked by the base class <a class="el" href="class_core_runnable.html#a41c3338adf9bf7222b13bbafb564dabb" title="Stops this runnable. ">Stop()</a> method. Override this method to perform any needed cleanup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graceful</td><td>Specifies whether the runnable should stop normally or whether it should exit as quickly as possible. </td></tr>
  </table>
  </dd>
</dl>
<p>This method will be called at most once from a passive level. </p>

<p>Reimplemented from <a class="el" href="class_core_runnable.html#ac2b1fc01ebff2aa052c13abe7be0d647">CoreRunnable</a>.</p>

<p>Reimplemented in <a class="el" href="class_core_thread.html#aaa00cb32629cf5f71d1dfe27342769a8">CoreThread</a>.</p>

</div>
</div>
<a class="anchor" id="a1186558c53eb71abc32af737376b44f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BasicThread::OnStop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked by the base class <a class="el" href="class_core_runnable.html#a41c3338adf9bf7222b13bbafb564dabb" title="Stops this runnable. ">Stop()</a> method. Implement this method to perform any needed cleanup. </p>
<p>Do not perform any time-consuming operations in this callback; the method may be called from a time-sensitive context and unacceptable system performance could result if long-duration operations are undertaken here.</p>
<p>Override the <a class="el" href="class_basic_thread.html#abb056d8402460ea96e350e2b9dcc2f4d" title="Invoked by the base class Stop() method. Override this method to perform any needed cleanup...">OnStop(bool graceful)</a> version of this function to handle immediate vs. graceful shutdown cleanup. </p>

<p>Reimplemented in <a class="el" href="class_core_thread.html#ab4d06e78e0b2365c429c05bde674b1bc">CoreThread</a>.</p>

</div>
</div>
<a class="anchor" id="ac6fa3d56f8a17a6a8244aeab10fff577"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BasicThread::PerformStatusUpdate </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a mutex, invokes the specified lambda function, and then updates the basic thread's state condition. </p>

</div>
</div>
<a class="anchor" id="aca183b811e4f93dfce70a449649b3033"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BasicThread::Run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins thread execution. </p>
<p>Implement this function to perform the work to be done by this thread. Your <a class="el" href="class_basic_thread.html#aca183b811e4f93dfce70a449649b3033" title="Begins thread execution. ">Run()</a> function implementation must exit when <a class="el" href="class_core_runnable.html#a144421b84f8b8fee45838fbe2be6e5c6" title="Reports whether this runnable should stop. ">ShouldStop()</a> becomes true.</p>
<p>BasicThreads can be stopped gracefully or immediately. Override <a class="el" href="class_basic_thread.html#abb056d8402460ea96e350e2b9dcc2f4d" title="Invoked by the base class Stop() method. Override this method to perform any needed cleanup...">OnStop(bool graceful)</a> to implement different behavior for these two shutdown modes. For example, if the shutdown mode is immediate, you might abort any actions in progress, but if the mode is graceful, you might take time to save files, etc. This behavior is application defined. Autowiring does not impose its own requirements. You can also perform custom shutdown cleanup in an <a class="el" href="class_basic_thread.html#a1186558c53eb71abc32af737376b44f3" title="Invoked by the base class Stop() method. Implement this method to perform any needed cleanup...">OnStop()</a> implementation.</p>
<p>The default implementation of Run will simply call WaitForEvent in a loop until it's told to quit. </p>

<p>Implemented in <a class="el" href="class_core_thread.html#a3268ba6d9cb6ff14272ba50a17e9fe9f">CoreThread</a>.</p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_thread_example_8cpp-example.html#a1">ThreadExample.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa6d8803cdc6ab28b1d79740b115487c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BasicThread::SetCurrentThreadName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a name to the thread, displayed in debuggers. </p>
<p>Some platforms allow the assignment of a thread name for identifying threads shown in a debugger window. This method provides a platform-independent way of doing setting this name for the current thread. </p>

</div>
</div>
<a class="anchor" id="a4b8057883725bfbfedd44b2f4ab471a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BasicThread::WaitForStateUpdate </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool()&gt; &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until the specified lambda function returns true or the thread shuts down. </p>
<p>The lambda function is called repeatedly until it evaluates to true. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autowiring/<a class="el" href="_basic_thread_8h_source.html">BasicThread.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_basic_thread.html">BasicThread</a></li>
    <li class="footer">Generated on Wed Jan 6 2016 16:27:05 for Autowiring by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
