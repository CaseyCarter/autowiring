<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Autowiring: SharedPointerSlotT&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="struct_shared_pointer_slot_t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SharedPointerSlotT&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for SharedPointerSlotT&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="struct_shared_pointer_slot_t.png" usemap="#SharedPointerSlotT&lt; T &gt;_map" alt=""/>
  <map id="SharedPointerSlotT&lt; T &gt;_map" name="SharedPointerSlotT&lt; T &gt;_map">
<area href="struct_shared_pointer_slot.html" title="Specialized space-invariant implementation of boost::any for shared pointers " alt="SharedPointerSlot" shape="rect" coords="0,0,152,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1bb54ddbc2dd98a55e5b0ad4e767f8d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bb54ddbc2dd98a55e5b0ad4e767f8d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SharedPointerSlotT</b> (const std::shared_ptr&lt; T &gt; &amp;rhs=std::shared_ptr&lt; T &gt;())</td></tr>
<tr class="separator:a1bb54ddbc2dd98a55e5b0ad4e767f8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0981809814bc8886d2c662657543a91"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot_t.html#ac0981809814bc8886d2c662657543a91">get</a> (void)</td></tr>
<tr class="separator:ac0981809814bc8886d2c662657543a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa9a63f90d995217cb7875b778e1755"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aa9a63f90d995217cb7875b778e1755"></a>
const std::shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> (void) const </td></tr>
<tr class="separator:a3aa9a63f90d995217cb7875b778e1755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00735e1de5622037db8f5d4ce2c1f253"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00735e1de5622037db8f5d4ce2c1f253"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>operator std::shared_ptr&lt; Object &gt;</b> (void) const override</td></tr>
<tr class="separator:a00735e1de5622037db8f5d4ce2c1f253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13062caee8befaee8ce960f837bc9931"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13062caee8befaee8ce960f837bc9931"></a>
virtual void *&#160;</td><td class="memItemRight" valign="bottom"><b>ptr</b> (void) override</td></tr>
<tr class="separator:a13062caee8befaee8ce960f837bc9931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee1416218450d62fed49942309ede1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ee1416218450d62fed49942309ede1c"></a>
virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><b>ptr</b> (void) const override</td></tr>
<tr class="separator:a9ee1416218450d62fed49942309ede1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7d7446251ef42583179d45023d1496"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot_t.html#acc7d7446251ef42583179d45023d1496">New</a> (void *pSpace, size_t nBytes) const override</td></tr>
<tr class="memdesc:acc7d7446251ef42583179d45023d1496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a placement new on the specified space with a type matching the current instance  <a href="#acc7d7446251ef42583179d45023d1496">More...</a><br /></td></tr>
<tr class="separator:acc7d7446251ef42583179d45023d1496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcdc2089264d26a91110bc9d01d7bd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot_t.html#affcdc2089264d26a91110bc9d01d7bd0">try_assign</a> (const std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt; &amp;rhs) override</td></tr>
<tr class="memdesc:affcdc2089264d26a91110bc9d01d7bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to dynamically assign this slot to the specified object without changing the current type  <a href="#affcdc2089264d26a91110bc9d01d7bd0">More...</a><br /></td></tr>
<tr class="separator:affcdc2089264d26a91110bc9d01d7bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9206fbe46e337d9f2a6fac583ef3ee38"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_slot_information_stump_base.html">SlotInformationStumpBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot_t.html#a9206fbe46e337d9f2a6fac583ef3ee38">GetSlotInformation</a> (void) const override</td></tr>
<tr class="memdesc:a9206fbe46e337d9f2a6fac583ef3ee38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to obtain a list of slots defined on this type, for reflection purposes  <a href="#a9206fbe46e337d9f2a6fac583ef3ee38">More...</a><br /></td></tr>
<tr class="separator:a9206fbe46e337d9f2a6fac583ef3ee38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939a86c42a2f4d10b48bd32c380cc914"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot_t.html#a939a86c42a2f4d10b48bd32c380cc914">empty</a> (void) const </td></tr>
<tr class="separator:a939a86c42a2f4d10b48bd32c380cc914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc6f13ca943efbaebff924d70939d10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbc6f13ca943efbaebff924d70939d10"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator bool</b> (void) const override</td></tr>
<tr class="separator:adbc6f13ca943efbaebff924d70939d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9fd7c9c32f22e591f01d3a62f11810"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot_t.html#a3f9fd7c9c32f22e591f01d3a62f11810">type</a> (void) const override</td></tr>
<tr class="separator:a3f9fd7c9c32f22e591f01d3a62f11810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ae517d2a6760d86839942257483703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot_t.html#a04ae517d2a6760d86839942257483703">reset</a> (void) override</td></tr>
<tr class="memdesc:a04ae517d2a6760d86839942257483703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears this type, if a shared pointer is currently held  <a href="#a04ae517d2a6760d86839942257483703">More...</a><br /></td></tr>
<tr class="separator:a04ae517d2a6760d86839942257483703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8815f400b50728d4aabd41e8c69d81"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1e8815f400b50728d4aabd41e8c69d81"></a>
template&lt;class U &gt; </td></tr>
<tr class="memitem:a1e8815f400b50728d4aabd41e8c69d81"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const std::shared_ptr&lt; U &gt; &amp;rhs) const </td></tr>
<tr class="separator:a1e8815f400b50728d4aabd41e8c69d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e0dae55903b110f161c0f03546b1d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3e0dae55903b110f161c0f03546b1d9"></a>
<a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const std::shared_ptr&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:af3e0dae55903b110f161c0f03546b1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697ab3fd937861b006b44085c400c9c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a697ab3fd937861b006b44085c400c9c6"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> (void) const </td></tr>
<tr class="separator:a697ab3fd937861b006b44085c400c9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97458164ba4c79aa06139443c453c56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa97458164ba4c79aa06139443c453c56"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (void) const </td></tr>
<tr class="separator:aa97458164ba4c79aa06139443c453c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_shared_pointer_slot"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_struct_shared_pointer_slot')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a></td></tr>
<tr class="memitem:aa262b092af3a0bd0d686a0ee4c875948 inherit pub_methods_struct_shared_pointer_slot"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa262b092af3a0bd0d686a0ee4c875948"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SharedPointerSlot</b> (const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;rhs)</td></tr>
<tr class="separator:aa262b092af3a0bd0d686a0ee4c875948 inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63f4aa89685ee5c189e9bdcd3462636 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplParams" colspan="2"><a class="anchor" id="af63f4aa89685ee5c189e9bdcd3462636"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af63f4aa89685ee5c189e9bdcd3462636 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SharedPointerSlot</b> (const std::shared_ptr&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:af63f4aa89685ee5c189e9bdcd3462636 inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9ad9e76105f72e459c253bfef788d5 inherit pub_methods_struct_shared_pointer_slot"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#acc9ad9e76105f72e459c253bfef788d5">shared_ptr</a> (void) const </td></tr>
<tr class="separator:acc9ad9e76105f72e459c253bfef788d5 inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a64c1fa173076432457e2daf338645 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a98a64c1fa173076432457e2daf338645 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#a98a64c1fa173076432457e2daf338645">init</a> (void)</td></tr>
<tr class="memdesc:a98a64c1fa173076432457e2daf338645 inherit pub_methods_struct_shared_pointer_slot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alters the type of this slot to match the specified type  <a href="#a98a64c1fa173076432457e2daf338645">More...</a><br /></td></tr>
<tr class="separator:a98a64c1fa173076432457e2daf338645 inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de1cdba907ea7e17a8dbb2d6885f838 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9de1cdba907ea7e17a8dbb2d6885f838 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#a9de1cdba907ea7e17a8dbb2d6885f838">is</a> (void) const </td></tr>
<tr class="separator:a9de1cdba907ea7e17a8dbb2d6885f838 inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3db751d8eb3461db3c912ff065ea31 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ade3db751d8eb3461db3c912ff065ea31 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplItemLeft" align="right" valign="top">const std::shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#ade3db751d8eb3461db3c912ff065ea31">as</a> (void) const </td></tr>
<tr class="memdesc:ade3db751d8eb3461db3c912ff065ea31 inherit pub_methods_struct_shared_pointer_slot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to coerce this type to the speceified type  <a href="#ade3db751d8eb3461db3c912ff065ea31">More...</a><br /></td></tr>
<tr class="separator:ade3db751d8eb3461db3c912ff065ea31 inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251406c973c5692a0c61aae91dd7743e inherit pub_methods_struct_shared_pointer_slot"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#a251406c973c5692a0c61aae91dd7743e">operator==</a> (const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a251406c973c5692a0c61aae91dd7743e inherit pub_methods_struct_shared_pointer_slot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison by reference. Comparison of unequal types always fails, even when different type casts of the same instance are referenced.  <a href="#a251406c973c5692a0c61aae91dd7743e">More...</a><br /></td></tr>
<tr class="separator:a251406c973c5692a0c61aae91dd7743e inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f97985c8158814321b0f02db9920b93 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f97985c8158814321b0f02db9920b93 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#a1f97985c8158814321b0f02db9920b93">operator&lt;</a> (const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a1f97985c8158814321b0f02db9920b93 inherit pub_methods_struct_shared_pointer_slot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default for std library sorting of unique elements. In order to enable strict ordering std::type_info::before is used.  <a href="#a1f97985c8158814321b0f02db9920b93">More...</a><br /></td></tr>
<tr class="separator:a1f97985c8158814321b0f02db9920b93 inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57999d9cd00bd9e24e83aa5fd97745a inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae57999d9cd00bd9e24e83aa5fd97745a inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#ae57999d9cd00bd9e24e83aa5fd97745a">operator&lt;=</a> (const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;rhs) const </td></tr>
<tr class="memdesc:ae57999d9cd00bd9e24e83aa5fd97745a inherit pub_methods_struct_shared_pointer_slot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default for std library sorting of repeatable elements. In order to enable strict ordering std::type_info::before is used.  <a href="#ae57999d9cd00bd9e24e83aa5fd97745a">More...</a><br /></td></tr>
<tr class="separator:ae57999d9cd00bd9e24e83aa5fd97745a inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb2013d9794c5e4fbb52801fc2a5f99 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplParams" colspan="2"><a class="anchor" id="afeb2013d9794c5e4fbb52801fc2a5f99"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afeb2013d9794c5e4fbb52801fc2a5f99 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;rhs) const </td></tr>
<tr class="separator:afeb2013d9794c5e4fbb52801fc2a5f99 inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea82921b301d0e477d8caf9b1754e5d inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeea82921b301d0e477d8caf9b1754e5d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aeea82921b301d0e477d8caf9b1754e5d inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;rhs) const </td></tr>
<tr class="separator:aeea82921b301d0e477d8caf9b1754e5d inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d43c7400abd1fe94ccb88cf7035ca0 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad7d43c7400abd1fe94ccb88cf7035ca0 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#ad7d43c7400abd1fe94ccb88cf7035ca0">operator==</a> (const std::shared_ptr&lt; T &gt; &amp;rhs) const </td></tr>
<tr class="memdesc:ad7d43c7400abd1fe94ccb88cf7035ca0 inherit pub_methods_struct_shared_pointer_slot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison by reference. Comparison of unequal types always fails, even when different type casts of the same instance are referenced.  <a href="#ad7d43c7400abd1fe94ccb88cf7035ca0">More...</a><br /></td></tr>
<tr class="separator:ad7d43c7400abd1fe94ccb88cf7035ca0 inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7c8c8b0e99aba6170a005fd897c6fb inherit pub_methods_struct_shared_pointer_slot"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#adc7c8c8b0e99aba6170a005fd897c6fb">operator==</a> (const std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt; &amp;rhs) const </td></tr>
<tr class="memdesc:adc7c8c8b0e99aba6170a005fd897c6fb inherit pub_methods_struct_shared_pointer_slot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the <a class="el" href="class_object.html" title="General object base, used to make conversions possible between various shared pointer implementations...">Object</a> base type  <a href="#adc7c8c8b0e99aba6170a005fd897c6fb">More...</a><br /></td></tr>
<tr class="separator:adc7c8c8b0e99aba6170a005fd897c6fb inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90e9a742733fff299b97359ece214ee inherit pub_methods_struct_shared_pointer_slot"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#ad90e9a742733fff299b97359ece214ee">operator=</a> (const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;rhs)</td></tr>
<tr class="memdesc:ad90e9a742733fff299b97359ece214ee inherit pub_methods_struct_shared_pointer_slot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator  <a href="#ad90e9a742733fff299b97359ece214ee">More...</a><br /></td></tr>
<tr class="separator:ad90e9a742733fff299b97359ece214ee inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0768ebe7541b74a5f2b67a9fda91d87 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa0768ebe7541b74a5f2b67a9fda91d87 inherit pub_methods_struct_shared_pointer_slot"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#aa0768ebe7541b74a5f2b67a9fda91d87">operator=</a> (const std::shared_ptr&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa0768ebe7541b74a5f2b67a9fda91d87 inherit pub_methods_struct_shared_pointer_slot"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place polymorphic transformer  <a href="#aa0768ebe7541b74a5f2b67a9fda91d87">More...</a><br /></td></tr>
<tr class="separator:aa0768ebe7541b74a5f2b67a9fda91d87 inherit pub_methods_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5ac62d1b208edda5a9fc928d030a5a96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot_t.html#a5ac62d1b208edda5a9fc928d030a5a96">assign</a> (const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;rhs) override</td></tr>
<tr class="memdesc:a5ac62d1b208edda5a9fc928d030a5a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment routine  <a href="#a5ac62d1b208edda5a9fc928d030a5a96">More...</a><br /></td></tr>
<tr class="separator:a5ac62d1b208edda5a9fc928d030a5a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_struct_shared_pointer_slot"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_struct_shared_pointer_slot')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a></td></tr>
<tr class="memitem:a15ab96610a199d153df370121286feae inherit pro_attribs_struct_shared_pointer_slot"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15ab96610a199d153df370121286feae"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>m_space</b> [sizeof(std::shared_ptr&lt; void &gt;)]</td></tr>
<tr class="separator:a15ab96610a199d153df370121286feae inherit pro_attribs_struct_shared_pointer_slot"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5ac62d1b208edda5a9fc928d030a5a96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment routine </p>
<p>If this method is called, there will be a strong guarantee that the type of rhs will be precisely equal to the type of this.</p>
<p>Implementors MUST treat this as a type of constructor replacement. The contents of m_space are indeterminate and certainly invalid, and should be treated as uninitialized memory. </p>

<p>Reimplemented from <a class="el" href="struct_shared_pointer_slot.html#a175eed4187135bf01b7fbecc660aa5a3">SharedPointerSlot</a>.</p>

</div>
</div>
<a class="anchor" id="a939a86c42a2f4d10b48bd32c380cc914"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this slot holds nothing </dd></dl>

<p>Reimplemented from <a class="el" href="struct_shared_pointer_slot.html#a79b712a390824888d5c47ad6457a6182">SharedPointerSlot</a>.</p>

</div>
</div>
<a class="anchor" id="ac0981809814bc8886d2c662657543a91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt;&amp; <a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The shared pointer held by this slot </dd></dl>

</div>
</div>
<a class="anchor" id="a9206fbe46e337d9f2a6fac583ef3ee38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_slot_information_stump_base.html">SlotInformationStumpBase</a>&amp; <a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt;::GetSlotInformation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to obtain a list of slots defined on this type, for reflection purposes </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the head of a linked list of slots on this context member </dd></dl>
<p>A slot is an <a class="el" href="class_autowired.html" title="An autowired template class that forms the foundation of the context consumer system ...">Autowired</a> field defined within a specific type. Slots are of particular interest because they denote a compile-time relationship between two types, and generally are one way to understand class relationships in a system. Furthermore, because of their compile-time nature, they are declarative and therefore denote a relationship between types, rather than states, which makes it easier to understand how slots are linked.</p>
<p>The returned value is cached, and should not be freed or modified as it may be in use in other parts of the program. The behavior of this method is undefined if it's called on an object before the object is fully constructed (for instance, if the method is invoked from a constructor). This method will return correct results even if the <a class="el" href="class_context_member.html" title="A class that must be inherited in order to be a member of a context heriarchy ">ContextMember</a> type was not the first inherited type.</p>
<p>If this method returns a correct result at any point, then all subsequent calls to this method are guaranteed to return correct results, even in the aforementioned case where the method is called during construction. This method is guaranteed to return correct results after the first instance of a concrete type is constructed.</p>
<p>This list is guaranteed not to contain any <a class="el" href="class_autowired_fast.html" title="Similar to Autowired, but doesn&#39;t defer creation if types doesn&#39;t already exist ">AutowiredFast</a> fields defined in the class.</p>
<p>The linked list is guaranteed to be in reverse-sorted order </p>

<p>Reimplemented from <a class="el" href="struct_shared_pointer_slot.html#ac3b3da1e18c736c039831979b26a16e5">SharedPointerSlot</a>.</p>

</div>
</div>
<a class="anchor" id="acc7d7446251ef42583179d45023d1496"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt;::New </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a placement new on the specified space with a type matching the current instance </p>
<p>This method will also initialize the returned space with a copy of the shared pointer held by this slot. </p>

<p>Reimplemented from <a class="el" href="struct_shared_pointer_slot.html#a9355745051aca3eb7ab05cf8ee25d1e3">SharedPointerSlot</a>.</p>

</div>
</div>
<a class="anchor" id="a04ae517d2a6760d86839942257483703"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears this type, if a shared pointer is currently held </p>
<p>This method will preserve the polymorphic type of this slot&ndash;IE, it does not change the return value of this-&gt;<a class="el" href="struct_shared_pointer_slot.html#a29cf3e7ce37b3bc0300b5c6ae14c658b">type()</a> </p>

<p>Reimplemented from <a class="el" href="struct_shared_pointer_slot.html#ac632a9c0092b7fce3b33d87c4c3fc28a">SharedPointerSlot</a>.</p>

</div>
</div>
<a class="anchor" id="affcdc2089264d26a91110bc9d01d7bd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt;::try_assign </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to dynamically assign this slot to the specified object without changing the current type </p>
<dl class="section return"><dt>Returns</dt><dd>True if the assignment succeeds</dd></dl>

<p>Reimplemented from <a class="el" href="struct_shared_pointer_slot.html#ad6f347f4158070752ef55ee91c4b9232">SharedPointerSlot</a>.</p>

</div>
</div>
<a class="anchor" id="a3f9fd7c9c32f22e591f01d3a62f11810"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; <a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt;::type </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns the type of the shared pointer held in this slot, or typeid(void) if empty </dd></dl>

<p>Reimplemented from <a class="el" href="struct_shared_pointer_slot.html#a29cf3e7ce37b3bc0300b5c6ae14c658b">SharedPointerSlot</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>autowiring/<a class="el" href="_shared_pointer_slot_8h_source.html">SharedPointerSlot.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 7 2014 11:13:20 for Autowiring by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
