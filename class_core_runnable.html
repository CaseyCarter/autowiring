<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Autowiring: CoreRunnable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">1.0.3</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Developer's&#160;Guide</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_core_runnable.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_core_runnable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CoreRunnable Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides the interface for threads that should receive start and stop notifications in a context  
 <a href="class_core_runnable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_core_runnable_8h_source.html">CoreRunnable.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CoreRunnable:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_core_runnable.png" usemap="#CoreRunnable_map" alt=""/>
  <map id="CoreRunnable_map" name="CoreRunnable_map">
<area href="class_auto_packet_factory.html" title="A configurable factory class for pipeline packets with a built-in object pool " alt="AutoPacketFactory" shape="rect" coords="0,56,120,80"/>
<area href="class_auto_packet_graph.html" title="Graphical visualization of AutoPackets " alt="AutoPacketGraph" shape="rect" coords="130,56,250,80"/>
<area href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. " alt="BasicThread" shape="rect" coords="260,56,380,80"/>
<area href="class_core_thread.html" title="Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the ..." alt="CoreThread" shape="rect" coords="260,112,380,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3ff8924be1ad354a7b8a5438ca82b32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3ff8924be1ad354a7b8a5438ca82b32"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#ac3ff8924be1ad354a7b8a5438ca82b32">IsRunning</a> (void) const </td></tr>
<tr class="memdesc:ac3ff8924be1ad354a7b8a5438ca82b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this runnable is currently running. <br /></td></tr>
<tr class="separator:ac3ff8924be1ad354a7b8a5438ca82b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144421b84f8b8fee45838fbe2be6e5c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a144421b84f8b8fee45838fbe2be6e5c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a144421b84f8b8fee45838fbe2be6e5c6">ShouldStop</a> (void) volatile const </td></tr>
<tr class="memdesc:a144421b84f8b8fee45838fbe2be6e5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this runnable should stop. <br /></td></tr>
<tr class="separator:a144421b84f8b8fee45838fbe2be6e5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5e7e482f70200b82d8f0d489eedd12"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a4f5e7e482f70200b82d8f0d489eedd12">Start</a> (std::shared_ptr&lt; CoreObject &gt; outstanding)</td></tr>
<tr class="memdesc:a4f5e7e482f70200b82d8f0d489eedd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes this runnable to begin processing.  <a href="#a4f5e7e482f70200b82d8f0d489eedd12">More...</a><br /></td></tr>
<tr class="separator:a4f5e7e482f70200b82d8f0d489eedd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c3338adf9bf7222b13bbafb564dabb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a41c3338adf9bf7222b13bbafb564dabb">Stop</a> (bool graceful=true)</td></tr>
<tr class="memdesc:a41c3338adf9bf7222b13bbafb564dabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops this runnable.  <a href="#a41c3338adf9bf7222b13bbafb564dabb">More...</a><br /></td></tr>
<tr class="separator:a41c3338adf9bf7222b13bbafb564dabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaa1a6490b1b7d16fa63b64a012a9f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a0aaa1a6490b1b7d16fa63b64a012a9f0">ThreadSleep</a> (std::chrono::nanoseconds timeout)</td></tr>
<tr class="memdesc:a0aaa1a6490b1b7d16fa63b64a012a9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeps this thread for the specified duration.  <a href="#a0aaa1a6490b1b7d16fa63b64a012a9f0">More...</a><br /></td></tr>
<tr class="separator:a0aaa1a6490b1b7d16fa63b64a012a9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3c019cfe57942e293c9cec805828e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#acb3c019cfe57942e293c9cec805828e7">Wait</a> (void)</td></tr>
<tr class="memdesc:acb3c019cfe57942e293c9cec805828e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits indefinitely. Returns when this runnable stops.  <a href="#acb3c019cfe57942e293c9cec805828e7">More...</a><br /></td></tr>
<tr class="separator:acb3c019cfe57942e293c9cec805828e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4856481bde70b25d28bac86876cadf88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a4856481bde70b25d28bac86876cadf88">WaitFor</a> (std::chrono::nanoseconds timeout)</td></tr>
<tr class="memdesc:a4856481bde70b25d28bac86876cadf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the specified amount of time.  <a href="#a4856481bde70b25d28bac86876cadf88">More...</a><br /></td></tr>
<tr class="separator:a4856481bde70b25d28bac86876cadf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b6ac4ade1032ea1411680a04592d87"><td class="memTemplParams" colspan="2">template&lt;typename TimeType &gt; </td></tr>
<tr class="memitem:aa8b6ac4ade1032ea1411680a04592d87"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#aa8b6ac4ade1032ea1411680a04592d87">WaitUntil</a> (TimeType timepoint)</td></tr>
<tr class="memdesc:aa8b6ac4ade1032ea1411680a04592d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the specified time.  <a href="#aa8b6ac4ade1032ea1411680a04592d87">More...</a><br /></td></tr>
<tr class="separator:aa8b6ac4ade1032ea1411680a04592d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7811af34bc57739faeefbf64415f819c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7811af34bc57739faeefbf64415f819c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a7811af34bc57739faeefbf64415f819c">WasStarted</a> (void) volatile const </td></tr>
<tr class="memdesc:a7811af34bc57739faeefbf64415f819c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this runnable was ever started. <br /></td></tr>
<tr class="separator:a7811af34bc57739faeefbf64415f819c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acfcf01282cf908f91218bfdd5601678c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#acfcf01282cf908f91218bfdd5601678c">DoAdditionalWait</a> (std::chrono::nanoseconds timeout)</td></tr>
<tr class="memdesc:acfcf01282cf908f91218bfdd5601678c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked just before control is returned to the user.  <a href="#acfcf01282cf908f91218bfdd5601678c">More...</a><br /></td></tr>
<tr class="separator:acfcf01282cf908f91218bfdd5601678c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c2a762acf2fd367f09fff1100231da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#af3c2a762acf2fd367f09fff1100231da">DoAdditionalWait</a> (void)</td></tr>
<tr class="memdesc:af3c2a762acf2fd367f09fff1100231da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Untimed variant of DoAdditionalWait  <a href="#af3c2a762acf2fd367f09fff1100231da">More...</a><br /></td></tr>
<tr class="separator:af3c2a762acf2fd367f09fff1100231da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2c7498d9db4e8f76dc2b6a69d8f1bc"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; CoreObject &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#a7d2c7498d9db4e8f76dc2b6a69d8f1bc">GetOutstanding</a> (void) const </td></tr>
<tr class="separator:a7d2c7498d9db4e8f76dc2b6a69d8f1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72398f9348bd2b63fd9e040ee21f7e9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#aa72398f9348bd2b63fd9e040ee21f7e9">OnStart</a> (void)</td></tr>
<tr class="memdesc:aa72398f9348bd2b63fd9e040ee21f7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by the <a class="el" href="class_core_runnable.html#a4f5e7e482f70200b82d8f0d489eedd12" title="Causes this runnable to begin processing. ">Start()</a> method. Override this method to perform any needed setup  <a href="#aa72398f9348bd2b63fd9e040ee21f7e9">More...</a><br /></td></tr>
<tr class="separator:aa72398f9348bd2b63fd9e040ee21f7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b1fc01ebff2aa052c13abe7be0d647"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_runnable.html#ac2b1fc01ebff2aa052c13abe7be0d647">OnStop</a> (bool graceful)</td></tr>
<tr class="memdesc:ac2b1fc01ebff2aa052c13abe7be0d647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked by the base class <a class="el" href="class_core_runnable.html#a41c3338adf9bf7222b13bbafb564dabb" title="Stops this runnable. ">Stop()</a> method. Override this method to perform any needed cleanup.  <a href="#ac2b1fc01ebff2aa052c13abe7be0d647">More...</a><br /></td></tr>
<tr class="separator:ac2b1fc01ebff2aa052c13abe7be0d647"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides the interface for threads that should receive start and stop notifications in a context </p>
<p>Users of Autowiring will typically use <a class="el" href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. ">BasicThread</a> or <a class="el" href="class_core_thread.html" title="Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the ...">CoreThread</a> instead of extending this class. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acfcf01282cf908f91218bfdd5601678c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CoreRunnable::DoAdditionalWait </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked just before control is returned to the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The maximum amount of time to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the wait succeeded, false if a timeout occurred</dd></dl>
<p>This virtual method provides implementors with a way to add further constraints to the wait operation beyond the condition variable held internally by this <a class="el" href="class_core_runnable.html" title="Provides the interface for threads that should receive start and stop notifications in a context ...">CoreRunnable</a>.</p>
<p>This method must return true if the timeout is indefinite. </p>

<p>Reimplemented in <a class="el" href="class_basic_thread.html#a43a1abcadf00639a64c02fc0ab2785f3">BasicThread</a>, and <a class="el" href="class_auto_packet_factory.html#aa969b149c74e23e0ee708481ec90ec94">AutoPacketFactory</a>.</p>

</div>
</div>
<a class="anchor" id="af3c2a762acf2fd367f09fff1100231da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CoreRunnable::DoAdditionalWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Untimed variant of DoAdditionalWait </p>

<p>Reimplemented in <a class="el" href="class_basic_thread.html#aec8c9fa548fc917627ab1806309c5747">BasicThread</a>, and <a class="el" href="class_auto_packet_factory.html#adcff2e0a4fd863f3a618973c6c5d6b3f">AutoPacketFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a7d2c7498d9db4e8f76dc2b6a69d8f1bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;CoreObject&gt;&amp; CoreRunnable::GetOutstanding </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A reference to the current outstanding counter </dd></dl>

</div>
</div>
<a class="anchor" id="aa72398f9348bd2b63fd9e040ee21f7e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CoreRunnable::OnStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked by the <a class="el" href="class_core_runnable.html#a4f5e7e482f70200b82d8f0d489eedd12" title="Causes this runnable to begin processing. ">Start()</a> method. Override this method to perform any needed setup </p>
<dl class="section return"><dt>Returns</dt><dd>True if processing has started, false otherwise. When overriding, returning false will shut down the runnable immediately. </dd></dl>
<p>This method will be called at most once. Returning false from this method will result in an immediate invocation of OnStop(false). </p>

<p>Reimplemented in <a class="el" href="class_basic_thread.html#a64061568019d519e3a27d1d3a840c741">BasicThread</a>, <a class="el" href="class_auto_packet_graph.html#a668b16bb510434cad6342e68d470bf7b">AutoPacketGraph</a>, and <a class="el" href="class_auto_packet_factory.html#aa60dd197a5520d5b06b1a1c9bfa8dda9">AutoPacketFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ac2b1fc01ebff2aa052c13abe7be0d647"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CoreRunnable::OnStop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>graceful</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked by the base class <a class="el" href="class_core_runnable.html#a41c3338adf9bf7222b13bbafb564dabb" title="Stops this runnable. ">Stop()</a> method. Override this method to perform any needed cleanup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graceful</td><td>Specifies whether the runnable should stop normally or whether it should exit as quickly as possible. </td></tr>
  </table>
  </dd>
</dl>
<p>This method will be called at most once from a passive level. </p>

<p>Reimplemented in <a class="el" href="class_basic_thread.html#abb056d8402460ea96e350e2b9dcc2f4d">BasicThread</a>, <a class="el" href="class_core_thread.html#aaa00cb32629cf5f71d1dfe27342769a8">CoreThread</a>, and <a class="el" href="class_auto_packet_factory.html#ac8615d15ffbe346e4f2f6976e8f4dcdc">AutoPacketFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a4f5e7e482f70200b82d8f0d489eedd12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CoreRunnable::Start </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; CoreObject &gt;&#160;</td>
          <td class="paramname"><em>outstanding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes this runnable to begin processing. </p>
<dl class="section return"><dt>Returns</dt><dd>This method always returns true.</dd></dl>
<p>It is an error to call this routine more than once. The passed outstanding shared pointer is used to keep tracking of number of simultaneous runnables outstanding. This routine may be called even after Stop has been called; the caller MUST return false in this case.</p>
<p>Callers should strongly prefer not to override Start if possible. Instead, override OnStart and obtain an instance of the outstanding pointer via GetOutstanding </p>

</div>
</div>
<a class="anchor" id="a41c3338adf9bf7222b13bbafb564dabb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreRunnable::Stop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>graceful</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops this runnable. </p>
<p>Calls <a class="el" href="class_core_runnable.html#ac2b1fc01ebff2aa052c13abe7be0d647" title="Invoked by the base class Stop() method. Override this method to perform any needed cleanup...">OnStop()</a>, forwarding the graceful parameter.</p>
<p>On return of this method, regardless of the return value, a subsequent call to Wait is guaranteed to either return immediately, or once the thread implementation completes. </p>

</div>
</div>
<a class="anchor" id="a0aaa1a6490b1b7d16fa63b64a012a9f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreRunnable::ThreadSleep </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleeps this thread for the specified duration. </p>
<dl class="section return"><dt>Returns</dt><dd>False if the thread was terminated before the timeout elapsed.</dd></dl>

</div>
</div>
<a class="anchor" id="acb3c019cfe57942e293c9cec805828e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreRunnable::Wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits indefinitely. Returns when this runnable stops. </p>

</div>
</div>
<a class="anchor" id="a4856481bde70b25d28bac86876cadf88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreRunnable::WaitFor </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the specified amount of time. </p>

</div>
</div>
<a class="anchor" id="aa8b6ac4ade1032ea1411680a04592d87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CoreRunnable::WaitUntil </td>
          <td>(</td>
          <td class="paramtype">TimeType&#160;</td>
          <td class="paramname"><em>timepoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until the specified time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timepoint</td><td>A std::chrono type representing a duration or future point in time.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/autowiring/<a class="el" href="_core_runnable_8h_source.html">CoreRunnable.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_core_runnable.html">CoreRunnable</a></li>
    <li class="footer">Generated on Fri Jul 29 2016 21:26:22 for Autowiring by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
