<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Autowiring: CoreContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.4.1</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_core_context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CoreContext Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A top-level container class representing an autowiring domain, a minimum broadcast domain, and a thread execution domain  
 <a href="class_core_context.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_core_context_8h_source.html">CoreContext.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CoreContext:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_core_context.png" usemap="#CoreContext_map" alt=""/>
  <map id="CoreContext_map" name="CoreContext_map">
<area href="class_teardown_notifier.html" title="Maintains a list of lambdas to be invoked when the enclosing object is being destroyed ..." alt="TeardownNotifier" shape="rect" coords="0,0,270,24"/>
<area href="class_core_context_t.html" title="Constant type optimization for named sigil types " alt="CoreContextT&lt; T &gt;" shape="rect" coords="0,112,270,136"/>
<area href="class_core_context_t.html" alt="CoreContextT&lt; GlobalCoreContext &gt;" shape="rect" coords="280,112,550,136"/>
<area href="class_global_core_context.html" alt="GlobalCoreContext" shape="rect" coords="280,168,550,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context_1_1_auto_factory.html">AutoFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy context member that knows how to create a factory for a particular type  <a href="class_core_context_1_1_auto_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context_1_1_auto_factory_fn.html">AutoFactoryFn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context_1_1_auto_factory_fn_3_01std_1_1tuple_3_01_ts_8_8_8_4_00_01_fn_01_4.html">AutoFactoryFn&lt; std::tuple&lt; Ts...&gt;, Fn &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context_1_1_auto_search_lambda_autowire.html">AutoSearchLambdaAutowire</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context_1_1_auto_search_lambda_notify_when_autowired.html">AutoSearchLambdaNotifyWhenAutowired</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_core_context_1_1_memo_entry.html">MemoEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single entry, together with any deferred elements waiting on the satisfaction of this entry  <a href="struct_core_context_1_1_memo_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae2eb27daa6e017c3b678868faf0f7b14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2eb27daa6e017c3b678868faf0f7b14"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsGlobalContext</b> (void) const </td></tr>
<tr class="separator:ae2eb27daa6e017c3b678868faf0f7b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad725f1858d6305af6721e575bb312674"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad725f1858d6305af6721e575bb312674"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetMemberCount</b> (void) const </td></tr>
<tr class="separator:ad725f1858d6305af6721e575bb312674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26665562a7e88fb2ecb00e1ae56432c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26665562a7e88fb2ecb00e1ae56432c6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetChildCount</b> (void) const </td></tr>
<tr class="separator:a26665562a7e88fb2ecb00e1ae56432c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2785f3a9ba5946d57a9a3b72d99b9955"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2785f3a9ba5946d57a9a3b72d99b9955"></a>
virtual const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSigilType</b> (void) const =0</td></tr>
<tr class="separator:a2785f3a9ba5946d57a9a3b72d99b9955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88653daf77a40b41dec8e64c175813d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae88653daf77a40b41dec8e64c175813d"></a>
t_childList::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>GetBackReference</b> (void) const </td></tr>
<tr class="separator:ae88653daf77a40b41dec8e64c175813d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3783fd45517f23b6f070e0b06e916440"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3783fd45517f23b6f070e0b06e916440"></a>
const std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetParentContext</b> (void) const </td></tr>
<tr class="separator:a3783fd45517f23b6f070e0b06e916440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefaae7d459f3ee07dce5b65c731e7900"><td class="memTemplParams" colspan="2">template&lt;class Sigil &gt; </td></tr>
<tr class="memitem:aefaae7d459f3ee07dce5b65c731e7900"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#aefaae7d459f3ee07dce5b65c731e7900">Is</a> (void) const </td></tr>
<tr class="separator:aefaae7d459f3ee07dce5b65c731e7900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadefc1626bfcdb4f1a8cc7b4afd50e98"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#aadefc1626bfcdb4f1a8cc7b4afd50e98">FirstChild</a> (void) const </td></tr>
<tr class="separator:aadefc1626bfcdb4f1a8cc7b4afd50e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed50fd3fbf376a831935254caf28f763"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#aed50fd3fbf376a831935254caf28f763">NextSibling</a> (void) const </td></tr>
<tr class="separator:aed50fd3fbf376a831935254caf28f763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3d68e3e2a36c0137c98c829729cbd5"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#afa3d68e3e2a36c0137c98c829729cbd5">GetAutoTypeId</a> (const <a class="el" href="struct_any_shared_pointer.html">AnySharedPointer</a> &amp;ptr) const </td></tr>
<tr class="separator:afa3d68e3e2a36c0137c98c829729cbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc43e4945b02d5deae2c94b55960a024"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afc43e4945b02d5deae2c94b55960a024"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#afc43e4945b02d5deae2c94b55960a024">Create</a> (<a class="el" href="class_auto_injectable.html">AutoInjectable</a> &amp;&amp;inj)</td></tr>
<tr class="memdesc:afc43e4945b02d5deae2c94b55960a024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a new context  <a href="#afc43e4945b02d5deae2c94b55960a024">More...</a><br /></td></tr>
<tr class="separator:afc43e4945b02d5deae2c94b55960a024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e6c77193e81a7e83474afb58630c33"><td class="memTemplParams" colspan="2"><a class="anchor" id="a58e6c77193e81a7e83474afb58630c33"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a58e6c77193e81a7e83474afb58630c33"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Create</b> (void)</td></tr>
<tr class="separator:a58e6c77193e81a7e83474afb58630c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a1163a33eb268e7fd943b05e7892d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a94a1163a33eb268e7fd943b05e7892d8"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a94a1163a33eb268e7fd943b05e7892d8">CreatePeer</a> (void)</td></tr>
<tr class="memdesc:a94a1163a33eb268e7fd943b05e7892d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a peer context  <a href="#a94a1163a33eb268e7fd943b05e7892d8">More...</a><br /></td></tr>
<tr class="separator:a94a1163a33eb268e7fd943b05e7892d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ef42fac99a89891c9cff760bd46ee8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a86ef42fac99a89891c9cff760bd46ee8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a86ef42fac99a89891c9cff760bd46ee8">Enable</a> (void)</td></tr>
<tr class="memdesc:a86ef42fac99a89891c9cff760bd46ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a specifically named class to be bolted  <a href="#a86ef42fac99a89891c9cff760bd46ee8">More...</a><br /></td></tr>
<tr class="separator:a86ef42fac99a89891c9cff760bd46ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cde2e3e4031ac1bc1c9e761f8eff11"><td class="memTemplParams" colspan="2">template&lt;class T , class... Sigils&gt; </td></tr>
<tr class="memitem:a81cde2e3e4031ac1bc1c9e761f8eff11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a81cde2e3e4031ac1bc1c9e761f8eff11">BoltTo</a> (void)</td></tr>
<tr class="memdesc:a81cde2e3e4031ac1bc1c9e761f8eff11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the specified type T to be injected in any subcontext created with one of the matching sigil types  <a href="#a81cde2e3e4031ac1bc1c9e761f8eff11">More...</a><br /></td></tr>
<tr class="separator:a81cde2e3e4031ac1bc1c9e761f8eff11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005f71baab03719918429b7ecdd8a9ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a005f71baab03719918429b7ecdd8a9ba"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a005f71baab03719918429b7ecdd8a9ba">Inject</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a005f71baab03719918429b7ecdd8a9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method which will inject the specified types into this context  <a href="#a005f71baab03719918429b7ecdd8a9ba">More...</a><br /></td></tr>
<tr class="separator:a005f71baab03719918429b7ecdd8a9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff72e44be09394686d51a367a6ff9e23"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aff72e44be09394686d51a367a6ff9e23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#aff72e44be09394686d51a367a6ff9e23">Has</a> (void) const </td></tr>
<tr class="separator:aff72e44be09394686d51a367a6ff9e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbfa409d6d26b10e4fd72b391b45623"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5fbfa409d6d26b10e4fd72b391b45623"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a5fbfa409d6d26b10e4fd72b391b45623"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DEPRECATED</b> (Construct(Args &amp;&amp;...args),&quot;'Construct' is deprecated, use '<a class="el" href="class_core_context.html#a005f71baab03719918429b7ecdd8a9ba">Inject</a>' instead&quot;)</td></tr>
<tr class="separator:a5fbfa409d6d26b10e4fd72b391b45623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed970b70575e2be12dd9b5129c1355a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#aeed970b70575e2be12dd9b5129c1355a">BuildCurrentState</a> (void)</td></tr>
<tr class="memdesc:aeed970b70575e2be12dd9b5129c1355a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <a class="el" href="class_autowiring_events.html" title="These events are broadcast internally by Autowiring for visualizing internal behavior. </summary ">AutowiringEvents</a> to build current state  <a href="#aeed970b70575e2be12dd9b5129c1355a">More...</a><br /></td></tr>
<tr class="separator:aeed970b70575e2be12dd9b5129c1355a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198a4ee1d3f001f14e3139f52d91160e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_basic_thread.html">BasicThread</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a198a4ee1d3f001f14e3139f52d91160e">CopyBasicThreadList</a> (void) const </td></tr>
<tr class="separator:a198a4ee1d3f001f14e3139f52d91160e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b08c5f0dead4908659cf87c6eb77abb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a6b08c5f0dead4908659cf87c6eb77abb">IsShutdown</a> (void) const </td></tr>
<tr class="separator:a6b08c5f0dead4908659cf87c6eb77abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d4381dc7affb5ee90f14063b757e4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17d4381dc7affb5ee90f14063b757e4a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsInitiated</b> (void) const </td></tr>
<tr class="separator:a17d4381dc7affb5ee90f14063b757e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12f8a7181248f040bde3fd4cdcd799e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ad12f8a7181248f040bde3fd4cdcd799e">WasStarted</a> (void) const </td></tr>
<tr class="separator:ad12f8a7181248f040bde3fd4cdcd799e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ab31f4f5f30284304bca63390f9545"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a46ab31f4f5f30284304bca63390f9545">IsAncestorOf</a> (const <a class="el" href="class_core_context.html">CoreContext</a> *child) const </td></tr>
<tr class="separator:a46ab31f4f5f30284304bca63390f9545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbd67d6fac649763f86c1eadd333788"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abfbd67d6fac649763f86c1eadd333788"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_junction_box.html">JunctionBox</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#abfbd67d6fac649763f86c1eadd333788">GetJunctionBox</a> (void)</td></tr>
<tr class="memdesc:abfbd67d6fac649763f86c1eadd333788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a shared pointer to an event sender <em>in this context</em> matching the specified type  <a href="#abfbd67d6fac649763f86c1eadd333788">More...</a><br /></td></tr>
<tr class="separator:abfbd67d6fac649763f86c1eadd333788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe1f8ada791176b9c4893963b74aee1"><td class="memTemplParams" colspan="2">template&lt;typename MemFn &gt; </td></tr>
<tr class="memitem:a1fe1f8ada791176b9c4893963b74aee1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_invoke_relay.html">InvokeRelay</a>&lt; MemFn &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a1fe1f8ada791176b9c4893963b74aee1">Invoke</a> (MemFn memFn)</td></tr>
<tr class="memdesc:a1fe1f8ada791176b9c4893963b74aee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method which allows an event to be fired without making the remote context current  <a href="#a1fe1f8ada791176b9c4893963b74aee1">More...</a><br /></td></tr>
<tr class="separator:a1fe1f8ada791176b9c4893963b74aee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4c58c375caaeb70d20807cd4029657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#aec4c58c375caaeb70d20807cd4029657">Initiate</a> (void)</td></tr>
<tr class="memdesc:aec4c58c375caaeb70d20807cd4029657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility routine, invoked typically by the service, which starts all registered core threads.  <a href="#aec4c58c375caaeb70d20807cd4029657">More...</a><br /></td></tr>
<tr class="separator:aec4c58c375caaeb70d20807cd4029657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14137656f7f7544958c0fa7e3895fb9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14137656f7f7544958c0fa7e3895fb9d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DEPRECATED</b> (InitiateCoreThreads(void),&quot;InitiateCoreThreads is deprecated, use <a class="el" href="class_core_context.html#aec4c58c375caaeb70d20807cd4029657">Initiate</a> instead&quot;)</td></tr>
<tr class="separator:a14137656f7f7544958c0fa7e3895fb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0ff07669244590fcdcec9aeb588aa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a8e0ff07669244590fcdcec9aeb588aa5">SignalShutdown</a> (bool wait=false, ShutdownMode shutdownMode=ShutdownMode::Graceful)</td></tr>
<tr class="memdesc:a8e0ff07669244590fcdcec9aeb588aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This signals to the whole system that a shutdown operation is underway, and that shutdown procedures should begin immediately  <a href="#a8e0ff07669244590fcdcec9aeb588aa5">More...</a><br /></td></tr>
<tr class="separator:a8e0ff07669244590fcdcec9aeb588aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107256cd9f29a43301afca98cd7309a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a107256cd9f29a43301afca98cd7309a5">SignalTerminate</a> (bool wait=true)</td></tr>
<tr class="memdesc:a107256cd9f29a43301afca98cd7309a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for SignalShutdown(true, ShutdownMode::Immediate)  <a href="#a107256cd9f29a43301afca98cd7309a5">More...</a><br /></td></tr>
<tr class="separator:a107256cd9f29a43301afca98cd7309a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846274ca88865c63655b5eeb054d12b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a846274ca88865c63655b5eeb054d12b9">Wait</a> (void)</td></tr>
<tr class="memdesc:a846274ca88865c63655b5eeb054d12b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the context is transitioned to the Stopped state and all threads and child threads have terminated.  <a href="#a846274ca88865c63655b5eeb054d12b9">More...</a><br /></td></tr>
<tr class="separator:a846274ca88865c63655b5eeb054d12b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6708295354459d99f39f4f4a2899211d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a6708295354459d99f39f4f4a2899211d">Wait</a> (const std::chrono::nanoseconds duration)</td></tr>
<tr class="memdesc:a6708295354459d99f39f4f4a2899211d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed overload  <a href="#a6708295354459d99f39f4f4a2899211d">More...</a><br /></td></tr>
<tr class="separator:a6708295354459d99f39f4f4a2899211d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafba926a5bb2aa13f15c4de0d0df019"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#abafba926a5bb2aa13f15c4de0d0df019">DelayUntilInitiated</a> (void)</td></tr>
<tr class="memdesc:abafba926a5bb2aa13f15c4de0d0df019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the context is initiated or is shutting down  <a href="#abafba926a5bb2aa13f15c4de0d0df019">More...</a><br /></td></tr>
<tr class="separator:abafba926a5bb2aa13f15c4de0d0df019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eb5256cf9d82e8b22dfe226100714c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a04eb5256cf9d82e8b22dfe226100714c">SetCurrent</a> (void)</td></tr>
<tr class="memdesc:a04eb5256cf9d82e8b22dfe226100714c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This makes this core context current.  <a href="#a04eb5256cf9d82e8b22dfe226100714c">More...</a><br /></td></tr>
<tr class="separator:a04eb5256cf9d82e8b22dfe226100714c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5b71f520358864f1cf52eb108aceb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a5b5b71f520358864f1cf52eb108aceb3">FilterException</a> (void)</td></tr>
<tr class="memdesc:a5b5b71f520358864f1cf52eb108aceb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters std::current_exception using any registered exception filters, or rethrows.  <a href="#a5b5b71f520358864f1cf52eb108aceb3">More...</a><br /></td></tr>
<tr class="separator:a5b5b71f520358864f1cf52eb108aceb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf39b096026f4f48c7fc1326f1f25426"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#acf39b096026f4f48c7fc1326f1f25426">FilterFiringException</a> (const <a class="el" href="class_junction_box_base.html">JunctionBoxBase</a> *pProxy, <a class="el" href="class_object.html">Object</a> *pRecipient)</td></tr>
<tr class="memdesc:acf39b096026f4f48c7fc1326f1f25426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a std::current_exception thrown by an EventSenderBase during a Fire  <a href="#acf39b096026f4f48c7fc1326f1f25426">More...</a><br /></td></tr>
<tr class="separator:acf39b096026f4f48c7fc1326f1f25426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861a5330dfe8fb609c2de97d2ea937a0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a861a5330dfe8fb609c2de97d2ea937a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a861a5330dfe8fb609c2de97d2ea937a0">Snoop</a> (const std::shared_ptr&lt; T &gt; &amp;pSnooper)</td></tr>
<tr class="memdesc:a861a5330dfe8fb609c2de97d2ea937a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the passed event receiver to obtain messages broadcast by this context  <a href="#a861a5330dfe8fb609c2de97d2ea937a0">More...</a><br /></td></tr>
<tr class="separator:a861a5330dfe8fb609c2de97d2ea937a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31a7a286dded4026fe4dd263eb22076"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab31a7a286dded4026fe4dd263eb22076"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#ab31a7a286dded4026fe4dd263eb22076">Snoop</a> (const <a class="el" href="class_autowired.html">Autowired</a>&lt; T &gt; &amp;snooper)</td></tr>
<tr class="memdesc:ab31a7a286dded4026fe4dd263eb22076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolution overload  <a href="#ab31a7a286dded4026fe4dd263eb22076">More...</a><br /></td></tr>
<tr class="separator:ab31a7a286dded4026fe4dd263eb22076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98a62b5ff67127aa2f870ec54196fd3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae98a62b5ff67127aa2f870ec54196fd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#ae98a62b5ff67127aa2f870ec54196fd3">Unsnoop</a> (const std::shared_ptr&lt; T &gt; &amp;pSnooper)</td></tr>
<tr class="memdesc:ae98a62b5ff67127aa2f870ec54196fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters an event receiver previously registered to receive snooped events  <a href="#ae98a62b5ff67127aa2f870ec54196fd3">More...</a><br /></td></tr>
<tr class="separator:ae98a62b5ff67127aa2f870ec54196fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac584c161af922db0482b30d8aa232146"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac584c161af922db0482b30d8aa232146"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#ac584c161af922db0482b30d8aa232146">Unsnoop</a> (const <a class="el" href="class_autowired.html">Autowired</a>&lt; T &gt; &amp;snooper)</td></tr>
<tr class="memdesc:ac584c161af922db0482b30d8aa232146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolution overload  <a href="#ac584c161af922db0482b30d8aa232146">More...</a><br /></td></tr>
<tr class="separator:ac584c161af922db0482b30d8aa232146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49a3f07a2ab270baa6cec93707127bc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad49a3f07a2ab270baa6cec93707127bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#ad49a3f07a2ab270baa6cec93707127bc">FindByType</a> (std::shared_ptr&lt; T &gt; &amp;slot) const </td></tr>
<tr class="memdesc:ad49a3f07a2ab270baa6cec93707127bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove EventReceiver from parents unless its a member of the parent  <a href="#ad49a3f07a2ab270baa6cec93707127bc">More...</a><br /></td></tr>
<tr class="separator:ad49a3f07a2ab270baa6cec93707127bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01014fe31d9a6a10cc7357a5924a6460"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a01014fe31d9a6a10cc7357a5924a6460"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a01014fe31d9a6a10cc7357a5924a6460">FindByTypeRecursive</a> (std::shared_ptr&lt; T &gt; &amp;ptr) const </td></tr>
<tr class="memdesc:a01014fe31d9a6a10cc7357a5924a6460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to Autowire, but will not register the passed slot for deferred resolution  <a href="#a01014fe31d9a6a10cc7357a5924a6460">More...</a><br /></td></tr>
<tr class="separator:a01014fe31d9a6a10cc7357a5924a6460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6936a4534f8d5b7c959bfed783c0eed5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6936a4534f8d5b7c959bfed783c0eed5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a6936a4534f8d5b7c959bfed783c0eed5">FindByTypeRecursive</a> (<a class="el" href="class_any_shared_pointer_t.html">AnySharedPointerT</a>&lt; T &gt; &amp;slot) const </td></tr>
<tr class="memdesc:a6936a4534f8d5b7c959bfed783c0eed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to Autowire, but will not register the passed slot for deferred resolution  <a href="#a6936a4534f8d5b7c959bfed783c0eed5">More...</a><br /></td></tr>
<tr class="separator:a6936a4534f8d5b7c959bfed783c0eed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada59ec3baf8cb335d6e0792dd1473705"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ada59ec3baf8cb335d6e0792dd1473705"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#ada59ec3baf8cb335d6e0792dd1473705">Autowire</a> (<a class="el" href="class_any_shared_pointer_t.html">AnySharedPointerT</a>&lt; T &gt; &amp;ref, <a class="el" href="class_deferrable_autowiring.html">DeferrableAutowiring</a> &amp;defer)</td></tr>
<tr class="memdesc:ada59ec3baf8cb335d6e0792dd1473705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a slot to be autowired  <a href="#ada59ec3baf8cb335d6e0792dd1473705">More...</a><br /></td></tr>
<tr class="separator:ada59ec3baf8cb335d6e0792dd1473705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5920389c012b628511fe22dfb1dadb4"><td class="memTemplParams" colspan="2">template&lt;class T , class Fn &gt; </td></tr>
<tr class="memitem:af5920389c012b628511fe22dfb1dadb4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_autowirable_slot_fn.html">AutowirableSlotFn</a>&lt; T, Fn &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#af5920389c012b628511fe22dfb1dadb4">NotifyWhenAutowired</a> (Fn &amp;&amp;listener)</td></tr>
<tr class="memdesc:af5920389c012b628511fe22dfb1dadb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a post-attachment listener in this context for a particular autowired member. There is no guarantee for the context in which the listener will be called.  <a href="#af5920389c012b628511fe22dfb1dadb4">More...</a><br /></td></tr>
<tr class="separator:af5920389c012b628511fe22dfb1dadb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7447775cbe9d10c8018c0b7344a1fdc2"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a7447775cbe9d10c8018c0b7344a1fdc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a7447775cbe9d10c8018c0b7344a1fdc2">AddTeardownListener</a> (Fx &amp;&amp;fx)</td></tr>
<tr class="memdesc:a7447775cbe9d10c8018c0b7344a1fdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a teardown notifier which receives a pointer to this context on destruction  <a href="#a7447775cbe9d10c8018c0b7344a1fdc2">More...</a><br /></td></tr>
<tr class="separator:a7447775cbe9d10c8018c0b7344a1fdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae784ab63f9d15a717cdcb3a4a22466c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ae784ab63f9d15a717cdcb3a4a22466c2">CancelAutowiringNotification</a> (<a class="el" href="class_deferrable_autowiring.html">DeferrableAutowiring</a> *pDeferrable)</td></tr>
<tr class="memdesc:ae784ab63f9d15a717cdcb3a4a22466c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a slot as a recipient of potential autowiring  <a href="#ae784ab63f9d15a717cdcb3a4a22466c2">More...</a><br /></td></tr>
<tr class="separator:ae784ab63f9d15a717cdcb3a4a22466c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc3598a2c82c5452ec5b942ec84ceed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a8bc3598a2c82c5452ec5b942ec84ceed">Dump</a> (std::ostream &amp;os) const </td></tr>
<tr class="memdesc:a8bc3598a2c82c5452ec5b942ec84ceed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility debug method for writing a snapshot of this context to the specified output stream  <a href="#a8bc3598a2c82c5452ec5b942ec84ceed">More...</a><br /></td></tr>
<tr class="separator:a8bc3598a2c82c5452ec5b942ec84ceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_teardown_notifier"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_teardown_notifier')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_teardown_notifier.html">TeardownNotifier</a></td></tr>
<tr class="memitem:afc05f0790c0f3e3bdebbcb171556bdca inherit pub_methods_class_teardown_notifier"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:afc05f0790c0f3e3bdebbcb171556bdca inherit pub_methods_class_teardown_notifier"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teardown_notifier.html#afc05f0790c0f3e3bdebbcb171556bdca">AddTeardownListener</a> (Fx &amp;&amp;listener)</td></tr>
<tr class="memdesc:afc05f0790c0f3e3bdebbcb171556bdca inherit pub_methods_class_teardown_notifier"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the passed listener to be called when teardown is occurring for this object  <a href="#afc05f0790c0f3e3bdebbcb171556bdca">More...</a><br /></td></tr>
<tr class="separator:afc05f0790c0f3e3bdebbcb171556bdca inherit pub_methods_class_teardown_notifier"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4b2b185fd5c86dd09b868a929a53d349"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a4b2b185fd5c86dd09b868a929a53d349">GetGlobal</a> (void)</td></tr>
<tr class="memdesc:a4b2b185fd5c86dd09b868a929a53d349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to obtain a shared reference to the global context  <a href="#a4b2b185fd5c86dd09b868a929a53d349">More...</a><br /></td></tr>
<tr class="separator:a4b2b185fd5c86dd09b868a929a53d349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bec68515169c46d817190ef4231c0ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4bec68515169c46d817190ef4231c0ee"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a4bec68515169c46d817190ef4231c0ee">Create</a> (std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; pParent, t_childList::iterator backReference, std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; pPeer)</td></tr>
<tr class="memdesc:a4bec68515169c46d817190ef4231c0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation helper routine  <a href="#a4bec68515169c46d817190ef4231c0ee">More...</a><br /></td></tr>
<tr class="separator:a4bec68515169c46d817190ef4231c0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0716b1184e3fba32e64c06160d3153a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0716b1184e3fba32e64c06160d3153a3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a0716b1184e3fba32e64c06160d3153a3">InjectCurrent</a> (void)</td></tr>
<tr class="memdesc:a0716b1184e3fba32e64c06160d3153a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of Inject that uses the current context  <a href="#a0716b1184e3fba32e64c06160d3153a3">More...</a><br /></td></tr>
<tr class="separator:a0716b1184e3fba32e64c06160d3153a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a61b01ae5958603a643a4de2d42e83"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#af4a61b01ae5958603a643a4de2d42e83">EvictCurrent</a> (void)</td></tr>
<tr class="memdesc:af4a61b01ae5958603a643a4de2d42e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes no context current  <a href="#af4a61b01ae5958603a643a4de2d42e83">More...</a><br /></td></tr>
<tr class="separator:af4a61b01ae5958603a643a4de2d42e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8272447038b5515a05ba9b56e9d75d7c"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a8272447038b5515a05ba9b56e9d75d7c">CurrentContext</a> (void)</td></tr>
<tr class="memdesc:a8272447038b5515a05ba9b56e9d75d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This retrieves a shared pointer to the current context. It is only contextually relevant.  <a href="#a8272447038b5515a05ba9b56e9d75d7c">More...</a><br /></td></tr>
<tr class="separator:a8272447038b5515a05ba9b56e9d75d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ad430ec467d8971779d9069cfc6456327"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad430ec467d8971779d9069cfc6456327"></a>
typedef std::list&lt; std::weak_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>t_childList</b></td></tr>
<tr class="separator:ad430ec467d8971779d9069cfc6456327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dce83010e44104fd7bec542c1dcd90f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dce83010e44104fd7bec542c1dcd90f"></a>
typedef std::unordered_map&lt; std::type_index, std::list&lt; <a class="el" href="class_bolt_base.html">BoltBase</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>t_contextNameListeners</b></td></tr>
<tr class="separator:a7dce83010e44104fd7bec542c1dcd90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea5f99e35c0d46325f782682e797a78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adea5f99e35c0d46325f782682e797a78"></a>
typedef std::set&lt; <a class="el" href="struct_junction_box_entry.html">JunctionBoxEntry</a>&lt; <a class="el" href="class_object.html">Object</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>t_rcvrSet</b></td></tr>
<tr class="separator:adea5f99e35c0d46325f782682e797a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79f98bd1de23b30e549a16fbd1834e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac79f98bd1de23b30e549a16fbd1834e0"></a>
typedef std::list&lt; <a class="el" href="class_core_runnable.html">CoreRunnable</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>t_threadList</b></td></tr>
<tr class="separator:ac79f98bd1de23b30e549a16fbd1834e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e3b761c300da03370867ea00904b38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89e3b761c300da03370867ea00904b38"></a>
typedef std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;(*&#160;</td><td class="memItemRight" valign="bottom"><b>t_pfnCreate</b>) (std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; pParent, t_childList::iterator backReference, std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; pPeer)</td></tr>
<tr class="separator:a89e3b761c300da03370867ea00904b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abb3d4237a06a0a736dcb1f38cfbafc41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb3d4237a06a0a736dcb1f38cfbafc41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoreContext</b> (std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; pParent, t_childList::iterator backReference, std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; pPeer)</td></tr>
<tr class="separator:abb3d4237a06a0a736dcb1f38cfbafc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6d54466d0eb7753ad8be8e43451fbc"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#afb6d54466d0eb7753ad8be8e43451fbc">CreateInternal</a> (t_pfnCreate pfnCreate, std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; pPeer, <a class="el" href="class_auto_injectable.html">AutoInjectable</a> &amp;&amp;pInj)</td></tr>
<tr class="memdesc:afb6d54466d0eb7753ad8be8e43451fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register new context with parent and notify others of its creation.  <a href="#afb6d54466d0eb7753ad8be8e43451fbc">More...</a><br /></td></tr>
<tr class="separator:afb6d54466d0eb7753ad8be8e43451fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726e4e05369193fcf5855e9566b41e2b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a726e4e05369193fcf5855e9566b41e2b">CreateInternal</a> (t_pfnCreate pfnCreate, std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; pPeer)</td></tr>
<tr class="memdesc:a726e4e05369193fcf5855e9566b41e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload which does not perform injection  <a href="#a726e4e05369193fcf5855e9566b41e2b">More...</a><br /></td></tr>
<tr class="separator:a726e4e05369193fcf5855e9566b41e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2131922fbdc136785975e914aeb0ec11"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2131922fbdc136785975e914aeb0ec11"></a>
template&lt;typename T , typename... Sigils&gt; </td></tr>
<tr class="memitem:a2131922fbdc136785975e914aeb0ec11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EnableInternal</b> (T *, <a class="el" href="class_bolt.html">Bolt</a>&lt; Sigils...&gt; *)</td></tr>
<tr class="separator:a2131922fbdc136785975e914aeb0ec11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3fc2dea9f57b9a43444ba06f7bf37d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8a3fc2dea9f57b9a43444ba06f7bf37d"></a>
template&lt;typename T , typename... Sigils&gt; </td></tr>
<tr class="memitem:a8a3fc2dea9f57b9a43444ba06f7bf37d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EnableInternal</b> (T *, <a class="el" href="struct_boltable.html">Boltable</a>&lt; Sigils...&gt; *)</td></tr>
<tr class="separator:a8a3fc2dea9f57b9a43444ba06f7bf37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3a4b2c879e60b4601cfd91c054daae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf3a4b2c879e60b4601cfd91c054daae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EnableInternal</b> (...)</td></tr>
<tr class="separator:acf3a4b2c879e60b4601cfd91c054daae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79812932650c998d159d6e43433411ef"><td class="memTemplParams" colspan="2"><a class="anchor" id="a79812932650c998d159d6e43433411ef"></a>
template&lt;typename T , typename... Sigil&gt; </td></tr>
<tr class="memitem:a79812932650c998d159d6e43433411ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AutoRequireMicroBolt</b> (void)</td></tr>
<tr class="separator:a79812932650c998d159d6e43433411ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991be17630104176c56c36eabc40da07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a991be17630104176c56c36eabc40da07">UnregisterEventReceiversUnsafe</a> (void)</td></tr>
<tr class="memdesc:a991be17630104176c56c36eabc40da07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters all event receivers in this context  <a href="#a991be17630104176c56c36eabc40da07">More...</a><br /></td></tr>
<tr class="separator:a991be17630104176c56c36eabc40da07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156dd07f25adb19c4ab262e2666dfd94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a156dd07f25adb19c4ab262e2666dfd94">BroadcastContextCreationNotice</a> (const std::type_info &amp;sigil) const </td></tr>
<tr class="memdesc:a156dd07f25adb19c4ab262e2666dfd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a notice to any listener in the current context regarding a creation event on a particular context name  <a href="#a156dd07f25adb19c4ab262e2666dfd94">More...</a><br /></td></tr>
<tr class="separator:a156dd07f25adb19c4ab262e2666dfd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3295b11b91d66a8dde52cacdbeebe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ade3295b11b91d66a8dde52cacdbeebe6">UpdateDeferredElements</a> (std::unique_lock&lt; std::mutex &gt; &amp;&amp;lk, const <a class="el" href="struct_object_traits.html">ObjectTraits</a> &amp;entry)</td></tr>
<tr class="memdesc:ade3295b11b91d66a8dde52cacdbeebe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes all deferred autowiring fields, generally called after a new member has been added  <a href="#ade3295b11b91d66a8dde52cacdbeebe6">More...</a><br /></td></tr>
<tr class="separator:ade3295b11b91d66a8dde52cacdbeebe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a024e1d27e6c92ae4b41cf2f17945cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a7a024e1d27e6c92ae4b41cf2f17945cd">AddEventReceiver</a> (const <a class="el" href="struct_junction_box_entry.html">JunctionBoxEntry</a>&lt; <a class="el" href="class_object.html">Object</a> &gt; &amp;pRecvr)</td></tr>
<tr class="memdesc:a7a024e1d27e6c92ae4b41cf2f17945cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the named event receiver to the collection of known receivers  <a href="#a7a024e1d27e6c92ae4b41cf2f17945cd">More...</a><br /></td></tr>
<tr class="separator:a7a024e1d27e6c92ae4b41cf2f17945cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290d80061956f9ef893fb58fc1424afb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a290d80061956f9ef893fb58fc1424afb">AddEventReceivers</a> (const t_rcvrSet &amp;receivers)</td></tr>
<tr class="memdesc:a290d80061956f9ef893fb58fc1424afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add delayed event receivers  <a href="#a290d80061956f9ef893fb58fc1424afb">More...</a><br /></td></tr>
<tr class="separator:a290d80061956f9ef893fb58fc1424afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4038a78b4adff993dbb8733236308ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ad4038a78b4adff993dbb8733236308ee">RemoveEventReceivers</a> (const t_rcvrSet &amp;receivers)</td></tr>
<tr class="memdesc:ad4038a78b4adff993dbb8733236308ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all recognized event receivers in the indicated range  <a href="#ad4038a78b4adff993dbb8733236308ee">More...</a><br /></td></tr>
<tr class="separator:ad4038a78b4adff993dbb8733236308ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5171e011503a16a4928bba813ad38a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a9c5171e011503a16a4928bba813ad38a">AddCoreRunnable</a> (const std::shared_ptr&lt; <a class="el" href="class_core_runnable.html">CoreRunnable</a> &gt; &amp;pCoreRunnable)</td></tr>
<tr class="memdesc:a9c5171e011503a16a4928bba813ad38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an object of any kind to the IOC container  <a href="#a9c5171e011503a16a4928bba813ad38a">More...</a><br /></td></tr>
<tr class="separator:a9c5171e011503a16a4928bba813ad38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d6a49f021ddb69312c49e5ab8794c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a47d6a49f021ddb69312c49e5ab8794c3">AddBolt</a> (const std::shared_ptr&lt; <a class="el" href="class_bolt_base.html">BoltBase</a> &gt; &amp;pBase)</td></tr>
<tr class="memdesc:a47d6a49f021ddb69312c49e5ab8794c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified context creation listener to receive creation events broadcast from this context  <a href="#a47d6a49f021ddb69312c49e5ab8794c3">More...</a><br /></td></tr>
<tr class="separator:a47d6a49f021ddb69312c49e5ab8794c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92caeb3111312c536a3f5114e63cb444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a92caeb3111312c536a3f5114e63cb444">AddContextMember</a> (const std::shared_ptr&lt; <a class="el" href="class_context_member.html">ContextMember</a> &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a92caeb3111312c536a3f5114e63cb444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of Add based on <a class="el" href="class_context_member.html" title="A class that must be inherited in order to be a member of a context heriarchy ">ContextMember</a>  <a href="#a92caeb3111312c536a3f5114e63cb444">More...</a><br /></td></tr>
<tr class="separator:a92caeb3111312c536a3f5114e63cb444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa5bc00c7f05c4009bc20a796605cda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#aafa5bc00c7f05c4009bc20a796605cda">AddPacketSubscriber</a> (const <a class="el" href="struct_auto_filter_descriptor.html">AutoFilterDescriptor</a> &amp;rhs)</td></tr>
<tr class="memdesc:aafa5bc00c7f05c4009bc20a796605cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwarding routine, recursively adds a packet subscriber to the internal packet factory  <a href="#aafa5bc00c7f05c4009bc20a796605cda">More...</a><br /></td></tr>
<tr class="separator:aafa5bc00c7f05c4009bc20a796605cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a772a84b896a9930bbcf4047420b6ee"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a5a772a84b896a9930bbcf4047420b6ee">IncrementOutstandingThreadCount</a> (void)</td></tr>
<tr class="memdesc:a5a772a84b896a9930bbcf4047420b6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the total number of contexts still outstanding  <a href="#a5a772a84b896a9930bbcf4047420b6ee">More...</a><br /></td></tr>
<tr class="separator:a5a772a84b896a9930bbcf4047420b6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5a68d25d48af497b0502d737aa27b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#afb5a68d25d48af497b0502d737aa27b1">AddInternal</a> (const <a class="el" href="struct_object_traits.html">ObjectTraits</a> &amp;traits)</td></tr>
<tr class="memdesc:afb5a68d25d48af497b0502d737aa27b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal type introduction routine  <a href="#afb5a68d25d48af497b0502d737aa27b1">More...</a><br /></td></tr>
<tr class="separator:afb5a68d25d48af497b0502d737aa27b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b7e9f05230fea54c584b319a1c955b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ad8b7e9f05230fea54c584b319a1c955b">FindByType</a> (<a class="el" href="struct_any_shared_pointer.html">AnySharedPointer</a> &amp;reference) const </td></tr>
<tr class="memdesc:ad8b7e9f05230fea54c584b319a1c955b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the memo collection for the specified entry, or adds a deferred resolution marker if resolution was not possible  <a href="#ad8b7e9f05230fea54c584b319a1c955b">More...</a><br /></td></tr>
<tr class="separator:ad8b7e9f05230fea54c584b319a1c955b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053fba129c34af4c1831f97aa3b42957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_core_context_1_1_memo_entry.html">MemoEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a053fba129c34af4c1831f97aa3b42957">FindByTypeUnsafe</a> (<a class="el" href="struct_any_shared_pointer.html">AnySharedPointer</a> &amp;reference) const </td></tr>
<tr class="memdesc:a053fba129c34af4c1831f97aa3b42957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsynchronized version of FindByType  <a href="#a053fba129c34af4c1831f97aa3b42957">More...</a><br /></td></tr>
<tr class="separator:a053fba129c34af4c1831f97aa3b42957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba2d203a57db4935367fcd856d33c33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#abba2d203a57db4935367fcd856d33c33">FindByTypeRecursive</a> (<a class="el" href="struct_any_shared_pointer.html">AnySharedPointer</a> &amp;reference, const <a class="el" href="class_auto_search_lambda.html">AutoSearchLambda</a> &amp;searchFn) const </td></tr>
<tr class="memdesc:abba2d203a57db4935367fcd856d33c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive locking for Autowire satisfaction search  <a href="#abba2d203a57db4935367fcd856d33c33">More...</a><br /></td></tr>
<tr class="separator:abba2d203a57db4935367fcd856d33c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d9a9f81175cd0079afa743bce90c8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a99d9a9f81175cd0079afa743bce90c8b">AddDeferredUnsafe</a> (<a class="el" href="class_deferrable_autowiring.html">DeferrableAutowiring</a> *deferrable)</td></tr>
<tr class="memdesc:a99d9a9f81175cd0079afa743bce90c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified deferrable autowiring to be satisfied at a later date when its matched type is inserted  <a href="#a99d9a9f81175cd0079afa743bce90c8b">More...</a><br /></td></tr>
<tr class="separator:a99d9a9f81175cd0079afa743bce90c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83f60a0420935b7d1d09de44e5aa9a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ae83f60a0420935b7d1d09de44e5aa9a7">InsertSnooper</a> (std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt; snooper)</td></tr>
<tr class="memdesc:ae83f60a0420935b7d1d09de44e5aa9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a snooper to the snoopers set  <a href="#ae83f60a0420935b7d1d09de44e5aa9a7">More...</a><br /></td></tr>
<tr class="separator:ae83f60a0420935b7d1d09de44e5aa9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e22b58c311d5de7e383ab548c696930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a8e22b58c311d5de7e383ab548c696930">RemoveSnooper</a> (std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt; snooper)</td></tr>
<tr class="memdesc:a8e22b58c311d5de7e383ab548c696930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a snooper to the snoopers set  <a href="#a8e22b58c311d5de7e383ab548c696930">More...</a><br /></td></tr>
<tr class="separator:a8e22b58c311d5de7e383ab548c696930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87700127f5227d7cab423f073ab9ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ae87700127f5227d7cab423f073ab9ef0">UnsnoopEvents</a> (<a class="el" href="class_object.html">Object</a> *snooper, const <a class="el" href="struct_junction_box_entry.html">JunctionBoxEntry</a>&lt; <a class="el" href="class_object.html">Object</a> &gt; &amp;traits)</td></tr>
<tr class="memdesc:ae87700127f5227d7cab423f073ab9ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively removes the specified snooper  <a href="#ae87700127f5227d7cab423f073ab9ef0">More...</a><br /></td></tr>
<tr class="separator:ae87700127f5227d7cab423f073ab9ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba0db5c9a5f329fa2441e165e73171d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a6ba0db5c9a5f329fa2441e165e73171d">UnsnoopAutoPacket</a> (const <a class="el" href="struct_object_traits.html">ObjectTraits</a> &amp;traits)</td></tr>
<tr class="memdesc:a6ba0db5c9a5f329fa2441e165e73171d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwarding routine, only removes from this context  <a href="#a6ba0db5c9a5f329fa2441e165e73171d">More...</a><br /></td></tr>
<tr class="separator:a6ba0db5c9a5f329fa2441e165e73171d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543d73b7ea7d1a457eb61dc73758a797"><td class="memTemplParams" colspan="2">template&lt;class Fn &gt; </td></tr>
<tr class="memitem:a543d73b7ea7d1a457eb61dc73758a797"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a543d73b7ea7d1a457eb61dc73758a797">RegisterFactoryFn</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:a543d73b7ea7d1a457eb61dc73758a797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a factory <em>function</em>, a lambda which is capable of constructing decltype(fn())  <a href="#a543d73b7ea7d1a457eb61dc73758a797">More...</a><br /></td></tr>
<tr class="separator:a543d73b7ea7d1a457eb61dc73758a797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce03e373cbec97f0f01480c0d8314df"><td class="memTemplParams" colspan="2">template&lt;class Factory &gt; </td></tr>
<tr class="memitem:a7ce03e373cbec97f0f01480c0d8314df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a7ce03e373cbec97f0f01480c0d8314df">RegisterFactory</a> (Factory &amp;obj, <a class="el" href="structautowiring_1_1member__new__type.html">autowiring::member_new_type</a>&lt; Factory, autowiring::factorytype::ret_val &gt;)</td></tr>
<tr class="memdesc:a7ce03e373cbec97f0f01480c0d8314df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new foreign factory type without explicitly specifying the returned value type  <a href="#a7ce03e373cbec97f0f01480c0d8314df">More...</a><br /></td></tr>
<tr class="separator:a7ce03e373cbec97f0f01480c0d8314df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cee3b8cc0c147d35403346883b5e680"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3cee3b8cc0c147d35403346883b5e680"></a>
template&lt;class Factory &gt; </td></tr>
<tr class="memitem:a3cee3b8cc0c147d35403346883b5e680"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RegisterFactory</b> (const Factory &amp;, <a class="el" href="structautowiring_1_1member__new__type.html">autowiring::member_new_type</a>&lt; Factory, autowiring::factorytype::none &gt;)</td></tr>
<tr class="separator:a3cee3b8cc0c147d35403346883b5e680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba4757146b5fd36964396ece0f93177"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1ba4757146b5fd36964396ece0f93177"></a>
template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a1ba4757146b5fd36964396ece0f93177"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddTeardownListener2</b> (Fx &amp;&amp;fx, void(Fx::*)(void))</td></tr>
<tr class="separator:a1ba4757146b5fd36964396ece0f93177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32058150df1b0edbccd8c11b4e096761"><td class="memTemplParams" colspan="2"><a class="anchor" id="a32058150df1b0edbccd8c11b4e096761"></a>
template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a32058150df1b0edbccd8c11b4e096761"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddTeardownListener2</b> (Fx &amp;&amp;fx, void(Fx::*)(const <a class="el" href="class_core_context.html">CoreContext</a> &amp;))</td></tr>
<tr class="separator:a32058150df1b0edbccd8c11b4e096761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6606eba854b451e224975eaa725bbb3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac6606eba854b451e224975eaa725bbb3"></a>
template&lt;class Fx &gt; </td></tr>
<tr class="memitem:ac6606eba854b451e224975eaa725bbb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddTeardownListener2</b> (Fx &amp;&amp;fx, void(Fx::*)(void) const)</td></tr>
<tr class="separator:ac6606eba854b451e224975eaa725bbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad825122b43d8a5661fa4d33cbad8a576"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad825122b43d8a5661fa4d33cbad8a576"></a>
template&lt;class Fx &gt; </td></tr>
<tr class="memitem:ad825122b43d8a5661fa4d33cbad8a576"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddTeardownListener2</b> (Fx &amp;&amp;fx, void(Fx::*)(const <a class="el" href="class_core_context.html">CoreContext</a> &amp;) const)</td></tr>
<tr class="separator:ad825122b43d8a5661fa4d33cbad8a576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_teardown_notifier"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_teardown_notifier')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_teardown_notifier.html">TeardownNotifier</a></td></tr>
<tr class="memitem:af64030a83f068f3aed13ad374932f239 inherit pro_methods_class_teardown_notifier"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teardown_notifier.html#af64030a83f068f3aed13ad374932f239">NotifyTeardownListeners</a> (void)</td></tr>
<tr class="memdesc:af64030a83f068f3aed13ad374932f239 inherit pro_methods_class_teardown_notifier"><td class="mdescLeft">&#160;</td><td class="mdescRight">May be invoked prospectively by a derived instance to prematurely notify teardown listeners  <a href="#af64030a83f068f3aed13ad374932f239">More...</a><br /></td></tr>
<tr class="separator:af64030a83f068f3aed13ad374932f239 inherit pro_methods_class_teardown_notifier"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4c8efaaec332e201f8fb493df2d2fc inherit pro_methods_class_teardown_notifier"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teardown_notifier.html#abc4c8efaaec332e201f8fb493df2d2fc">AddTeardownListenerInternal</a> (<a class="el" href="struct_teardown_notifier_1_1_entry_base.html">EntryBase</a> *listener)</td></tr>
<tr class="memdesc:abc4c8efaaec332e201f8fb493df2d2fc inherit pro_methods_class_teardown_notifier"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime version of AddTeardownListener  <a href="#abc4c8efaaec332e201f8fb493df2d2fc">More...</a><br /></td></tr>
<tr class="separator:abc4c8efaaec332e201f8fb493df2d2fc inherit pro_methods_class_teardown_notifier"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2501b378098b6d5299e0498cbb5617c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2501b378098b6d5299e0498cbb5617c0"></a>
const std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_pParent</b></td></tr>
<tr class="separator:a2501b378098b6d5299e0498cbb5617c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f25f3d5ba3302c95e8bb054a62cdfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25f25f3d5ba3302c95e8bb054a62cdfd"></a>
const t_childList::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>m_backReference</b></td></tr>
<tr class="separator:a25f25f3d5ba3302c95e8bb054a62cdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785440c77cb0b555fd146ba3df9b29d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a785440c77cb0b555fd146ba3df9b29d0"></a>
std::unique_ptr&lt; <a class="el" href="struct_core_context_state_block.html">CoreContextStateBlock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_stateBlock</b></td></tr>
<tr class="separator:a785440c77cb0b555fd146ba3df9b29d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1feaab4481d00b04a466e8904fb7f2e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1feaab4481d00b04a466e8904fb7f2e2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_beforeRunning</b></td></tr>
<tr class="separator:a1feaab4481d00b04a466e8904fb7f2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb76e267d9038b3671a02a310b17ac5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeb76e267d9038b3671a02a310b17ac5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_initiated</b></td></tr>
<tr class="separator:aaeb76e267d9038b3671a02a310b17ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cc83bc63c3d3c66bede9eaa09ddc2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34cc83bc63c3d3c66bede9eaa09ddc2f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_isShutdown</b></td></tr>
<tr class="separator:a34cc83bc63c3d3c66bede9eaa09ddc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab4d8f7826689502034c68f77d6ff65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ab4d8f7826689502034c68f77d6ff65"></a>
t_childList&#160;</td><td class="memItemRight" valign="bottom"><b>m_children</b></td></tr>
<tr class="separator:a9ab4d8f7826689502034c68f77d6ff65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e193f76865bd3d813da88abf9ea67b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36e193f76865bd3d813da88abf9ea67b"></a>
t_contextNameListeners&#160;</td><td class="memItemRight" valign="bottom"><b>m_nameListeners</b></td></tr>
<tr class="separator:a36e193f76865bd3d813da88abf9ea67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfb3514a1fbab1512114313df014c5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cfb3514a1fbab1512114313df014c5d"></a>
std::list&lt; <a class="el" href="struct_object_traits.html">ObjectTraits</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_concreteTypes</b></td></tr>
<tr class="separator:a0cfb3514a1fbab1512114313df014c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e9f42ab2320db72b93d04a883f9294"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8e9f42ab2320db72b93d04a883f9294"></a>
std::unordered_map&lt; std::type_index, <a class="el" href="struct_core_context_1_1_memo_entry.html">MemoEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_typeMemos</b></td></tr>
<tr class="separator:ab8e9f42ab2320db72b93d04a883f9294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accafbaceb7b000ba4a3cbbb2684b39e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accafbaceb7b000ba4a3cbbb2684b39e5"></a>
std::vector&lt; <a class="el" href="class_context_member.html">ContextMember</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_contextMembers</b></td></tr>
<tr class="separator:accafbaceb7b000ba4a3cbbb2684b39e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a2c1c69e95644bb5bd8cc5fd39cbcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9a2c1c69e95644bb5bd8cc5fd39cbcd"></a>
std::vector&lt; <a class="el" href="class_exception_filter.html">ExceptionFilter</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_filters</b></td></tr>
<tr class="separator:af9a2c1c69e95644bb5bd8cc5fd39cbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ece57881be0dc719ca89c4847b693b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ece57881be0dc719ca89c4847b693b5"></a>
t_rcvrSet&#160;</td><td class="memItemRight" valign="bottom"><b>m_eventReceivers</b></td></tr>
<tr class="separator:a4ece57881be0dc719ca89c4847b693b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc1c409cb4d3ecaf30ded9b670d96f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dc1c409cb4d3ecaf30ded9b670d96f8"></a>
t_rcvrSet&#160;</td><td class="memItemRight" valign="bottom"><b>m_delayedEventReceivers</b></td></tr>
<tr class="separator:a6dc1c409cb4d3ecaf30ded9b670d96f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dc4b4a1ca9460ba9c4944fef9da66a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27dc4b4a1ca9460ba9c4944fef9da66a"></a>
std::set&lt; <a class="el" href="class_object.html">Object</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_snoopers</b></td></tr>
<tr class="separator:a27dc4b4a1ca9460ba9c4944fef9da66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84e8a3620c5cd0de3edef21d302446d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab84e8a3620c5cd0de3edef21d302446d"></a>
const std::shared_ptr&lt; <a class="el" href="class_junction_box_manager.html">JunctionBoxManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_junctionBoxManager</b></td></tr>
<tr class="separator:ab84e8a3620c5cd0de3edef21d302446d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b905ceee36b96af2fe0b9a6eff4003"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95b905ceee36b96af2fe0b9a6eff4003"></a>
t_threadList&#160;</td><td class="memItemRight" valign="bottom"><b>m_threads</b></td></tr>
<tr class="separator:a95b905ceee36b96af2fe0b9a6eff4003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2477eafac5df61ac12c328034471f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd2477eafac5df61ac12c328034471f7"></a>
std::weak_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_outstanding</b></td></tr>
<tr class="separator:afd2477eafac5df61ac12c328034471f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_teardown_notifier"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_teardown_notifier')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_teardown_notifier.html">TeardownNotifier</a></td></tr>
<tr class="memitem:a22ae6bc94ba1db7b31fbc2b687f5494c inherit pro_attribs_class_teardown_notifier"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22ae6bc94ba1db7b31fbc2b687f5494c"></a>
<a class="el" href="struct_teardown_notifier_1_1_entry_base.html">EntryBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_pFirstTeardownListener</b></td></tr>
<tr class="separator:a22ae6bc94ba1db7b31fbc2b687f5494c inherit pro_attribs_class_teardown_notifier"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a547b876463511c1860a149442e6cc147"><td class="memTemplParams" colspan="2"><a class="anchor" id="a547b876463511c1860a149442e6cc147"></a>
template&lt;autowiring::construction_strategy , class T , class... Args&gt; </td></tr>
<tr class="memitem:a547b876463511c1860a149442e6cc147"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>autowiring::crh</b></td></tr>
<tr class="separator:a547b876463511c1860a149442e6cc147"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A top-level container class representing an autowiring domain, a minimum broadcast domain, and a thread execution domain </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a47d6a49f021ddb69312c49e5ab8794c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::AddBolt </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_bolt_base.html">BoltBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified context creation listener to receive creation events broadcast from this context </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBase</td><td>The instance being added</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92caeb3111312c536a3f5114e63cb444"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::AddContextMember </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_context_member.html">ContextMember</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of Add based on <a class="el" href="class_context_member.html" title="A class that must be inherited in order to be a member of a context heriarchy ">ContextMember</a> </p>

</div>
</div>
<a class="anchor" id="a9c5171e011503a16a4928bba813ad38a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::AddCoreRunnable </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_core_runnable.html">CoreRunnable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pCoreRunnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an object of any kind to the IOC container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContextMember</td><td>The member which was added</td></tr>
    <tr><td class="paramname">notReady</td><td>Allows the insertion of a thread, even if that thread isn't ready yet</td></tr>
  </table>
  </dd>
</dl>
<p>&lt;return&gt;The shared pointer which contains the context member.&lt;/return&gt; </p>
<p>It's safe to allow the returned shared_ptr to go out of scope; the core context will continue to hold a reference to it until Remove is invoked. </p>

</div>
</div>
<a class="anchor" id="a99d9a9f81175cd0079afa743bce90c8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::AddDeferredUnsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_deferrable_autowiring.html">DeferrableAutowiring</a> *&#160;</td>
          <td class="paramname"><em>deferrable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified deferrable autowiring to be satisfied at a later date when its matched type is inserted </p>

</div>
</div>
<a class="anchor" id="a7a024e1d27e6c92ae4b41cf2f17945cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::AddEventReceiver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_junction_box_entry.html">JunctionBoxEntry</a>&lt; <a class="el" href="class_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pRecvr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the named event receiver to the collection of known receivers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRecvr</td><td>The junction box entry corresponding to the receiver type</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a290d80061956f9ef893fb58fc1424afb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::AddEventReceivers </td>
          <td>(</td>
          <td class="paramtype">const t_rcvrSet &amp;&#160;</td>
          <td class="paramname"><em>receivers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add delayed event receivers </p>

</div>
</div>
<a class="anchor" id="afb5a68d25d48af497b0502d737aa27b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::AddInternal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_object_traits.html">ObjectTraits</a> &amp;&#160;</td>
          <td class="paramname"><em>traits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal type introduction routine </p>

</div>
</div>
<a class="anchor" id="aafa5bc00c7f05c4009bc20a796605cda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::AddPacketSubscriber </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_auto_filter_descriptor.html">AutoFilterDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwarding routine, recursively adds a packet subscriber to the internal packet factory </p>

</div>
</div>
<a class="anchor" id="a7447775cbe9d10c8018c0b7344a1fdc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::AddTeardownListener </td>
          <td>(</td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a teardown notifier which receives a pointer to this context on destruction </p>

</div>
</div>
<a class="anchor" id="ada59ec3baf8cb335d6e0792dd1473705"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Autowire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_any_shared_pointer_t.html">AnySharedPointerT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_deferrable_autowiring.html">DeferrableAutowiring</a> &amp;&#160;</td>
          <td class="paramname"><em>defer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a slot to be autowired </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>The space where the resolved shared pointer will be stored</td></tr>
    <tr><td class="paramname">defer</td><td>In the event that resolution was not successful, the deferrable that will be used to perform delayed satisfaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81cde2e3e4031ac1bc1c9e761f8eff11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Sigils&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::BoltTo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes the specified type T to be injected in any subcontext created with one of the matching sigil types </p>

</div>
</div>
<a class="anchor" id="a156dd07f25adb19c4ab262e2666dfd94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::BroadcastContextCreationNotice </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>sigil</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts a notice to any listener in the current context regarding a creation event on a particular context name </p>
<p>The broadcast is made without altering the current context. Recipients expect that the current context will be the one about which they are being informed. </p>

</div>
</div>
<a class="anchor" id="aeed970b70575e2be12dd9b5129c1355a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::BuildCurrentState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <a class="el" href="class_autowiring_events.html" title="These events are broadcast internally by Autowiring for visualizing internal behavior. </summary ">AutowiringEvents</a> to build current state </p>

</div>
</div>
<a class="anchor" id="ae784ab63f9d15a717cdcb3a4a22466c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::CancelAutowiringNotification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_deferrable_autowiring.html">DeferrableAutowiring</a> *&#160;</td>
          <td class="paramname"><em>pDeferrable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a slot as a recipient of potential autowiring </p>

</div>
</div>
<a class="anchor" id="a198a4ee1d3f001f14e3139f52d91160e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_basic_thread.html">BasicThread</a> &gt; &gt; CoreContext::CopyBasicThreadList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A copy of the list of child CoreRunnables </dd></dl>
<p>No guarantee is made about how long the returned collection will be consistent with this context. A thread may potentially be added to the context after the method returns. </p>

</div>
</div>
<a class="anchor" id="a4bec68515169c46d817190ef4231c0ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="class_core_context.html">CoreContext</a>&gt; CoreContext::Create </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td>
          <td class="paramname"><em>pParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_childList::iterator&#160;</td>
          <td class="paramname"><em>backReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td>
          <td class="paramname"><em>pPeer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creation helper routine </p>

</div>
</div>
<a class="anchor" id="afc43e4945b02d5deae2c94b55960a024"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_core_context.html">CoreContext</a>&gt; CoreContext::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_auto_injectable.html">AutoInjectable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>inj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory to create a new context </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The context sigil.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb6d54466d0eb7753ad8be8e43451fbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; CoreContext::CreateInternal </td>
          <td>(</td>
          <td class="paramtype">t_pfnCreate&#160;</td>
          <td class="paramname"><em>pfnCreate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td>
          <td class="paramname"><em>pPeer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_auto_injectable.html">AutoInjectable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>pInj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register new context with parent and notify others of its creation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfnCreate</td><td>A creation routine which can create the desired context</td></tr>
    <tr><td class="paramname">pPeer</td><td>The peer context, if one exists</td></tr>
    <tr><td class="paramname">inj</td><td>An injectable to be inserted into the context before bolts are fired</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a726e4e05369193fcf5855e9566b41e2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; CoreContext::CreateInternal </td>
          <td>(</td>
          <td class="paramtype">t_pfnCreate&#160;</td>
          <td class="paramname"><em>pfnCreate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td>
          <td class="paramname"><em>pPeer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload which does not perform injection </p>

</div>
</div>
<a class="anchor" id="a94a1163a33eb268e7fd943b05e7892d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_core_context.html">CoreContext</a>&gt; CoreContext::CreatePeer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory to create a peer context </p>
<p>A peer context allows clients to create autowiring contexts which are in the same event domain with respect to each other, but are not in the same autowiring domain. This can be useful where multiple instances of a particular object are desired, but inserting such objects into a simple child context is cumbersome because the objects at parent scope are listening to events originating from objects at child scope. Events can be fired, but not received, from an unintiated context if its peer is initiated. </p>

</div>
</div>
<a class="anchor" id="a8272447038b5515a05ba9b56e9d75d7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; CoreContext::CurrentContext </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This retrieves a shared pointer to the current context. It is only contextually relevant. </p>
<p>&lt;return&gt; The last core context to have called SetCurrent in the current thread, or else an empty pointer &lt;/return&gt; </p>
<p>This works by using thread-local store, and so is safe in multithreaded systems. The current context is assigned before invoking a <a class="el" href="class_core_runnable.html">CoreRunnable</a> instance's Run method, and it's also assigned when a context is first constructed by a thread. </p>

</div>
</div>
<a class="anchor" id="abafba926a5bb2aa13f15c4de0d0df019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::DelayUntilInitiated </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the context is initiated or is shutting down </p>
<dl class="section return"><dt>Returns</dt><dd>True if initiated, false if shutting down</dd></dl>

</div>
</div>
<a class="anchor" id="a8bc3598a2c82c5452ec5b942ec84ceed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility debug method for writing a snapshot of this context to the specified output stream </p>

</div>
</div>
<a class="anchor" id="a86ef42fac99a89891c9cff760bd46ee8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows a specifically named class to be bolted </p>
<p>If the specified type does not inherit from BoltTo, this method has no effect </p>

</div>
</div>
<a class="anchor" id="af4a61b01ae5958603a643a4de2d42e83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::EvictCurrent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes no context current </p>
<p>Generally speaking, users wishing to release their reference to some context can do so simply by making the global context current. </p>

</div>
</div>
<a class="anchor" id="a5b5b71f520358864f1cf52eb108aceb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::FilterException </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters std::current_exception using any registered exception filters, or rethrows. </p>
<p>The passed exception is assumed to be a generic exception whose default behavior shall be to tear down the context. It will be the caller's responsibility to ensure that this behavior is observed.</p>
<p>If the exception is successfully handled by a filter, this method returns cleanly. Otherwise, this method is equivalent to std::rethrow_exception. </p>

</div>
</div>
<a class="anchor" id="acf39b096026f4f48c7fc1326f1f25426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::FilterFiringException </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_junction_box_base.html">JunctionBoxBase</a> *&#160;</td>
          <td class="paramname"><em>pProxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_object.html">Object</a> *&#160;</td>
          <td class="paramname"><em>pRecipient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a std::current_exception thrown by an EventSenderBase during a Fire </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pProxy</td><td>The sender of the event</td></tr>
    <tr><td class="paramname">pRecipient</td><td>The recipient of the event</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8b7e9f05230fea54c584b319a1c955b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::FindByType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_any_shared_pointer.html">AnySharedPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans the memo collection for the specified entry, or adds a deferred resolution marker if resolution was not possible </p>
<dl class="section return"><dt>Returns</dt><dd>The memo entry where this type was found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>An initialized shared pointer slot which may be used in type detection</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad49a3f07a2ab270baa6cec93707127bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::FindByType </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove EventReceiver from parents unless its a member of the parent </p>
<p>Locates an available context member in this context </p>

</div>
</div>
<a class="anchor" id="abba2d203a57db4935367fcd856d33c33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::FindByTypeRecursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_any_shared_pointer.html">AnySharedPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_auto_search_lambda.html">AutoSearchLambda</a> &amp;&#160;</td>
          <td class="paramname"><em>searchFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursive locking for Autowire satisfaction search </p>

</div>
</div>
<a class="anchor" id="a01014fe31d9a6a10cc7357a5924a6460"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::FindByTypeRecursive </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identical to Autowire, but will not register the passed slot for deferred resolution </p>

</div>
</div>
<a class="anchor" id="a6936a4534f8d5b7c959bfed783c0eed5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::FindByTypeRecursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_any_shared_pointer_t.html">AnySharedPointerT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identical to Autowire, but will not register the passed slot for deferred resolution </p>

</div>
</div>
<a class="anchor" id="a053fba129c34af4c1831f97aa3b42957"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_core_context_1_1_memo_entry.html">CoreContext::MemoEntry</a> &amp; CoreContext::FindByTypeUnsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_any_shared_pointer.html">AnySharedPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsynchronized version of FindByType </p>

</div>
</div>
<a class="anchor" id="aadefc1626bfcdb4f1a8cc7b4afd50e98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; CoreContext::FirstChild </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The first child in the set of this context's children </dd></dl>

</div>
</div>
<a class="anchor" id="afa3d68e3e2a36c0137c98c829729cbd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info &amp; CoreContext::GetAutoTypeId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_any_shared_pointer.html">AnySharedPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The type identifier of the specified type identifier </dd></dl>
<p>The returned type structure will be the actual type of the specified object as defined at the time of injection. In the case of a static factory new or <a class="el" href="class_core_context_1_1_auto_factory.html" title="A proxy context member that knows how to create a factory for a particular type ">AutoFactory</a> new, this type will be the type of the interface. All other members are the concrete type actually injected, as opposed to the type unifier for that type.</p>
<p>This method will throw an exception if the passed shared pointer is not strictly a member of this context </p>

</div>
</div>
<a class="anchor" id="a4b2b185fd5c86dd09b868a929a53d349"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; CoreContext::GetGlobal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to obtain a shared reference to the global context </p>

</div>
</div>
<a class="anchor" id="abfbd67d6fac649763f86c1eadd333788"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_junction_box.html">JunctionBox</a>&lt;T&gt; &gt; CoreContext::GetJunctionBox </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a shared pointer to an event sender <em>in this context</em> matching the specified type </p>

</div>
</div>
<a class="anchor" id="aff72e44be09394686d51a367a6ff9e23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::Has </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the specified type can be autowired in this context </dd></dl>

</div>
</div>
<a class="anchor" id="a5a772a84b896a9930bbcf4047420b6ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt; CoreContext::IncrementOutstandingThreadCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the total number of contexts still outstanding </p>
<p>This is an indirect incrementation routine. The count will be incremented for as long as the returned shared_ptr is not destroyed. Once it's destroyed, the count is decremented. The caller is encouraged not to copy the return value, as doing so can give inflated values for the current number of outstanding threads.</p>
<p>The caller is responsible for exterior synchronization </p>

</div>
</div>
<a class="anchor" id="aec4c58c375caaeb70d20807cd4029657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Initiate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility routine, invoked typically by the service, which starts all registered core threads. </p>

</div>
</div>
<a class="anchor" id="a005f71baab03719918429b7ecdd8a9ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; CoreContext::Inject </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility method which will inject the specified types into this context </p>
<p>Arguments will be passed to the T constructor if provided </p>

</div>
</div>
<a class="anchor" id="a0716b1184e3fba32e64c06160d3153a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CoreContext::InjectCurrent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static version of Inject that uses the current context </p>

</div>
</div>
<a class="anchor" id="ae83f60a0420935b7d1d09de44e5aa9a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::InsertSnooper </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>snooper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a snooper to the snoopers set </p>

</div>
</div>
<a class="anchor" id="a1fe1f8ada791176b9c4893963b74aee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_invoke_relay.html">InvokeRelay</a>&lt;MemFn&gt; CoreContext::Invoke </td>
          <td>(</td>
          <td class="paramtype">MemFn&#160;</td>
          <td class="paramname"><em>memFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method which allows an event to be fired without making the remote context current </p>
<p>The following two statements are equivalent:</p>
<p><a class="el" href="class_current_context_pusher.html" title="Saves the current context and makes the passed one current, and then restores the current context whe...">CurrentContextPusher(ctxt)</a>, (AutoFired&lt;MyEventType&gt;())(&amp;MyEventType::MyEvent)();</p>
<p>ctxt-&gt;Invoke(&amp;MyEventType::MyEvent)();</p>

</div>
</div>
<a class="anchor" id="aefaae7d459f3ee07dce5b65c731e7900"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sigil &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::Is </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the sigil type of this <a class="el" href="class_core_context.html" title="A top-level container class representing an autowiring domain, a minimum broadcast domain...">CoreContext</a> matches the specified sigil type </dd></dl>

</div>
</div>
<a class="anchor" id="a46ab31f4f5f30284304bca63390f9545"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::IsAncestorOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_core_context.html">CoreContext</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this context is an ancestor of the specified context </dd></dl>
<p>This method will also return true if this == child </p>

</div>
</div>
<a class="anchor" id="a6b08c5f0dead4908659cf87c6eb77abb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::IsShutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if <a class="el" href="class_core_runnable.html">CoreRunnable</a> instances in this context should begin teardown operations </dd></dl>

</div>
</div>
<a class="anchor" id="aed50fd3fbf376a831935254caf28f763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; CoreContext::NextSibling </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The next context sharing the same parent, or null if this is the last entry in the list </dd></dl>

</div>
</div>
<a class="anchor" id="af5920389c012b628511fe22dfb1dadb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_autowirable_slot_fn.html">AutowirableSlotFn</a>&lt;T, Fn&gt;* CoreContext::NotifyWhenAutowired </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a post-attachment listener in this context for a particular autowired member. There is no guarantee for the context in which the listener will be called. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a deferrable autowiring function which the caller may safely ignore if it's not needed. Returns nullptr if the call was made immediately. </dd></dl>
<p>This method will succeed if slot was constructed in this context or any parent context. If the passed slot was not created in this context or a parent context, an exception will be thrown.</p>
<p>It's possible that the passed slot will never be filled, and instead the corresponding instance destroyed without ever having been initialized.</p>
<p>If the passed slot is already autowired, then the listener will be invoked immediately from the body of this method. Care should be taken to avoid deadlocks in this case&ndash;either the caller must not be holding any locks when this method is invoked, or the caller should design the listener method such that it may be substitutde in place for the notification routine.</p>
<p>The returned value may be used later in CancelAutowiringNotification in order to explicitly clean up memory. </p>

</div>
</div>
<a class="anchor" id="a7ce03e373cbec97f0f01480c0d8314df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Factory &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::RegisterFactory </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structautowiring_1_1member__new__type.html">autowiring::member_new_type</a>&lt; Factory, autowiring::factorytype::ret_val &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a new foreign factory type without explicitly specifying the returned value type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Factory</td><td>The factory type to be added</td></tr>
    <tr><td class="paramname">obj</td><td>A reference to the factory proper</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a543d73b7ea7d1a457eb61dc73758a797"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::RegisterFactoryFn </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a factory <em>function</em>, a lambda which is capable of constructing decltype(fn()) </p>

</div>
</div>
<a class="anchor" id="ad4038a78b4adff993dbb8733236308ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::RemoveEventReceivers </td>
          <td>(</td>
          <td class="paramtype">const t_rcvrSet &amp;&#160;</td>
          <td class="paramname"><em>receivers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all recognized event receivers in the indicated range </p>

</div>
</div>
<a class="anchor" id="a8e22b58c311d5de7e383ab548c696930"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::RemoveSnooper </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>snooper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a snooper to the snoopers set </p>

</div>
</div>
<a class="anchor" id="a04eb5256cf9d82e8b22dfe226100714c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; CoreContext::SetCurrent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This makes this core context current. </p>
<dl class="section return"><dt>Returns</dt><dd>The previously current context</dd></dl>

</div>
</div>
<a class="anchor" id="a8e0ff07669244590fcdcec9aeb588aa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::SignalShutdown </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShutdownMode&#160;</td>
          <td class="paramname"><em>shutdownMode</em> = <code>ShutdownMode::Graceful</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This signals to the whole system that a shutdown operation is underway, and that shutdown procedures should begin immediately </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait</td><td>Set if the function should wait for all child contexts to exit before returning</td></tr>
  </table>
  </dd>
</dl>
<p>This method will immediately prevent any new events from being recieved by this context or by any descendant context, whether those events are fired in this context or one above, and regardless of whether these events are fired or deferred. Event receivers in this context will also not receive any messages. </p>

</div>
</div>
<a class="anchor" id="a107256cd9f29a43301afca98cd7309a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::SignalTerminate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for SignalShutdown(true, ShutdownMode::Immediate) </p>

</div>
</div>
<a class="anchor" id="a861a5330dfe8fb609c2de97d2ea937a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Snoop </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pSnooper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the passed event receiver to obtain messages broadcast by this context </p>
<p>This enables the passed event receiver to snoop events that are broadcast from a parent context. The passed event receiver MUST exist in a parent context, or the behavior of this method may be undefined during teardown.</p>
<p>The snooper will not receive any events broadcast from parent contexts. ONLY events broadcast in THIS context will be forwarded to the snooper. </p>

</div>
</div>
<a class="anchor" id="ab31a7a286dded4026fe4dd263eb22076"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Snoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_autowired.html">Autowired</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>snooper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolution overload </p>

</div>
</div>
<a class="anchor" id="a991be17630104176c56c36eabc40da07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::UnregisterEventReceiversUnsafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters all event receivers in this context </p>

</div>
</div>
<a class="anchor" id="ae98a62b5ff67127aa2f870ec54196fd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Unsnoop </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pSnooper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters an event receiver previously registered to receive snooped events </p>
<p>It is an error to call this method without a prior call to Snoop </p>

</div>
</div>
<a class="anchor" id="ac584c161af922db0482b30d8aa232146"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Unsnoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_autowired.html">Autowired</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>snooper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolution overload </p>

</div>
</div>
<a class="anchor" id="a6ba0db5c9a5f329fa2441e165e73171d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::UnsnoopAutoPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_object_traits.html">ObjectTraits</a> &amp;&#160;</td>
          <td class="paramname"><em>traits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwarding routine, only removes from this context </p>

</div>
</div>
<a class="anchor" id="ae87700127f5227d7cab423f073ab9ef0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::UnsnoopEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_object.html">Object</a> *&#160;</td>
          <td class="paramname"><em>snooper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_junction_box_entry.html">JunctionBoxEntry</a>&lt; <a class="el" href="class_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively removes the specified snooper </p>
<p>This method has no effect if the passed value is presently a snooper in this context; the snooper collection must therefore be updated prior to the call to this method. </p>

</div>
</div>
<a class="anchor" id="ade3295b11b91d66a8dde52cacdbeebe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::UpdateDeferredElements </td>
          <td>(</td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_object_traits.html">ObjectTraits</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes all deferred autowiring fields, generally called after a new member has been added </p>

</div>
</div>
<a class="anchor" id="a846274ca88865c63655b5eeb054d12b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until the context is transitioned to the Stopped state and all threads and child threads have terminated. </p>

</div>
</div>
<a class="anchor" id="a6708295354459d99f39f4f4a2899211d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::Wait </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed overload </p>

</div>
</div>
<a class="anchor" id="ad12f8a7181248f040bde3fd4cdcd799e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::WasStarted </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this context was ever started </dd></dl>
<p>A return value of "true" is guaranteed to be indefinitely correct. A return value of "false" will only be correct for as long as it takes for someone to start this context. Unless externally synchronized, this operation may return false on a running context. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>autowiring/<a class="el" href="_core_context_8h_source.html">CoreContext.h</a></li>
<li>src/autowiring/CoreContext.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 19 2015 11:57:30 for Autowiring by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
