<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Autowiring: CoreContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.7.7</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Developer's&#160;Guide</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_core_context.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_core_context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CoreContext Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A top-level container class representing an autowiring domain, a minimum broadcast domain, and a thread execution domain.  
 <a href="class_core_context.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_core_context_8h_source.html">CoreContext.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CoreContext:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_core_context.png" usemap="#CoreContext_map" alt=""/>
  <map id="CoreContext_map" name="CoreContext_map">
<area href="class_core_context_t.html" title="A type of CoreContext that has a sigil. " alt="CoreContextT&lt; T &gt;" shape="rect" coords="0,56,219,80"/>
<area href="class_core_context_t.html" alt="CoreContextT&lt; GlobalCoreContext &gt;" shape="rect" coords="229,56,448,80"/>
<area href="class_global_core_context.html" title="A special class designed to make it easier to detect when our context is the global context..." alt="GlobalCoreContext" shape="rect" coords="229,112,448,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a274e47cff1ae841fe66e03a186d8eede"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a274e47cff1ae841fe66e03a186d8eede"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a274e47cff1ae841fe66e03a186d8eede">Add</a> (const std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a274e47cff1ae841fe66e03a186d8eede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces the specified pointer to this context explicitly  <a href="#a274e47cff1ae841fe66e03a186d8eede">More...</a><br /></td></tr>
<tr class="separator:a274e47cff1ae841fe66e03a186d8eede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0312724984a15bffd56019af5a2737"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a7e0312724984a15bffd56019af5a2737">AddSnooper</a> (const CoreObjectDescriptor &amp;traits)</td></tr>
<tr class="memdesc:a7e0312724984a15bffd56019af5a2737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime version of AddSnooper  <a href="#a7e0312724984a15bffd56019af5a2737">More...</a><br /></td></tr>
<tr class="separator:a7e0312724984a15bffd56019af5a2737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670aaca238bf0f7db59bcdb71f84ccd0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a670aaca238bf0f7db59bcdb71f84ccd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a670aaca238bf0f7db59bcdb71f84ccd0">AddSnooper</a> (const std::shared_ptr&lt; T &gt; &amp;pSnooper)</td></tr>
<tr class="memdesc:a670aaca238bf0f7db59bcdb71f84ccd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified event receiver to receive messages from this context  <a href="#a670aaca238bf0f7db59bcdb71f84ccd0">More...</a><br /></td></tr>
<tr class="separator:a670aaca238bf0f7db59bcdb71f84ccd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a34fcd446e51c5c006d9f3d46b4cc7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a01a34fcd446e51c5c006d9f3d46b4cc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a01a34fcd446e51c5c006d9f3d46b4cc7">AddSnooper</a> (const <a class="el" href="class_autowired.html">Autowired</a>&lt; T &gt; &amp;snooper)</td></tr>
<tr class="memdesc:a01a34fcd446e51c5c006d9f3d46b4cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolution overload  <a href="#a01a34fcd446e51c5c006d9f3d46b4cc7">More...</a><br /></td></tr>
<tr class="separator:a01a34fcd446e51c5c006d9f3d46b4cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a9b70597e2ce15604bd823758408c6"><td class="memItemLeft" align="right" valign="top">JunctionBoxBase &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ad7a9b70597e2ce15604bd823758408c6">All</a> (const std::type_info &amp;ti) const </td></tr>
<tr class="memdesc:ad7a9b70597e2ce15604bd823758408c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime variant of All  <a href="#ad7a9b70597e2ce15604bd823758408c6">More...</a><br /></td></tr>
<tr class="separator:ad7a9b70597e2ce15604bd823758408c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5c351a08cc681adb51e7eb21ec6303"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aae5c351a08cc681adb51e7eb21ec6303"><td class="memTemplItemLeft" align="right" valign="top">JunctionBox&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#aae5c351a08cc681adb51e7eb21ec6303">All</a> (void)</td></tr>
<tr class="memdesc:aae5c351a08cc681adb51e7eb21ec6303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all members of and snoopers on this context which implement the specified interface  <a href="#aae5c351a08cc681adb51e7eb21ec6303">More...</a><br /></td></tr>
<tr class="separator:aae5c351a08cc681adb51e7eb21ec6303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cde2e3e4031ac1bc1c9e761f8eff11"><td class="memTemplParams" colspan="2">template&lt;class T , class... Sigils&gt; </td></tr>
<tr class="memitem:a81cde2e3e4031ac1bc1c9e761f8eff11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a81cde2e3e4031ac1bc1c9e761f8eff11">BoltTo</a> (void)</td></tr>
<tr class="memdesc:a81cde2e3e4031ac1bc1c9e761f8eff11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects the specified type T into all subcontexts created with one of the matching sigil types.  <a href="#a81cde2e3e4031ac1bc1c9e761f8eff11">More...</a><br /></td></tr>
<tr class="separator:a81cde2e3e4031ac1bc1c9e761f8eff11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248d2983aeb495dfa013024d10fbfc16"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_basic_thread.html">BasicThread</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a248d2983aeb495dfa013024d10fbfc16">CopyBasicThreadList</a> (void) const </td></tr>
<tr class="memdesc:a248d2983aeb495dfa013024d10fbfc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy of the current list of child CoreRunnables of this context.  <a href="#a248d2983aeb495dfa013024d10fbfc16">More...</a><br /></td></tr>
<tr class="separator:a248d2983aeb495dfa013024d10fbfc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edf5743ee22ca42a0ca3d8cff226fca"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6edf5743ee22ca42a0ca3d8cff226fca"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context_t.html">CoreContextT</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a6edf5743ee22ca42a0ca3d8cff226fca">Create</a> (void)</td></tr>
<tr class="memdesc:a6edf5743ee22ca42a0ca3d8cff226fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a child context of this context.  <a href="#a6edf5743ee22ca42a0ca3d8cff226fca">More...</a><br /></td></tr>
<tr class="separator:a6edf5743ee22ca42a0ca3d8cff226fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafba926a5bb2aa13f15c4de0d0df019"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#abafba926a5bb2aa13f15c4de0d0df019">DelayUntilInitiated</a> (void)</td></tr>
<tr class="memdesc:abafba926a5bb2aa13f15c4de0d0df019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the context is initiated or, if never initiated, until it starts shutting down.  <a href="#abafba926a5bb2aa13f15c4de0d0df019">More...</a><br /></td></tr>
<tr class="separator:abafba926a5bb2aa13f15c4de0d0df019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9cb8e948aee0f4c90e0ec8f89d99cf"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a1a9cb8e948aee0f4c90e0ec8f89d99cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a1a9cb8e948aee0f4c90e0ec8f89d99cf">DEPRECATED</a> (AddTeardownListener(Fx &amp;&amp;fx),&quot;Superceded by onTeardown&quot;)</td></tr>
<tr class="memdesc:a1a9cb8e948aee0f4c90e0ec8f89d99cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a teardown notifier which receives a pointer to this context on destruction  <a href="#a1a9cb8e948aee0f4c90e0ec8f89d99cf">More...</a><br /></td></tr>
<tr class="separator:a1a9cb8e948aee0f4c90e0ec8f89d99cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc3598a2c82c5452ec5b942ec84ceed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a8bc3598a2c82c5452ec5b942ec84ceed">Dump</a> (std::ostream &amp;os) const </td></tr>
<tr class="memdesc:a8bc3598a2c82c5452ec5b942ec84ceed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility debug method for writing a snapshot of this context to the specified output stream  <a href="#a8bc3598a2c82c5452ec5b942ec84ceed">More...</a><br /></td></tr>
<tr class="separator:a8bc3598a2c82c5452ec5b942ec84ceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ef42fac99a89891c9cff760bd46ee8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a86ef42fac99a89891c9cff760bd46ee8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a86ef42fac99a89891c9cff760bd46ee8">Enable</a> (void)</td></tr>
<tr class="memdesc:a86ef42fac99a89891c9cff760bd46ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a specifically named class to be "bolted" to this context or one of its subcontexts.  <a href="#a86ef42fac99a89891c9cff760bd46ee8">More...</a><br /></td></tr>
<tr class="separator:a86ef42fac99a89891c9cff760bd46ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5b71f520358864f1cf52eb108aceb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a5b5b71f520358864f1cf52eb108aceb3">FilterException</a> (void)</td></tr>
<tr class="memdesc:a5b5b71f520358864f1cf52eb108aceb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters std::current_exception using any registered exception filters, or rethrows.  <a href="#a5b5b71f520358864f1cf52eb108aceb3">More...</a><br /></td></tr>
<tr class="separator:a5b5b71f520358864f1cf52eb108aceb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14de7efacd23075c69ea134a7a45f4a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a14de7efacd23075c69ea134a7a45f4a8">FilterFiringException</a> (const JunctionBoxBase *pProxy, CoreObject *pRecipient)</td></tr>
<tr class="memdesc:a14de7efacd23075c69ea134a7a45f4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a std::current_exception thrown by an EventSenderBase during a Fire  <a href="#a14de7efacd23075c69ea134a7a45f4a8">More...</a><br /></td></tr>
<tr class="separator:a14de7efacd23075c69ea134a7a45f4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5cef7deb0bf47f0c6d51ee015f6750"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#aac5cef7deb0bf47f0c6d51ee015f6750">FirstChild</a> (void) const </td></tr>
<tr class="memdesc:aac5cef7deb0bf47f0c6d51ee015f6750"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first child in the set of this context's children.  <a href="#aac5cef7deb0bf47f0c6d51ee015f6750">More...</a><br /></td></tr>
<tr class="separator:aac5cef7deb0bf47f0c6d51ee015f6750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5eee91bb723177b240ba727f41b5733"><td class="memItemLeft" align="right" valign="top">auto_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#af5eee91bb723177b240ba727f41b5733">GetAutoTypeId</a> (const AnySharedPointer &amp;ptr) const </td></tr>
<tr class="memdesc:af5eee91bb723177b240ba727f41b5733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type information for the instance referenced by the specified shared pointer.  <a href="#af5eee91bb723177b240ba727f41b5733">More...</a><br /></td></tr>
<tr class="separator:af5eee91bb723177b240ba727f41b5733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88653daf77a40b41dec8e64c175813d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae88653daf77a40b41dec8e64c175813d"></a>
t_childList::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ae88653daf77a40b41dec8e64c175813d">GetBackReference</a> (void) const </td></tr>
<tr class="memdesc:ae88653daf77a40b41dec8e64c175813d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Context iterator for the parent context's children, pointing to this context. <br /></td></tr>
<tr class="separator:ae88653daf77a40b41dec8e64c175813d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26665562a7e88fb2ecb00e1ae56432c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26665562a7e88fb2ecb00e1ae56432c6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a26665562a7e88fb2ecb00e1ae56432c6">GetChildCount</a> (void) const </td></tr>
<tr class="memdesc:a26665562a7e88fb2ecb00e1ae56432c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of child contexts of this context. <br /></td></tr>
<tr class="separator:a26665562a7e88fb2ecb00e1ae56432c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad725f1858d6305af6721e575bb312674"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad725f1858d6305af6721e575bb312674"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ad725f1858d6305af6721e575bb312674">GetMemberCount</a> (void) const </td></tr>
<tr class="memdesc:ad725f1858d6305af6721e575bb312674"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of <a class="el" href="class_autowired.html" title="Autowires a &quot;slot&quot; in a context to which an instance of the specified type will be wired when it beco...">Autowired</a> members in this context. <br /></td></tr>
<tr class="separator:ad725f1858d6305af6721e575bb312674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3783fd45517f23b6f070e0b06e916440"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3783fd45517f23b6f070e0b06e916440"></a>
const std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a3783fd45517f23b6f070e0b06e916440">GetParentContext</a> (void) const </td></tr>
<tr class="memdesc:a3783fd45517f23b6f070e0b06e916440"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shared reference to the parent context of this context. <br /></td></tr>
<tr class="separator:a3783fd45517f23b6f070e0b06e916440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a15fed7006535074ba0cad22734300"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_core_runnable.html">CoreRunnable</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a93a15fed7006535074ba0cad22734300">GetRunnables</a> (void) const </td></tr>
<tr class="memdesc:a93a15fed7006535074ba0cad22734300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the list of runnables  <a href="#a93a15fed7006535074ba0cad22734300">More...</a><br /></td></tr>
<tr class="separator:a93a15fed7006535074ba0cad22734300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000005b5f276de444327cab8ccc2a785"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a000005b5f276de444327cab8ccc2a785"></a>
const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a000005b5f276de444327cab8ccc2a785">GetSigilType</a> (void) const </td></tr>
<tr class="memdesc:a000005b5f276de444327cab8ccc2a785"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used as a sigil when creating this class, if any. <br /></td></tr>
<tr class="separator:a000005b5f276de444327cab8ccc2a785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7646ea17e7eb961c2193485926af7965"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classautowiring_1_1_thread_pool.html">autowiring::ThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a7646ea17e7eb961c2193485926af7965">GetThreadPool</a> (void) const </td></tr>
<tr class="memdesc:a7646ea17e7eb961c2193485926af7965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current thread pool  <a href="#a7646ea17e7eb961c2193485926af7965">More...</a><br /></td></tr>
<tr class="separator:a7646ea17e7eb961c2193485926af7965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff72e44be09394686d51a367a6ff9e23"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aff72e44be09394686d51a367a6ff9e23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#aff72e44be09394686d51a367a6ff9e23">Has</a> (void) const </td></tr>
<tr class="memdesc:aff72e44be09394686d51a367a6ff9e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">True, if an instance of the specified type exists and dependencies of that type can be autowired in this context.  <a href="#aff72e44be09394686d51a367a6ff9e23">More...</a><br /></td></tr>
<tr class="separator:aff72e44be09394686d51a367a6ff9e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4c58c375caaeb70d20807cd4029657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#aec4c58c375caaeb70d20807cd4029657">Initiate</a> (void)</td></tr>
<tr class="memdesc:aec4c58c375caaeb70d20807cd4029657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts all registered threads and enables events and the flow of filter graph packets.  <a href="#aec4c58c375caaeb70d20807cd4029657">More...</a><br /></td></tr>
<tr class="separator:aec4c58c375caaeb70d20807cd4029657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005f71baab03719918429b7ecdd8a9ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a005f71baab03719918429b7ecdd8a9ba"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a005f71baab03719918429b7ecdd8a9ba">Inject</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a005f71baab03719918429b7ecdd8a9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects the specified types into this context.  <a href="#a005f71baab03719918429b7ecdd8a9ba">More...</a><br /></td></tr>
<tr class="separator:a005f71baab03719918429b7ecdd8a9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe1f8ada791176b9c4893963b74aee1"><td class="memTemplParams" colspan="2">template&lt;typename MemFn &gt; </td></tr>
<tr class="memitem:a1fe1f8ada791176b9c4893963b74aee1"><td class="memTemplItemLeft" align="right" valign="top">InvokeRelay&lt; MemFn &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a1fe1f8ada791176b9c4893963b74aee1">Invoke</a> (MemFn memFn)</td></tr>
<tr class="memdesc:a1fe1f8ada791176b9c4893963b74aee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fires an event in another context.  <a href="#a1fe1f8ada791176b9c4893963b74aee1">More...</a><br /></td></tr>
<tr class="separator:a1fe1f8ada791176b9c4893963b74aee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefaae7d459f3ee07dce5b65c731e7900"><td class="memTemplParams" colspan="2"><a class="anchor" id="aefaae7d459f3ee07dce5b65c731e7900"></a>
template&lt;class Sigil &gt; </td></tr>
<tr class="memitem:aefaae7d459f3ee07dce5b65c731e7900"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#aefaae7d459f3ee07dce5b65c731e7900">Is</a> (void) const </td></tr>
<tr class="memdesc:aefaae7d459f3ee07dce5b65c731e7900"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the sigil type of this <a class="el" href="class_core_context.html" title="A top-level container class representing an autowiring domain, a minimum broadcast domain...">CoreContext</a> matches the specified sigil type. <br /></td></tr>
<tr class="separator:aefaae7d459f3ee07dce5b65c731e7900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ab31f4f5f30284304bca63390f9545"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a46ab31f4f5f30284304bca63390f9545">IsAncestorOf</a> (const <a class="el" href="class_core_context.html">CoreContext</a> *child) const </td></tr>
<tr class="memdesc:a46ab31f4f5f30284304bca63390f9545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the specified context is an ancestor of this context.  <a href="#a46ab31f4f5f30284304bca63390f9545">More...</a><br /></td></tr>
<tr class="separator:a46ab31f4f5f30284304bca63390f9545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2eb27daa6e017c3b678868faf0f7b14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2eb27daa6e017c3b678868faf0f7b14"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ae2eb27daa6e017c3b678868faf0f7b14">IsGlobalContext</a> (void) const </td></tr>
<tr class="memdesc:ae2eb27daa6e017c3b678868faf0f7b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if and only if this is the global context. <br /></td></tr>
<tr class="separator:ae2eb27daa6e017c3b678868faf0f7b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d4381dc7affb5ee90f14063b757e4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a17d4381dc7affb5ee90f14063b757e4a">IsInitiated</a> (void) const </td></tr>
<tr class="memdesc:a17d4381dc7affb5ee90f14063b757e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True, if the context has been initiated.  <a href="#a17d4381dc7affb5ee90f14063b757e4a">More...</a><br /></td></tr>
<tr class="separator:a17d4381dc7affb5ee90f14063b757e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9830b4f21a5195e8b93bfde236033a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ad9830b4f21a5195e8b93bfde236033a2">IsQuiescent</a> (void) const </td></tr>
<tr class="memdesc:ad9830b4f21a5195e8b93bfde236033a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the system's current quiescence status  <a href="#ad9830b4f21a5195e8b93bfde236033a2">More...</a><br /></td></tr>
<tr class="separator:ad9830b4f21a5195e8b93bfde236033a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e98de82b665c7d3791b317f7789fa3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a47e98de82b665c7d3791b317f7789fa3">IsRunning</a> (void) const </td></tr>
<tr class="memdesc:a47e98de82b665c7d3791b317f7789fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">True, if the context is presently running.  <a href="#a47e98de82b665c7d3791b317f7789fa3">More...</a><br /></td></tr>
<tr class="separator:a47e98de82b665c7d3791b317f7789fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b08c5f0dead4908659cf87c6eb77abb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a6b08c5f0dead4908659cf87c6eb77abb">IsShutdown</a> (void) const </td></tr>
<tr class="separator:a6b08c5f0dead4908659cf87c6eb77abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad571b7a096111d87c37e826546f875ea"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ad571b7a096111d87c37e826546f875ea">NextSibling</a> (void) const </td></tr>
<tr class="memdesc:ad571b7a096111d87c37e826546f875ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next context sharing the same parent, or null if this is the last entry in the list  <a href="#ad571b7a096111d87c37e826546f875ea">More...</a><br /></td></tr>
<tr class="separator:ad571b7a096111d87c37e826546f875ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2073501aa492a30cb8738a14eee9302e"><td class="memTemplParams" colspan="2">template&lt;class T , class Fn &gt; </td></tr>
<tr class="memitem:a2073501aa492a30cb8738a14eee9302e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a2073501aa492a30cb8738a14eee9302e">NotifyWhenAutowired</a> (Fn &amp;&amp;listener)</td></tr>
<tr class="memdesc:a2073501aa492a30cb8738a14eee9302e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a post-attachment listener in this context for a particular autowired member. There is no guarantee for the context in which the listener will be called.  <a href="#a2073501aa492a30cb8738a14eee9302e">More...</a><br /></td></tr>
<tr class="separator:a2073501aa492a30cb8738a14eee9302e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4ff8b34b0d1a6159abff8f7b96599e"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a9d4ff8b34b0d1a6159abff8f7b96599e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a9d4ff8b34b0d1a6159abff8f7b96599e">operator+=</a> (Fx &amp;&amp;fx)</td></tr>
<tr class="memdesc:a9d4ff8b34b0d1a6159abff8f7b96599e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits the specified lambda to this context's ThreadPool for processing  <a href="#a9d4ff8b34b0d1a6159abff8f7b96599e">More...</a><br /></td></tr>
<tr class="separator:a9d4ff8b34b0d1a6159abff8f7b96599e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13acb0db1c7703d05721b49df414bd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#aa13acb0db1c7703d05721b49df414bd3">Quiescent</a> (void) const </td></tr>
<tr class="memdesc:aa13acb0db1c7703d05721b49df414bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to Wait, except blocks only until the threads in this and all descendant contexts have stopped  <a href="#aa13acb0db1c7703d05721b49df414bd3">More...</a><br /></td></tr>
<tr class="separator:aa13acb0db1c7703d05721b49df414bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aad9deb56c4d7ad73984ed35ea9d65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a04aad9deb56c4d7ad73984ed35ea9d65">Quiescent</a> (std::chrono::nanoseconds duration) const </td></tr>
<tr class="memdesc:a04aad9deb56c4d7ad73984ed35ea9d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed version of Quiescent  <a href="#a04aad9deb56c4d7ad73984ed35ea9d65">More...</a><br /></td></tr>
<tr class="separator:a04aad9deb56c4d7ad73984ed35ea9d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc0d1a9db98765d26bb89cab5bb4f90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a9dc0d1a9db98765d26bb89cab5bb4f90">RemoveSnooper</a> (const CoreObjectDescriptor &amp;traits)</td></tr>
<tr class="memdesc:a9dc0d1a9db98765d26bb89cab5bb4f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime version of RemoveSnooper  <a href="#a9dc0d1a9db98765d26bb89cab5bb4f90">More...</a><br /></td></tr>
<tr class="separator:a9dc0d1a9db98765d26bb89cab5bb4f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7dd841f71c271a2f61b0a698011f29"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1a7dd841f71c271a2f61b0a698011f29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a1a7dd841f71c271a2f61b0a698011f29">RemoveSnooper</a> (const std::shared_ptr&lt; T &gt; &amp;pSnooper)</td></tr>
<tr class="memdesc:a1a7dd841f71c271a2f61b0a698011f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a snooper previously registered to receive snooped events  <a href="#a1a7dd841f71c271a2f61b0a698011f29">More...</a><br /></td></tr>
<tr class="separator:a1a7dd841f71c271a2f61b0a698011f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc0620a27181c14654da12561c1cead"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9dc0620a27181c14654da12561c1cead"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a9dc0620a27181c14654da12561c1cead">RemoveSnooper</a> (const <a class="el" href="class_autowired.html">Autowired</a>&lt; T &gt; &amp;snooper)</td></tr>
<tr class="memdesc:a9dc0620a27181c14654da12561c1cead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolution overload of RemoveSnooper  <a href="#a9dc0620a27181c14654da12561c1cead">More...</a><br /></td></tr>
<tr class="separator:a9dc0620a27181c14654da12561c1cead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad306c1c3703311ba1fe7fdb4add279f9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ad306c1c3703311ba1fe7fdb4add279f9">SetCurrent</a> (void)</td></tr>
<tr class="memdesc:ad306c1c3703311ba1fe7fdb4add279f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this context the current context.  <a href="#ad306c1c3703311ba1fe7fdb4add279f9">More...</a><br /></td></tr>
<tr class="separator:ad306c1c3703311ba1fe7fdb4add279f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eff2c50f12c4de4e9e82a49a4bb2bc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a2eff2c50f12c4de4e9e82a49a4bb2bc7">SetThreadPool</a> (const std::shared_ptr&lt; <a class="el" href="classautowiring_1_1_thread_pool.html">autowiring::ThreadPool</a> &gt; &amp;threadPool)</td></tr>
<tr class="memdesc:a2eff2c50f12c4de4e9e82a49a4bb2bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the thread pool handler for this context  <a href="#a2eff2c50f12c4de4e9e82a49a4bb2bc7">More...</a><br /></td></tr>
<tr class="separator:a2eff2c50f12c4de4e9e82a49a4bb2bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15918e5e6962e2865b6da51e557f35c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a15918e5e6962e2865b6da51e557f35c8">SetUnlinkOnTeardown</a> (bool unlinkOnTeardown)</td></tr>
<tr class="memdesc:a15918e5e6962e2865b6da51e557f35c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the context's teardown unlink behavior  <a href="#a15918e5e6962e2865b6da51e557f35c8">More...</a><br /></td></tr>
<tr class="separator:a15918e5e6962e2865b6da51e557f35c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0ff07669244590fcdcec9aeb588aa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a8e0ff07669244590fcdcec9aeb588aa5">SignalShutdown</a> (bool wait=false, <a class="el" href="_core_context_8h.html#aa042d52710c2112736f295f5adab0de5">ShutdownMode</a> shutdownMode=<a class="el" href="_core_context_8h.html#aa042d52710c2112736f295f5adab0de5a33246d22483d4dbb20f20f098e24a684">ShutdownMode::Graceful</a>)</td></tr>
<tr class="memdesc:a8e0ff07669244590fcdcec9aeb588aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins shutdown of this context, optionally waiting for child contexts and threads to also shut down before returning.  <a href="#a8e0ff07669244590fcdcec9aeb588aa5">More...</a><br /></td></tr>
<tr class="separator:a8e0ff07669244590fcdcec9aeb588aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107256cd9f29a43301afca98cd7309a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a107256cd9f29a43301afca98cd7309a5">SignalTerminate</a> (bool wait=true)</td></tr>
<tr class="memdesc:a107256cd9f29a43301afca98cd7309a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down the context with the Immediate shutdown mode.  <a href="#a107256cd9f29a43301afca98cd7309a5">More...</a><br /></td></tr>
<tr class="separator:a107256cd9f29a43301afca98cd7309a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846274ca88865c63655b5eeb054d12b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a846274ca88865c63655b5eeb054d12b9">Wait</a> (void)</td></tr>
<tr class="memdesc:a846274ca88865c63655b5eeb054d12b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the context begins shutting down (IsShutdown is true) and all threads and child threads have terminated.  <a href="#a846274ca88865c63655b5eeb054d12b9">More...</a><br /></td></tr>
<tr class="separator:a846274ca88865c63655b5eeb054d12b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6708295354459d99f39f4f4a2899211d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a6708295354459d99f39f4f4a2899211d">Wait</a> (const std::chrono::nanoseconds duration)</td></tr>
<tr class="memdesc:a6708295354459d99f39f4f4a2899211d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the specified number of nanoseconds.  <a href="#a6708295354459d99f39f4f4a2899211d">More...</a><br /></td></tr>
<tr class="separator:a6708295354459d99f39f4f4a2899211d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12f8a7181248f040bde3fd4cdcd799e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#ad12f8a7181248f040bde3fd4cdcd799e">WasStarted</a> (void) const </td></tr>
<tr class="memdesc:ad12f8a7181248f040bde3fd4cdcd799e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of the IsInitiated method  <a href="#ad12f8a7181248f040bde3fd4cdcd799e">More...</a><br /></td></tr>
<tr class="separator:ad12f8a7181248f040bde3fd4cdcd799e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3f8e26f6c2f8e94bdff0f2e2870b6836"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a3f8e26f6c2f8e94bdff0f2e2870b6836">CurrentContext</a> (void)</td></tr>
<tr class="memdesc:a3f8e26f6c2f8e94bdff0f2e2870b6836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to CurrentContextNoCheck, except returns the global context instead of a null pointer  <a href="#a3f8e26f6c2f8e94bdff0f2e2870b6836">More...</a><br /></td></tr>
<tr class="separator:a3f8e26f6c2f8e94bdff0f2e2870b6836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf36b5e9c6bda2f2e2b6058b34d99e87"><td class="memItemLeft" align="right" valign="top">static const std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#abf36b5e9c6bda2f2e2b6058b34d99e87">CurrentContextOrNull</a> (void)</td></tr>
<tr class="memdesc:abf36b5e9c6bda2f2e2b6058b34d99e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">The shared pointer to the current context.  <a href="#abf36b5e9c6bda2f2e2b6058b34d99e87">More...</a><br /></td></tr>
<tr class="separator:abf36b5e9c6bda2f2e2b6058b34d99e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1878fadff510297d81f6beb32b38ef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#aac1878fadff510297d81f6beb32b38ef">EvictCurrent</a> (void)</td></tr>
<tr class="memdesc:aac1878fadff510297d81f6beb32b38ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes no context current.  <a href="#aac1878fadff510297d81f6beb32b38ef">More...</a><br /></td></tr>
<tr class="separator:aac1878fadff510297d81f6beb32b38ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143f68a029dbd4eb6bf628c7ea6e9d31"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a143f68a029dbd4eb6bf628c7ea6e9d31">GetGlobal</a> (void)</td></tr>
<tr class="memdesc:a143f68a029dbd4eb6bf628c7ea6e9d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared reference to the global context.  <a href="#a143f68a029dbd4eb6bf628c7ea6e9d31">More...</a><br /></td></tr>
<tr class="separator:a143f68a029dbd4eb6bf628c7ea6e9d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0716b1184e3fba32e64c06160d3153a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0716b1184e3fba32e64c06160d3153a3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a0716b1184e3fba32e64c06160d3153a3">InjectCurrent</a> (void)</td></tr>
<tr class="memdesc:a0716b1184e3fba32e64c06160d3153a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects a type into the current context.  <a href="#a0716b1184e3fba32e64c06160d3153a3">More...</a><br /></td></tr>
<tr class="separator:a0716b1184e3fba32e64c06160d3153a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2aca013ec6ca56def339ccc2a950e7"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a4b2aca013ec6ca56def339ccc2a950e7">SetCurrent</a> (const std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; &amp;ctxt)</td></tr>
<tr class="memdesc:a4b2aca013ec6ca56def339ccc2a950e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of SetCurrent, may be invoked with nullptr  <a href="#a4b2aca013ec6ca56def339ccc2a950e7">More...</a><br /></td></tr>
<tr class="separator:a4b2aca013ec6ca56def339ccc2a950e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40740a5c98a9cf2919b83bde3b9adbfb"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_context.html#a40740a5c98a9cf2919b83bde3b9adbfb">SetCurrent</a> (std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; &amp;&amp;ctxt)</td></tr>
<tr class="memdesc:a40740a5c98a9cf2919b83bde3b9adbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-optimized version of SetCurrent  <a href="#a40740a5c98a9cf2919b83bde3b9adbfb">More...</a><br /></td></tr>
<tr class="separator:a40740a5c98a9cf2919b83bde3b9adbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a543d73b7ea7d1a457eb61dc73758a797"><td class="memTemplParams" colspan="2">template&lt;class Fn &gt; </td></tr>
<tr class="memitem:a543d73b7ea7d1a457eb61dc73758a797"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_core_context.html#a543d73b7ea7d1a457eb61dc73758a797">RegisterFactoryFn</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:a543d73b7ea7d1a457eb61dc73758a797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a factory <em>function</em>, a lambda which is capable of constructing decltype(fn())  <a href="#a543d73b7ea7d1a457eb61dc73758a797">More...</a><br /></td></tr>
<tr class="separator:a543d73b7ea7d1a457eb61dc73758a797"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A top-level container class representing an autowiring domain, a minimum broadcast domain, and a thread execution domain. </p>
<p>A context is the basic unit of organization within an autowired application. The scope of a context determines:</p><ul>
<li>How <a class="el" href="class_autowired.html" title="Autowires a &quot;slot&quot; in a context to which an instance of the specified type will be wired when it beco...">Autowired</a> dependencies are resolved</li>
<li>Who receives <a class="el" href="class_auto_fired.html" title="Injects an object that can fire events. ">AutoFired</a> events</li>
<li>Thread ownership (<a class="el" href="class_basic_thread.html" title="An abstract class for creating a thread with a single Run method. ">BasicThread</a>, <a class="el" href="class_core_thread.html" title="Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the ...">CoreThread</a>)</li>
<li><a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> filter graph scope</li>
</ul>
<p>Dependencies can be injected into a context using <a class="el" href="class_autowired.html" title="Autowires a &quot;slot&quot; in a context to which an instance of the specified type will be wired when it beco...">Autowired</a> or <a class="el" href="class_auto_required.html" title="Autowires the specified dependency, creating a new instance if one does not already exist...">AutoRequired</a>. The system looks in the current context for an existing object of the required type to satisfy the dependency. If one does not exist, it looks in parent contexts. When using <a class="el" href="class_auto_required.html" title="Autowires the specified dependency, creating a new instance if one does not already exist...">AutoRequired</a>, a new instance of the required type is created if no existing object is found. Otherwise, the dependoncy is satisfied when another object of the same type (or subtype) is added to the context (or one of its parents). This resolution system carries the restriction that only one instance of an <a class="el" href="class_autowired.html" title="Autowires a &quot;slot&quot; in a context to which an instance of the specified type will be wired when it beco...">Autowired</a> type can exist in the same branch of the context tree.</p>
<p>In addition, an <a class="el" href="class_autowired.html" title="Autowires a &quot;slot&quot; in a context to which an instance of the specified type will be wired when it beco...">Autowired</a> member of a context exists for as long as that context. exists.</p>
<p><a class="el" href="class_autowired.html" title="Autowires a &quot;slot&quot; in a context to which an instance of the specified type will be wired when it beco...">Autowired</a> dependencies do not need to meet any special requirements such as inheriting from a particular Autowiring type or implementing a particular interface. However, if a type contains <a class="el" href="class_autowired.html" title="Autowires a &quot;slot&quot; in a context to which an instance of the specified type will be wired when it beco...">Autowired</a> members, instances of that type must be <a class="el" href="class_autowired.html" title="Autowires a &quot;slot&quot; in a context to which an instance of the specified type will be wired when it beco...">Autowired</a> to a context in order for the dependencies of their members to be satisfied.</p>
<p>Contexts can be created with <a class="el" href="_autowired_8h.html#aa65e92d94fffb9dcc42b0ff6de09f4cb" title="Creates a new context as a child of the current context. ">AutoCreateContext</a> and <a class="el" href="class_auto_create_context_t.html" title="Provides a simple way to create a child of the current context using a sigil. ">AutoCreateContextT</a>. The global context is created automatically; get a reference to it using <a class="el" href="class_auto_global_context.html" title="Provides a reference to the global context. ">AutoGlobalContext</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="class_auto_global_context.html">AutoGlobalContext</a> global;</div>
<div class="line"><a class="code" href="class_auto_create_context_t.html">AutoCreateContext</a> childContext;</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>Foo{}; <span class="comment">//dummy class</span></div>
<div class="line"><a class="code" href="class_auto_create_context_t.html">AutoCreateContextT&lt;Foo&gt;</a> childContextWithSigil;</div>
</div><!-- fragment --><p>Contexts can be enumerated using the <a class="el" href="class_context_enumerator.html" title="A virtual container which may be used to enumerate all children of a particular context ...">ContextEnumerator</a> class. You can restrict enumeration to those contexts marked with a given sigil with ContextEnumeratorT&lt;Sigil&gt;. You can also enumerate the current context with <a class="el" href="class_current_context_enumerator.html" title="CurrentContextEnumerator. ">CurrentContextEnumerator</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="class_auto_global_context.html">AutoGlobalContext</a> global;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> context : <a class="code" href="class_context_enumerator.html">ContextEnumerator</a>(global)){</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Enumerating &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code" href="namespaceautowiring.html#aef8c65202e0d57213ea8335013bc634a">autowiring::demangle</a>(&amp;context-&gt;GetSigilType())</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; within global context.&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> context : <a class="code" href="class_context_enumerator_t.html">ContextEnumeratorT&lt;Foo&gt;</a>(childContext)){</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Enumerating &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code" href="namespaceautowiring.html#aef8c65202e0d57213ea8335013bc634a">autowiring::demangle</a>(&amp;context-&gt;GetSigilType())</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; within childContext.&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> context : <a class="code" href="class_current_context_enumerator.html">CurrentContextEnumerator</a>()){</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Enumerating &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code" href="namespaceautowiring.html#aef8c65202e0d57213ea8335013bc634a">autowiring::demangle</a>(&amp;context-&gt;GetSigilType())</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; in current context.&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="class_autowired.html" title="Autowires a &quot;slot&quot; in a context to which an instance of the specified type will be wired when it beco...">Autowired</a> members of a context can pass information using <a class="el" href="class_auto_fired.html" title="Injects an object that can fire events. ">AutoFired</a> events, as well as with a filter graph. You can also pass data from one context to another in the same way. A context can also snoop on another context's events and filter graph packets to receive data it wouldn't otherwise have access to. Use <a class="el" href="class_bolt.html">Bolt</a> objects to receive notification when a context of a particular sigil type is created. This allows you to set up snooping whenever a particular type of context is created.</p>
<p>Events, threads, and filter graphs require that the context's <a class="el" href="class_core_context.html#aec4c58c375caaeb70d20807cd4029657" title="Starts all registered threads and enables events and the flow of filter graph packets. ">Initiate()</a> function is called. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a274e47cff1ae841fe66e03a186d8eede"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Add </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Introduces the specified pointer to this context explicitly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The interface to make available in this context</td></tr>
  </table>
  </dd>
</dl>
<p>Add is similar in behavior to Inject, except that the passed pointer is not treated as a concrete type. This means that other interfaces implemented by ptr will not be available for autowiring unless explicitly made discoverable by another call to Add.</p>
<p>It is an error to add a type which is already autowirable in a context. </p>

</div>
</div>
<a class="anchor" id="a7e0312724984a15bffd56019af5a2737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::AddSnooper </td>
          <td>(</td>
          <td class="paramtype">const CoreObjectDescriptor &amp;&#160;</td>
          <td class="paramname"><em>traits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime version of AddSnooper </p>

<p>Referenced by <a class="el" href="class_core_context.html#a670aaca238bf0f7db59bcdb71f84ccd0">AddSnooper()</a>.</p>

</div>
</div>
<a class="anchor" id="a670aaca238bf0f7db59bcdb71f84ccd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::AddSnooper </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pSnooper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the specified event receiver to receive messages from this context </p>
<p>This enables the passed event receiver to snoop events that are broadcast from a parent context. The passed event receiver MUST exist in a parent context, or the behavior of this method may be undefined during teardown.</p>
<p>The snooper will not receive any events broadcast from parent contexts. ONLY events broadcast in THIS context will be forwarded to the snooper. </p>

</div>
</div>
<a class="anchor" id="a01a34fcd446e51c5c006d9f3d46b4cc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::AddSnooper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_autowired.html">Autowired</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>snooper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolution overload </p>

</div>
</div>
<a class="anchor" id="ad7a9b70597e2ce15604bd823758408c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JunctionBoxBase&amp; CoreContext::All </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime variant of All </p>
<p>This instance does not cause a correct instantiation of the underlying junction box. Users are cautioned against using this method directly unless they are able to ensure a proper entry is made into the type registry.</p>
<p>It is an error to call this method on an unregistered type. </p>

</div>
</div>
<a class="anchor" id="aae5c351a08cc681adb51e7eb21ec6303"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JunctionBox&lt;T&gt;&amp; CoreContext::All </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all members of and snoopers on this context which implement the specified interface </p>
<p>This method makes use of the JunctionBox subsystem, and thus is extremely efficient. The underlying system is memoized, and new entries automatically update any existing memos, which gives this routine O(n) efficiency, where n is the number of types in this context that implement the specified interface.</p>
<p>Note that the junction box will also contain members of child contexts that implement the specified interface, and instances that are snooping this context.</p>
<p>This method's result will be an empty iterable if the context is not currently initiated. </p>

</div>
</div>
<a class="anchor" id="a81cde2e3e4031ac1bc1c9e761f8eff11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Sigils&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::BoltTo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Injects the specified type T into all subcontexts created with one of the matching sigil types. </p>

</div>
</div>
<a class="anchor" id="a248d2983aeb495dfa013024d10fbfc16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="class_basic_thread.html">BasicThread</a>&gt; &gt; CoreContext::CopyBasicThreadList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A copy of the current list of child CoreRunnables of this context. </p>
<p>No guarantee is made about how long the returned collection will be consistent within this context. A thread may potentially be added to the context after the method returns. </p>

</div>
</div>
<a class="anchor" id="a6edf5743ee22ca42a0ca3d8cff226fca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_core_context_t.html">CoreContextT</a>&lt;T&gt; &gt; CoreContext::Create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a child context of this context. </p>
<p>Using using <a class="el" href="_autowired_8h.html#aa65e92d94fffb9dcc42b0ff6de09f4cb" title="Creates a new context as a child of the current context. ">AutoCreateContext</a> or <a class="el" href="class_auto_create_context_t.html" title="Provides a simple way to create a child of the current context using a sigil. ">AutoCreateContextT</a> is the prefered way to create children of the current context.</p>
<div class="fragment"><div class="line"><a class="code" href="class_auto_create_context_t.html">AutoCreateContext</a> myContext;</div>
<div class="line"><a class="code" href="class_auto_create_context_t.html">AutoCreateContextT&lt;MySigil&gt;</a> myMarkedContext;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3f8e26f6c2f8e94bdff0f2e2870b6836"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="class_core_context.html">CoreContext</a>&gt; CoreContext::CurrentContext </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identical to CurrentContextNoCheck, except returns the global context instead of a null pointer </p>

<p>Referenced by <a class="el" href="class_core_context.html#a0716b1184e3fba32e64c06160d3153a3">InjectCurrent()</a>.</p>

</div>
</div>
<a class="anchor" id="abf36b5e9c6bda2f2e2b6058b34d99e87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::shared_ptr&lt;<a class="el" href="class_core_context.html">CoreContext</a>&gt;&amp; CoreContext::CurrentContextOrNull </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The shared pointer to the current context. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the current <a class="el" href="class_core_context.html" title="A top-level container class representing an autowiring domain, a minimum broadcast domain...">CoreContext</a> instance of the current thread, or else nullptr, if no context is current. </dd></dl>
<p>This works by using thread-local store, and so is safe in multithreaded systems. The current context is assigned before invoking a <a class="el" href="class_core_runnable.html" title="Provides the interface for threads that should receive start and stop notifications in a context ...">CoreRunnable</a> instance's Run method, and it's also assigned when a context is first constructed by a thread. </p>

</div>
</div>
<a class="anchor" id="abafba926a5bb2aa13f15c4de0d0df019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::DelayUntilInitiated </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until the context is initiated or, if never initiated, until it starts shutting down. </p>
<dl class="section return"><dt>Returns</dt><dd>True if initiated, false if shutting down.</dd></dl>

</div>
</div>
<a class="anchor" id="a1a9cb8e948aee0f4c90e0ec8f89d99cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">AddTeardownListener(Fx &amp;&amp;fx)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Superceded by onTeardown&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a teardown notifier which receives a pointer to this context on destruction </p>

</div>
</div>
<a class="anchor" id="a8bc3598a2c82c5452ec5b942ec84ceed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility debug method for writing a snapshot of this context to the specified output stream </p>

</div>
</div>
<a class="anchor" id="a86ef42fac99a89891c9cff760bd46ee8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows a specifically named class to be "bolted" to this context or one of its subcontexts. </p>
<p>Call Enable&lt;T&gt; before calling BoltTo&lt;T&gt;. If the specified type does not inherit from <a class="el" href="class_bolt.html">Bolt</a>, this method has no effect. </p>

</div>
</div>
<a class="anchor" id="aac1878fadff510297d81f6beb32b38ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CoreContext::EvictCurrent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes no context current. </p>
<p>Generally speaking, if you just want to release a reference to the current context, simply make the global context current instead.</p>
<p>This method is identical to CoreContext::SetCurrent(nullptr) </p>

</div>
</div>
<a class="anchor" id="a5b5b71f520358864f1cf52eb108aceb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::FilterException </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters std::current_exception using any registered exception filters, or rethrows. </p>
<p>The passed exception is assumed to be a generic exception whose default behavior shall be to tear down the context. It will be the caller's responsibility to ensure that this behavior is observed.</p>
<p>If the exception is successfully handled by a filter, this method returns cleanly. Otherwise, this method is equivalent to std::rethrow_exception. </p>

</div>
</div>
<a class="anchor" id="a14de7efacd23075c69ea134a7a45f4a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::FilterFiringException </td>
          <td>(</td>
          <td class="paramtype">const JunctionBoxBase *&#160;</td>
          <td class="paramname"><em>pProxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoreObject *&#160;</td>
          <td class="paramname"><em>pRecipient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a std::current_exception thrown by an EventSenderBase during a Fire </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pProxy</td><td>The sender of the event</td></tr>
    <tr><td class="paramname">pRecipient</td><td>The recipient of the event</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac5cef7deb0bf47f0c6d51ee015f6750"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_core_context.html">CoreContext</a>&gt; CoreContext::FirstChild </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first child in the set of this context's children. </p>

</div>
</div>
<a class="anchor" id="af5eee91bb723177b240ba727f41b5733"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto_id CoreContext::GetAutoTypeId </td>
          <td>(</td>
          <td class="paramtype">const AnySharedPointer &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the type information for the instance referenced by the specified shared pointer. </p>
<p>The returned type structure will be the actual type of the specified object as defined at the time of injection. In the case of a static factory new or AutoFactory new, this type will be the type of the interface. All other members are the concrete type actually injected, as opposed to the type unifier for that type.</p>
<p>This method will throw an exception if the passed shared pointer is not strictly a member of this context. </p>
<dl class="section return"><dt>Returns</dt><dd>The type identifier of the referenced instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a143f68a029dbd4eb6bf628c7ea6e9d31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="class_core_context.html">CoreContext</a>&gt; CoreContext::GetGlobal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a shared reference to the global context. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_auto_global_context.html" title="Provides a reference to the global context. ">AutoGlobalContext</a>, <a class="el" href="class_global_core_context.html" title="A special class designed to make it easier to detect when our context is the global context...">GlobalCoreContext</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a93a15fed7006535074ba0cad22734300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_core_runnable.html">CoreRunnable</a>*&gt; CoreContext::GetRunnables </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the list of runnables </p>
<p>This list is intended primarily for diagnostic purposes. The pointers are dumb pointers, and may be invalidated if the caller is not careful to hold a shared pointer to the context. </p>

</div>
</div>
<a class="anchor" id="a7646ea17e7eb961c2193485926af7965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classautowiring_1_1_thread_pool.html">autowiring::ThreadPool</a>&gt; CoreContext::GetThreadPool </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current thread pool </p>
<p>If the context has been shut down, (IE, IsShutdown returns true), this method returns nullptr. Calling ThreadPool::Start on the returned shared pointer will not cause dispatchers pended to this context to be executed. To do this, invoke <a class="el" href="class_core_context.html#aec4c58c375caaeb70d20807cd4029657" title="Starts all registered threads and enables events and the flow of filter graph packets. ">CoreContext::Initiate</a> </p>

<p>Referenced by <a class="el" href="class_core_context.html#a9d4ff8b34b0d1a6159abff8f7b96599e">operator+=()</a>.</p>

</div>
</div>
<a class="anchor" id="aff72e44be09394686d51a367a6ff9e23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::Has </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True, if an instance of the specified type exists and dependencies of that type can be autowired in this context. </p>

</div>
</div>
<a class="anchor" id="aec4c58c375caaeb70d20807cd4029657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Initiate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts all registered threads and enables events and the flow of filter graph packets. </p>

</div>
</div>
<a class="anchor" id="a005f71baab03719918429b7ecdd8a9ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; CoreContext::Inject </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Injects the specified types into this context. </p>
<p>Arguments will be passed to the T constructor, if provided. </p>

</div>
</div>
<a class="anchor" id="a0716b1184e3fba32e64c06160d3153a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CoreContext::InjectCurrent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Injects a type into the current context. </p>

</div>
</div>
<a class="anchor" id="a1fe1f8ada791176b9c4893963b74aee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InvokeRelay&lt;MemFn&gt; CoreContext::Invoke </td>
          <td>(</td>
          <td class="paramtype">MemFn&#160;</td>
          <td class="paramname"><em>memFn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fires an event in another context. </p>
<p>Invoke allows you to fire an event in another context without first making that context current.</p>
<p>The following statment:</p>
<div class="fragment"><div class="line">ctxt-&gt;Invoke(&amp;MyEventType::MyEvent)();</div>
</div><!-- fragment --><p>is equivalent to:</p>
<div class="fragment"><div class="line"><a class="code" href="class_current_context_pusher.html">CurrentContextPusher</a>(ctxt);</div>
<div class="line">(<a class="code" href="class_auto_fired.html">AutoFired&lt;MyEventType&gt;</a>())(&amp;MyEventType::MyEvent)();</div>
<div class="line">ctxt-&gt;Pop();</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a46ab31f4f5f30284304bca63390f9545"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::IsAncestorOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_core_context.html">CoreContext</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports whether the specified context is an ancestor of this context. </p>
<p>This method will also return true if this == child. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this context is an ancestor of the specified context. </dd></dl>

</div>
</div>
<a class="anchor" id="a17d4381dc7affb5ee90f14063b757e4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::IsInitiated </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True, if the context has been initiated. </p>
<p>This method will return true even if the context is currently shut down. Once the context is shut down, the return value of this method is guaranteed to not change. </p>

<p>Referenced by <a class="el" href="class_core_context.html#ad12f8a7181248f040bde3fd4cdcd799e">WasStarted()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9830b4f21a5195e8b93bfde236033a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::IsQuiescent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the system's current quiescence status </p>

</div>
</div>
<a class="anchor" id="a47e98de82b665c7d3791b317f7789fa3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::IsRunning </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True, if the context is presently running. </p>
<p>This method may return false even if IsInitiated returns true if the parent context has not yet been initiated. </p>

</div>
</div>
<a class="anchor" id="a6b08c5f0dead4908659cf87c6eb77abb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::IsShutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if <a class="el" href="class_core_runnable.html" title="Provides the interface for threads that should receive start and stop notifications in a context ...">CoreRunnable</a> instances in this context should begin teardown operations </dd></dl>

</div>
</div>
<a class="anchor" id="ad571b7a096111d87c37e826546f875ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_core_context.html">CoreContext</a>&gt; CoreContext::NextSibling </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The next context sharing the same parent, or null if this is the last entry in the list </p>

</div>
</div>
<a class="anchor" id="a2073501aa492a30cb8738a14eee9302e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::NotifyWhenAutowired </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a post-attachment listener in this context for a particular autowired member. There is no guarantee for the context in which the listener will be called. </p>
<p>This method will succeed if slot was constructed in this context or any parent context. If the passed slot was not created in this context or a parent context, an exception will be thrown.</p>
<p>It's possible that the passed slot will never be filled, and instead the corresponding instance destroyed without ever having been initialized.</p>
<p>If the passed slot is already autowired, then the listener will be invoked immediately from the body of this method. Care should be taken to avoid deadlocks in this case&ndash;either the caller must not be holding any locks when this method is invoked, or the caller should design the listener method such that it may be substitutde in place for the notification routine. </p>

</div>
</div>
<a class="anchor" id="a9d4ff8b34b0d1a6159abff8f7b96599e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::operator+= </td>
          <td>(</td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits the specified lambda to this context's ThreadPool for processing </p>
<dl class="section return"><dt>Returns</dt><dd>True if the job has been submitted for execution</dd></dl>
<p>The passed thunk will not be executed if the current context has already stopped. </p>

</div>
</div>
<a class="anchor" id="aa13acb0db1c7703d05721b49df414bd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Quiescent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to Wait, except blocks only until the threads in this and all descendant contexts have stopped </p>
<p>This method intrinsically may imply a race condition unless the caller is careful to ensure it retains total control over injection and subcontext creation events. In a single-threaded system, the currrent context and all child contexts are guaranteed to have no <a class="el" href="class_core_runnable.html" title="Provides the interface for threads that should receive start and stop notifications in a context ...">CoreRunnable</a> instances in a running state. </p>

</div>
</div>
<a class="anchor" id="a04aad9deb56c4d7ad73984ed35ea9d65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::Quiescent </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed version of Quiescent </p>

</div>
</div>
<a class="anchor" id="a543d73b7ea7d1a457eb61dc73758a797"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::RegisterFactoryFn </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a factory <em>function</em>, a lambda which is capable of constructing decltype(fn()) </p>

</div>
</div>
<a class="anchor" id="a9dc0d1a9db98765d26bb89cab5bb4f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::RemoveSnooper </td>
          <td>(</td>
          <td class="paramtype">const CoreObjectDescriptor &amp;&#160;</td>
          <td class="paramname"><em>traits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime version of RemoveSnooper </p>

</div>
</div>
<a class="anchor" id="a1a7dd841f71c271a2f61b0a698011f29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::RemoveSnooper </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pSnooper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters a snooper previously registered to receive snooped events </p>
<p>It is an error to call this method without a prior call to AddSnooper </p>

</div>
</div>
<a class="anchor" id="a9dc0620a27181c14654da12561c1cead"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::RemoveSnooper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_autowired.html">Autowired</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>snooper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolution overload of RemoveSnooper </p>

</div>
</div>
<a class="anchor" id="a4b2aca013ec6ca56def339ccc2a950e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="class_core_context.html">CoreContext</a>&gt; CoreContext::SetCurrent </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static version of SetCurrent, may be invoked with nullptr </p>

</div>
</div>
<a class="anchor" id="a40740a5c98a9cf2919b83bde3b9adbfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="class_core_context.html">CoreContext</a>&gt; CoreContext::SetCurrent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-optimized version of SetCurrent </p>

</div>
</div>
<a class="anchor" id="ad306c1c3703311ba1fe7fdb4add279f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_core_context.html">CoreContext</a>&gt; CoreContext::SetCurrent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes this context the current context. </p>
<dl class="section return"><dt>Returns</dt><dd>The previously current context, or else nullptr if no context was current.</dd></dl>

</div>
</div>
<a class="anchor" id="a2eff2c50f12c4de4e9e82a49a4bb2bc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::SetThreadPool </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classautowiring_1_1_thread_pool.html">autowiring::ThreadPool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>threadPool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the thread pool handler for this context </p>
<p>If the context is currently running, the thread pool will automatically be started. The pool's start token and shared pointer is reset automatically when the context is torn down. If the context has already been shut down (IE, IsShutdown returns true), this method has no effect.</p>
<p>Dispatchers that have been attached to the current thread pool will not be transitioned to the new pool. Changing the thread pool may cause the previously assigned thread pool to be stopped. This will cause it to complete all work assigned to it and release resources associated with processing. If there are no other handles to the pool, it may potentially destroy itself.</p>
<p>It is an error to pass nullptr to this method. </p>

</div>
</div>
<a class="anchor" id="a15918e5e6962e2865b6da51e557f35c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::SetUnlinkOnTeardown </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unlinkOnTeardown</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the context's teardown unlink behavior </p>
<p>If this feature is turned on, then during context destruction and after teardown listeners have been run, all context members will be scanned for uses of <a class="el" href="class_autowired.html" title="Autowires a &quot;slot&quot; in a context to which an instance of the specified type will be wired when it beco...">Autowired</a>. If a context member has such a field, and that field points to another member of the current context, then the field will be unlinked.</p>
<p>If a field is <a class="el" href="class_auto_required.html" title="Autowires the specified dependency, creating a new instance if one does not already exist...">AutoRequired</a>, it is skipped. If the autowiring was satisfied outside of the context (for instance, at global scope), it's also skipped. <a class="el" href="class_autowired_fast.html" title="Autowires a slot immediately (with limitations). ">AutowiredFast</a> uses aren't registered anywhere, so they are also skipped.</p>
<p>This method may be called at any time where a valid <a class="el" href="class_core_context.html" title="A top-level container class representing an autowiring domain, a minimum broadcast domain...">CoreContext</a> reference exists. <a class="el" href="class_core_context.html" title="A top-level container class representing an autowiring domain, a minimum broadcast domain...">CoreContext</a> does not track additional state if this flag is set. &lt;/reamrks&gt; </p>

</div>
</div>
<a class="anchor" id="a8e0ff07669244590fcdcec9aeb588aa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::SignalShutdown </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_core_context_8h.html#aa042d52710c2112736f295f5adab0de5">ShutdownMode</a>&#160;</td>
          <td class="paramname"><em>shutdownMode</em> = <code><a class="el" href="_core_context_8h.html#aa042d52710c2112736f295f5adab0de5a33246d22483d4dbb20f20f098e24a684">ShutdownMode::Graceful</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins shutdown of this context, optionally waiting for child contexts and threads to also shut down before returning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait</td><td>Specifies whether the function should wait for all child contexts to exit before returning</td></tr>
    <tr><td class="paramname">shutdownMode</td><td>Specifies whether <a class="el" href="class_core_thread.html" title="Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the ...">CoreThread</a> objects should run all pending jobs or should shutdown immediately.</td></tr>
  </table>
  </dd>
</dl>
<p>After this method is invoked, no new events can be dispatched within this context or any descendant context, whether those events are fired in this context or one above, and regardless of whether these events are fired or deferred. Event receivers in this context will also not receive any messages.</p>
<p>Filter graph packets will not be sent to receivers.</p>
<p>The OnStop() method of all threads in the context is invoked. The specified shutdown mode determines whether the graceful parameter of OnStop() is set to true or false. </p>

<p>Referenced by <a class="el" href="class_core_context.html#a107256cd9f29a43301afca98cd7309a5">SignalTerminate()</a>.</p>

</div>
</div>
<a class="anchor" id="a107256cd9f29a43301afca98cd7309a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::SignalTerminate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shuts down the context with the Immediate shutdown mode. </p>
<p>The same as calling SignalShutdown(true, ShutdownMode::Immediate). </p>

</div>
</div>
<a class="anchor" id="a846274ca88865c63655b5eeb054d12b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CoreContext::Wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until the context begins shutting down (IsShutdown is true) and all threads and child threads have terminated. </p>
<p>You can use this function to keep a context in scope while it processes events, etc. For example, to prevent exiting from the program's main() function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <a class="code" href="class_auto_current_context.html">AutoCurrentContext</a> ctxt;</div>
<div class="line">    <span class="comment">// set up and initiate context...</span></div>
<div class="line">    ctxt-&gt;Wait();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a6708295354459d99f39f4f4a2899211d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::Wait </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the specified number of nanoseconds. </p>

</div>
</div>
<a class="anchor" id="ad12f8a7181248f040bde3fd4cdcd799e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreContext::WasStarted </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias of the IsInitiated method </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autowiring/<a class="el" href="_core_context_8h_source.html">CoreContext.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_core_context.html">CoreContext</a></li>
    <li class="footer">Generated on Wed Jan 6 2016 16:25:20 for Autowiring by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
