<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Autowiring: DispatchQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.5.1</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Developer's&#160;Guide</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_dispatch_queue.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_dispatch_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DispatchQueue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is an asynchronous queue of zero-argument functions  
 <a href="class_dispatch_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_dispatch_queue_8h_source.html">DispatchQueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DispatchQueue:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_dispatch_queue.png" usemap="#DispatchQueue_map" alt=""/>
  <map id="DispatchQueue_map" name="DispatchQueue_map">
<area href="class_core_thread.html" title="Provides a dispatch queue that creates a thread to run jobs (in the form of lambda functions) in the ..." alt="CoreThread" shape="rect" coords="0,56,99,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa62c1140f05c7513bc80668aa724684c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#aa62c1140f05c7513bc80668aa724684c">~DispatchQueue</a> (void)</td></tr>
<tr class="memdesc:aa62c1140f05c7513bc80668aa724684c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs down the dispatch queue without calling anything  <a href="#aa62c1140f05c7513bc80668aa724684c">More...</a><br /></td></tr>
<tr class="separator:aa62c1140f05c7513bc80668aa724684c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3193aa5422bf9e1aa80e1c1e9a913016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a3193aa5422bf9e1aa80e1c1e9a913016">Abort</a> (void)</td></tr>
<tr class="memdesc:a3193aa5422bf9e1aa80e1c1e9a913016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the current dispatch queue to be dumped if it's non-empty  <a href="#a3193aa5422bf9e1aa80e1c1e9a913016">More...</a><br /></td></tr>
<tr class="separator:a3193aa5422bf9e1aa80e1c1e9a913016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1121ea959ace80dfcee8a26b44a2d376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a1121ea959ace80dfcee8a26b44a2d376">AddExisting</a> (DispatchThunkBase *pBase)</td></tr>
<tr class="memdesc:a1121ea959ace80dfcee8a26b44a2d376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit overload for already-constructed dispatch thunk types  <a href="#a1121ea959ace80dfcee8a26b44a2d376">More...</a><br /></td></tr>
<tr class="separator:a1121ea959ace80dfcee8a26b44a2d376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee3c640b1c46dc87157d7e1186db9bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ee3c640b1c46dc87157d7e1186db9bc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a9ee3c640b1c46dc87157d7e1186db9bc">AreAnyDispatchersReady</a> (void) const </td></tr>
<tr class="memdesc:a9ee3c640b1c46dc87157d7e1186db9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>True if there are curerntly any dispatchers ready for execution&ndash;IE, DispatchEvent would return true </dd></dl>
<br /></td></tr>
<tr class="separator:a9ee3c640b1c46dc87157d7e1186db9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead80f32b70b6c6ee5acffb2b083724a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aead80f32b70b6c6ee5acffb2b083724a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#aead80f32b70b6c6ee5acffb2b083724a">GetDispatchQueueLength</a> (void) const </td></tr>
<tr class="memdesc:aead80f32b70b6c6ee5acffb2b083724a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>The total number of all ready and delayed events </dd></dl>
<br /></td></tr>
<tr class="separator:aead80f32b70b6c6ee5acffb2b083724a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2064b527f4ded6b9fbfd3f9193df696"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:af2064b527f4ded6b9fbfd3f9193df696"><td class="memTemplItemLeft" align="right" valign="top">DispatchThunkDelayedExpression&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#af2064b527f4ded6b9fbfd3f9193df696">operator+=</a> (std::chrono::duration&lt; Rep, Period &gt; rhs)</td></tr>
<tr class="memdesc:af2064b527f4ded6b9fbfd3f9193df696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for the introduction of a delayed dispatch thunk  <a href="#af2064b527f4ded6b9fbfd3f9193df696">More...</a><br /></td></tr>
<tr class="separator:af2064b527f4ded6b9fbfd3f9193df696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e6065b7860a6bb075634a0fbbc7203"><td class="memItemLeft" align="right" valign="top">DispatchThunkDelayedExpression&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a00e6065b7860a6bb075634a0fbbc7203">operator+=</a> (std::chrono::steady_clock::time_point rhs)</td></tr>
<tr class="memdesc:a00e6065b7860a6bb075634a0fbbc7203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for absolute-time based delayed dispatch thunk  <a href="#a00e6065b7860a6bb075634a0fbbc7203">More...</a><br /></td></tr>
<tr class="separator:a00e6065b7860a6bb075634a0fbbc7203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada43ba9a08cec6888a103f94f6e2dabb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#ada43ba9a08cec6888a103f94f6e2dabb">operator+=</a> (DispatchThunkDelayed &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ada43ba9a08cec6888a103f94f6e2dabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly pends a delayed dispatch thunk  <a href="#ada43ba9a08cec6888a103f94f6e2dabb">More...</a><br /></td></tr>
<tr class="separator:ada43ba9a08cec6888a103f94f6e2dabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfd34970fbfca53f0d3b10cbb9c433c"><td class="memTemplParams" colspan="2">template&lt;class _Fx &gt; </td></tr>
<tr class="memitem:a8dfd34970fbfca53f0d3b10cbb9c433c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a8dfd34970fbfca53f0d3b10cbb9c433c">operator+=</a> (_Fx &amp;&amp;fx)</td></tr>
<tr class="memdesc:a8dfd34970fbfca53f0d3b10cbb9c433c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic overload which will pend an arbitrary dispatch type  <a href="#a8dfd34970fbfca53f0d3b10cbb9c433c">More...</a><br /></td></tr>
<tr class="separator:a8dfd34970fbfca53f0d3b10cbb9c433c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457e780c30d55fffc706892e1ebb160a"><td class="memItemLeft" align="right" valign="top">std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a457e780c30d55fffc706892e1ebb160a">SuggestSoonestWakeupTimeUnsafe</a> (std::chrono::steady_clock::time_point latestTime) const </td></tr>
<tr class="memdesc:a457e780c30d55fffc706892e1ebb160a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recommends a point in time to wake up to check for events  <a href="#a457e780c30d55fffc706892e1ebb160a">More...</a><br /></td></tr>
<tr class="separator:a457e780c30d55fffc706892e1ebb160a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af94131c04ad4d1513cc411870fc6b002"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#af94131c04ad4d1513cc411870fc6b002">DispatchAllEvents</a> (void)</td></tr>
<tr class="memdesc:af94131c04ad4d1513cc411870fc6b002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to DispatchEvent, but will attempt to dispatch all events currently queued  <a href="#af94131c04ad4d1513cc411870fc6b002">More...</a><br /></td></tr>
<tr class="separator:af94131c04ad4d1513cc411870fc6b002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cf0ed4b428ecbee03fb64a0e705ce7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#ae4cf0ed4b428ecbee03fb64a0e705ce7">DispatchEvent</a> (void)</td></tr>
<tr class="memdesc:ae4cf0ed4b428ecbee03fb64a0e705ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to WaitForEvent, but does not block  <a href="#ae4cf0ed4b428ecbee03fb64a0e705ce7">More...</a><br /></td></tr>
<tr class="separator:ae4cf0ed4b428ecbee03fb64a0e705ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c909a2f706599e2aeaea163afc43d2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a7c909a2f706599e2aeaea163afc43d2a">DispatchEventUnsafe</a> (std::unique_lock&lt; std::mutex &gt; &amp;lk)</td></tr>
<tr class="memdesc:a7c909a2f706599e2aeaea163afc43d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to DispatchEvent, except assumes that the dispatch lock is currently held  <a href="#a7c909a2f706599e2aeaea163afc43d2a">More...</a><br /></td></tr>
<tr class="separator:a7c909a2f706599e2aeaea163afc43d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7d922485f14bdbb72559df2e009b40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a6c7d922485f14bdbb72559df2e009b40">OnPended</a> (std::unique_lock&lt; std::mutex &gt; &amp;&amp;lk)</td></tr>
<tr class="memdesc:a6c7d922485f14bdbb72559df2e009b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility virtual, called whenever a new event is deferred  <a href="#a6c7d922485f14bdbb72559df2e009b40">More...</a><br /></td></tr>
<tr class="separator:a6c7d922485f14bdbb72559df2e009b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e44d8531decda82fe874ef073d2d99"><td class="memTemplParams" colspan="2">template&lt;class _Fx &gt; </td></tr>
<tr class="memitem:ad2e44d8531decda82fe874ef073d2d99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#ad2e44d8531decda82fe874ef073d2d99">Pend</a> (_Fx &amp;&amp;fx)</td></tr>
<tr class="memdesc:ad2e44d8531decda82fe874ef073d2d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches an element to the end of the dispatch queue without any checks.  <a href="#ad2e44d8531decda82fe874ef073d2d99">More...</a><br /></td></tr>
<tr class="separator:ad2e44d8531decda82fe874ef073d2d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad392c934d343fb56f8c233d2fbd6243b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#ad392c934d343fb56f8c233d2fbd6243b">PromoteReadyDispatchersUnsafe</a> (void)</td></tr>
<tr class="memdesc:ad392c934d343fb56f8c233d2fbd6243b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all ready events from the delayed queue into the dispatch queue  <a href="#ad392c934d343fb56f8c233d2fbd6243b">More...</a><br /></td></tr>
<tr class="separator:ad392c934d343fb56f8c233d2fbd6243b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e455ffdaece9c129717211f13752fa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dispatch_queue.html#a6e455ffdaece9c129717211f13752fa3">SetDispatcherCap</a> (size_t dispatchCap)</td></tr>
<tr class="memdesc:a6e455ffdaece9c129717211f13752fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the upper bound on the number of allowed pending dispatchers  <a href="#a6e455ffdaece9c129717211f13752fa3">More...</a><br /></td></tr>
<tr class="separator:a6e455ffdaece9c129717211f13752fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is an asynchronous queue of zero-argument functions </p>
<p>A <a class="el" href="class_dispatch_queue.html" title="This is an asynchronous queue of zero-argument functions ">DispatchQueue</a> is a type of event receiver which allows for the reception of deferred events. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa62c1140f05c7513bc80668aa724684c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DispatchQueue::~DispatchQueue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs down the dispatch queue without calling anything </p>
<p>Nothing in the destructor is synchronized. This is done under the assumption that multi- access during teardown is impossible. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3193aa5422bf9e1aa80e1c1e9a913016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::Abort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the current dispatch queue to be dumped if it's non-empty </p>
<p>This method should only be called if a non-graceful termination is desired. In this case, the dispatch queue will be immediately cleared and any subsequent calls to WaitForEvent or DispatchEvent will throw a dispatch_aborted_exception.</p>
<p>Callers who are willing to allow the dispatch queue to be fully processed should call Rundown instead.</p>
<p>This method is idempotent </p>

</div>
</div>
<a class="anchor" id="a1121ea959ace80dfcee8a26b44a2d376"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::AddExisting </td>
          <td>(</td>
          <td class="paramtype">DispatchThunkBase *&#160;</td>
          <td class="paramname"><em>pBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit overload for already-constructed dispatch thunk types </p>

</div>
</div>
<a class="anchor" id="af94131c04ad4d1513cc411870fc6b002"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DispatchQueue::DispatchAllEvents </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to DispatchEvent, but will attempt to dispatch all events currently queued </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of events dispatched</dd></dl>

</div>
</div>
<a class="anchor" id="ae4cf0ed4b428ecbee03fb64a0e705ce7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DispatchQueue::DispatchEvent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to WaitForEvent, but does not block </p>
<dl class="section return"><dt>Returns</dt><dd>True if an event was dispatched, false if the queue was empty when checked</dd></dl>
<p>If the dispatch queue is empty, this method will check the delayed dispatch queue. </p>

</div>
</div>
<a class="anchor" id="a7c909a2f706599e2aeaea163afc43d2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::DispatchEventUnsafe </td>
          <td>(</td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt; &amp;&#160;</td>
          <td class="paramname"><em>lk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to DispatchEvent, except assumes that the dispatch lock is currently held </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lk</td><td>A lock on m_dispatchLock</td></tr>
  </table>
  </dd>
</dl>
<p>This method assumes that the dispatch lock is held and that m_aborted is false. It is an error to call this method without those preconditions met. </p>

</div>
</div>
<a class="anchor" id="a6c7d922485f14bdbb72559df2e009b40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DispatchQueue::OnPended </td>
          <td>(</td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility virtual, called whenever a new event is deferred </p>
<p>The recipient of this call will be running in an arbitrary thread context while holding the dispatch lock. The queue is guaranteed to contain at least one element, and may potentially contain more. The caller MUST NOT attempt to pend any more events during this call, or a deadlock could occur. </p>

<p>Referenced by <a class="el" href="class_dispatch_queue.html#a8dfd34970fbfca53f0d3b10cbb9c433c">operator+=()</a>, and <a class="el" href="class_dispatch_queue.html#ad2e44d8531decda82fe874ef073d2d99">Pend()</a>.</p>

</div>
</div>
<a class="anchor" id="af2064b527f4ded6b9fbfd3f9193df696"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DispatchThunkDelayedExpression DispatchQueue::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for the introduction of a delayed dispatch thunk </p>

</div>
</div>
<a class="anchor" id="a00e6065b7860a6bb075634a0fbbc7203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DispatchThunkDelayedExpression DispatchQueue::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::chrono::steady_clock::time_point&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for absolute-time based delayed dispatch thunk </p>

</div>
</div>
<a class="anchor" id="ada43ba9a08cec6888a103f94f6e2dabb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::operator+= </td>
          <td>(</td>
          <td class="paramtype">DispatchThunkDelayed &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directly pends a delayed dispatch thunk </p>
<p>This overload will always succeed and does not consult the dispatch cap </p>

</div>
</div>
<a class="anchor" id="a8dfd34970fbfca53f0d3b10cbb9c433c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::operator+= </td>
          <td>(</td>
          <td class="paramtype">_Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic overload which will pend an arbitrary dispatch type </p>

</div>
</div>
<a class="anchor" id="ad2e44d8531decda82fe874ef073d2d99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::Pend </td>
          <td>(</td>
          <td class="paramtype">_Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches an element to the end of the dispatch queue without any checks. </p>

</div>
</div>
<a class="anchor" id="ad392c934d343fb56f8c233d2fbd6243b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DispatchQueue::PromoteReadyDispatchersUnsafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves all ready events from the delayed queue into the dispatch queue </p>
<dl class="section return"><dt>Returns</dt><dd>True if at least one dispatcher was promoted</dd></dl>

</div>
</div>
<a class="anchor" id="a6e455ffdaece9c129717211f13752fa3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DispatchQueue::SetDispatcherCap </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dispatchCap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the upper bound on the number of allowed pending dispatchers </p>

</div>
</div>
<a class="anchor" id="a457e780c30d55fffc706892e1ebb160a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::steady_clock::time_point DispatchQueue::SuggestSoonestWakeupTimeUnsafe </td>
          <td>(</td>
          <td class="paramtype">std::chrono::steady_clock::time_point&#160;</td>
          <td class="paramname"><em>latestTime</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recommends a point in time to wake up to check for events </p>
<dl class="section return"><dt>Returns</dt><dd>lastestTime, or if there is a dispatch in the delayed queue which will be ready sooner than latestTime, the time_point when that dispatch will be ready to run. </dd></dl>
<p>This method is used by clients that are performing manual dispatch operations and wish to know the shortest time they should sleep in order to be guaranteed that, upon waking, a dispatch will be ready to run.</p>
<p>Users should be aware that another dispatch may arrive which is ready to run sooner than the returned suggestion. Notification of this case will be provided to derived classes via the OnPended override. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autowiring/<a class="el" href="_dispatch_queue_8h_source.html">DispatchQueue.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_dispatch_queue.html">DispatchQueue</a></li>
    <li class="footer">Generated on Thu Mar 26 2015 17:32:37 for Autowiring by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
