///////////////////////////////////////////////////////////////////////////////
// accumulators_fwd.hpp
//
//  Copyright 2005 Eric Niebler. Distributed under the Boost
//  Software License, Version 1.0. (See accompanying file
//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

#ifndef AUTOBOOST_ACCUMULATORS_ACCUMULATORS_FWD_HPP_EAN_28_10_2005
#define AUTOBOOST_ACCUMULATORS_ACCUMULATORS_FWD_HPP_EAN_28_10_2005

#include <autoboost/config.hpp>
#include <autoboost/mpl/apply_fwd.hpp> // for mpl::na
#include <autoboost/mpl/limits/vector.hpp>
#include <autoboost/preprocessor/cat.hpp>
#include <autoboost/preprocessor/arithmetic/inc.hpp>
#include <autoboost/preprocessor/repetition/enum_params_with_a_default.hpp>
#include <autoboost/preprocessor/repetition/enum_trailing_params.hpp>
#include <autoboost/preprocessor/repetition/enum_trailing_binary_params.hpp>
#include <autoboost/preprocessor/repetition/repeat_from_to.hpp>
#include <autoboost/accumulators/numeric/functional_fwd.hpp>

#ifndef AUTOBOOST_ACCUMULATORS_MAX_FEATURES
  /// The maximum number of accumulators that may be put in an accumulator_set.
  /// Defaults to AUTOBOOST_MPL_LIMIT_VECTOR_SIZE (which defaults to 20).
# define AUTOBOOST_ACCUMULATORS_MAX_FEATURES AUTOBOOST_MPL_LIMIT_VECTOR_SIZE
#endif

#if AUTOBOOST_ACCUMULATORS_MAX_FEATURES > AUTOBOOST_MPL_LIMIT_VECTOR_SIZE
# error AUTOBOOST_ACCUMULATORS_MAX_FEATURES cannot be larger than AUTOBOOST_MPL_LIMIT_VECTOR_SIZE
#endif

#ifndef AUTOBOOST_ACCUMULATORS_MAX_ARGS
  /// The maximum number of arguments that may be specified to an accumulator_set's
  /// accumulation function. Defaults to 15.
# define AUTOBOOST_ACCUMULATORS_MAX_ARGS 15
#endif

#if AUTOBOOST_WORKAROUND(__GNUC__, == 3) \
 || AUTOBOOST_WORKAROUND(__EDG_VERSION__, AUTOBOOST_TESTED_AT(306))
# define AUTOBOOST_ACCUMULATORS_BROKEN_CONST_OVERLOADS
#endif

#ifdef AUTOBOOST_ACCUMULATORS_BROKEN_CONST_OVERLOADS
# include <autoboost/utility/enable_if.hpp>
# include <autoboost/type_traits/is_const.hpp>
# define AUTOBOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST(T)\
    , typename autoboost::disable_if<autoboost::is_const<T> >::type * = 0
#else
# define AUTOBOOST_ACCUMULATORS_PROTO_DISABLE_IF_IS_CONST(T)
#endif

#define AUTOBOOST_ACCUMULATORS_GCC_VERSION                                                              \
  (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)

namespace autoboost { namespace accumulators
{

///////////////////////////////////////////////////////////////////////////////
// Named parameters tags
//
namespace tag
{
    struct sample;
    struct weight;
    struct accumulator;
    struct weights;
}

///////////////////////////////////////////////////////////////////////////////
// User-level features
//
namespace tag
{
    template<typename ValueType, typename Tag>
    struct value;

    template<typename Tag>
    struct value_tag;

    template<typename Referent, typename Tag>
    struct reference;

    template<typename Tag>
    struct reference_tag;

    template<typename Type, typename Tag = void, typename AccumulatorSet = void>
    struct external;

    template<typename Feature>
    struct droppable;
}

template<typename Accumulator>
struct droppable_accumulator_base;

template<typename Accumulator>
struct droppable_accumulator;

template<typename Accumulator>
struct with_cached_result;

template<typename Sample, typename Features, typename Weight = void>
struct accumulator_set;

template<typename Feature>
struct extractor;

template<typename Feature>
struct feature_of;

template<typename Feature>
struct as_feature;

template<typename Feature>
struct as_weighted_feature;

template<AUTOBOOST_PP_ENUM_PARAMS_WITH_A_DEFAULT(AUTOBOOST_ACCUMULATORS_MAX_FEATURES, typename Feature, mpl::na)>
struct depends_on;

template<AUTOBOOST_PP_ENUM_PARAMS_WITH_A_DEFAULT(AUTOBOOST_ACCUMULATORS_MAX_FEATURES, typename Feature, mpl::na)>
struct features;

template<typename Feature, typename AccumulatorSet>
typename mpl::apply<AccumulatorSet, Feature>::type const &
find_accumulator(AccumulatorSet const &acc);

template<typename Feature, typename AccumulatorSet>
typename mpl::apply<AccumulatorSet, Feature>::type::result_type
extract_result(AccumulatorSet const &acc);

template<typename Feature, typename AccumulatorSet, typename A1>
typename mpl::apply<AccumulatorSet, Feature>::type::result_type
extract_result(AccumulatorSet const &acc, A1 const &a1);

// ... other overloads generated by Boost.Preprocessor:

/// INTERNAL ONLY
///
#define AUTOBOOST_ACCUMULATORS_EXTRACT_RESULT_FWD(z, n, _)                      \
    template<                                                               \
        typename Feature                                                    \
      , typename AccumulatorSet                                             \
        AUTOBOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, typename A)                   \
    >                                                                       \
    typename mpl::apply<AccumulatorSet, Feature>::type::result_type         \
    extract_result(                                                         \
        AccumulatorSet const &acc                                           \
        AUTOBOOST_PP_ENUM_TRAILING_BINARY_PARAMS_Z(z, n, A, const &a)           \
    );

/// INTERNAL ONLY
///
AUTOBOOST_PP_REPEAT_FROM_TO(
    2
  , AUTOBOOST_PP_INC(AUTOBOOST_ACCUMULATORS_MAX_ARGS)
  , AUTOBOOST_ACCUMULATORS_EXTRACT_RESULT_FWD
  , _
)

#ifdef AUTOBOOST_ACCUMULATORS_DOXYGEN_INVOKED
template<typename Feature, typename AccumulatorSet, typename A1, typename A2 ...>
typename mpl::apply<AccumulatorSet, Feature>::type::result_type
extract_result(AccumulatorSet const &acc, A1 const &a1, A2 const &a2 ...);
#endif

namespace impl
{
    using namespace numeric::operators;

    template<typename Accumulator, typename Tag>
    struct external_impl;
}

namespace detail
{
    template<typename Accumulator>
    struct feature_tag;

    template<typename Feature, typename Sample, typename Weight>
    struct to_accumulator;

    struct accumulator_set_base;

    template<typename T>
    struct is_accumulator_set;

    inline void ignore_variable(void const *) {}

#define AUTOBOOST_ACCUMULATORS_IGNORE_GLOBAL(X)                             \
    namespace detail                                                    \
    {                                                                   \
        struct AUTOBOOST_PP_CAT(ignore_, X)                                 \
        {                                                               \
            void ignore()                                               \
            {                                                           \
                autoboost::accumulators::detail::ignore_variable(&X);       \
            }                                                           \
        };                                                              \
    }                                                                   \
    /**/
}

}} // namespace autoboost::accumulators

// For defining autoboost::parameter keywords that can be inherited from to
// get a nested, class-scoped keyword with the requested alias
#define AUTOBOOST_PARAMETER_NESTED_KEYWORD(tag_namespace, name, alias)                                  \
    namespace tag_namespace                                                                         \
    {                                                                                               \
        template<int Dummy = 0>                                                                     \
        struct name ## _                                                                            \
        {                                                                                           \
            static char const* keyword_name()                                                       \
            {                                                                                       \
                return #name;                                                                       \
            }                                                                                       \
            static ::autoboost::parameter::keyword<name ## _<Dummy> > &alias;                           \
        };                                                                                          \
        template<int Dummy>                                                                         \
        ::autoboost::parameter::keyword<name ## _<Dummy> > &name ## _<Dummy>::alias =                   \
        ::autoboost::parameter::keyword<name ## _<Dummy> >::get();                                      \
        typedef name ## _ <> name;                                                                  \
    }                                                                                               \
    namespace                                                                                       \
    {                                                                                               \
        ::autoboost::parameter::keyword<tag_namespace::name> &name =                                    \
        ::autoboost::parameter::keyword<tag_namespace::name>::get();                                    \
    }

#endif
