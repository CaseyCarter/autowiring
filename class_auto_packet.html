<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Autowiring: AutoPacket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_auto_packet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AutoPacket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A decorator-style processing packet  
 <a href="class_auto_packet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_auto_packet_8h_source.html">AutoPacket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AutoPacket:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_auto_packet.png" usemap="#AutoPacket_map" alt=""/>
  <map id="AutoPacket_map" name="AutoPacket_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab486082f7387a45d05dbc6eb04590a59"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab486082f7387a45d05dbc6eb04590a59"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ab486082f7387a45d05dbc6eb04590a59">Has</a> (void) const </td></tr>
<tr class="separator:ab486082f7387a45d05dbc6eb04590a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf54c5ecd5cd943820475cbe051a9570"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adf54c5ecd5cd943820475cbe051a9570"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#adf54c5ecd5cd943820475cbe051a9570">Get</a> (void) const </td></tr>
<tr class="memdesc:adf54c5ecd5cd943820475cbe051a9570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects the desired type, or throws an exception if such a type cannot be found  <a href="#adf54c5ecd5cd943820475cbe051a9570">More...</a><br /></td></tr>
<tr class="separator:adf54c5ecd5cd943820475cbe051a9570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0a7cec8c6689c756b35af4cffd24a4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aec0a7cec8c6689c756b35af4cffd24a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aec0a7cec8c6689c756b35af4cffd24a4">Get</a> (const T *&amp;out) const </td></tr>
<tr class="memdesc:aec0a7cec8c6689c756b35af4cffd24a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this pipeline packet contains an entry of the specified type  <a href="#aec0a7cec8c6689c756b35af4cffd24a4">More...</a><br /></td></tr>
<tr class="separator:aec0a7cec8c6689c756b35af4cffd24a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967bcbe811ccef75857a358ab0fd1af5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a967bcbe811ccef75857a358ab0fd1af5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a967bcbe811ccef75857a358ab0fd1af5">Get</a> (const std::shared_ptr&lt; T &gt; *&amp;out) const </td></tr>
<tr class="memdesc:a967bcbe811ccef75857a358ab0fd1af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer specialization, used to obtain the underlying shared pointer for some type T  <a href="#a967bcbe811ccef75857a358ab0fd1af5">More...</a><br /></td></tr>
<tr class="separator:a967bcbe811ccef75857a358ab0fd1af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeb4ec519323be93d0b2e757cb8bbeb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6eeb4ec519323be93d0b2e757cb8bbeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_auto_checkout.html">AutoCheckout</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a6eeb4ec519323be93d0b2e757cb8bbeb">Checkout</a> (std::shared_ptr&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a6eeb4ec519323be93d0b2e757cb8bbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks out the specified type, providing it to the caller to be filled in  <a href="#a6eeb4ec519323be93d0b2e757cb8bbeb">More...</a><br /></td></tr>
<tr class="separator:a6eeb4ec519323be93d0b2e757cb8bbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b14dbee716497ad15ec4d132b12ad3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad7b14dbee716497ad15ec4d132b12ad3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad7b14dbee716497ad15ec4d132b12ad3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_auto_checkout.html">AutoCheckout</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Checkout</b> (void)</td></tr>
<tr class="separator:ad7b14dbee716497ad15ec4d132b12ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9788e64105fee4f967e53871c4d93b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2b9788e64105fee4f967e53871c4d93b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a2b9788e64105fee4f967e53871c4d93b">Unsatisfiable</a> (void)</td></tr>
<tr class="memdesc:a2b9788e64105fee4f967e53871c4d93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the named decoration as unsatisfiable  <a href="#a2b9788e64105fee4f967e53871c4d93b">More...</a><br /></td></tr>
<tr class="separator:a2b9788e64105fee4f967e53871c4d93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828d9a72ac228f36087723cca4f93e13"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a828d9a72ac228f36087723cca4f93e13"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a828d9a72ac228f36087723cca4f93e13">Decorate</a> (T t)</td></tr>
<tr class="memdesc:a828d9a72ac228f36087723cca4f93e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorates this packet with a particular type  <a href="#a828d9a72ac228f36087723cca4f93e13">More...</a><br /></td></tr>
<tr class="separator:a828d9a72ac228f36087723cca4f93e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dd9447cf3094e6cadb319ccfe60982"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a65dd9447cf3094e6cadb319ccfe60982"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a65dd9447cf3094e6cadb319ccfe60982">Decorate</a> (std::shared_ptr&lt; T &gt; t)</td></tr>
<tr class="memdesc:a65dd9447cf3094e6cadb319ccfe60982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decoration method specialized for shared pointer types  <a href="#a65dd9447cf3094e6cadb319ccfe60982">More...</a><br /></td></tr>
<tr class="separator:a65dd9447cf3094e6cadb319ccfe60982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac016b40fd64cf3e9df03627de240448a"><td class="memTemplParams" colspan="2">template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:ac016b40fd64cf3e9df03627de240448a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ac016b40fd64cf3e9df03627de240448a">DecorateImmediate</a> (const T &amp;immed, const Ts &amp;...immeds)</td></tr>
<tr class="memdesc:ac016b40fd64cf3e9df03627de240448a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribers respond to the decoration arguments immediately or never for this packet. Optional argument resolution is forced for any subscriber requiring at least one argument of this method  <a href="#ac016b40fd64cf3e9df03627de240448a">More...</a><br /></td></tr>
<tr class="separator:ac016b40fd64cf3e9df03627de240448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af6d953ba5968fffd20cb736ad0cbc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a76af6d953ba5968fffd20cb736ad0cbc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a76af6d953ba5968fffd20cb736ad0cbc">HasSubscribers</a> (void) const </td></tr>
<tr class="separator:a76af6d953ba5968fffd20cb736ad0cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e097c036f19ffd123c5f8ab0b5cfc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4e097c036f19ffd123c5f8ab0b5cfc1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasSubscribers</b> (const std::type_info &amp;ti) const </td></tr>
<tr class="separator:af4e097c036f19ffd123c5f8ab0b5cfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2c4b80812e483277a1296f42bfa8d30b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c4b80812e483277a1296f42bfa8d30b"></a>
static <a class="el" href="class_object_pool.html">ObjectPool</a>&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateObjectPool</b> (<a class="el" href="class_auto_packet_factory.html">AutoPacketFactory</a> &amp;factory, const std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt; &amp;outstanding)</td></tr>
<tr class="separator:a2c4b80812e483277a1296f42bfa8d30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A decorator-style processing packet </p>
<p>A processing packet may be decorated with additional types as desired by the user. The pipeline packet is not a type of context; querying the packet for an element of a particular type will look for an element of precisely that type, not an inherited type or a related interface.</p>
<p>Consumers who wish to advertise a particular field under multiple types must do so manually with the Advertise function. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6eeb4ec519323be93d0b2e757cb8bbeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_auto_checkout.html">AutoCheckout</a>&lt;T&gt; AutoPacket::Checkout </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks out the specified type, providing it to the caller to be filled in </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>If set, the initial value that will be held by the checkout</td></tr>
  </table>
  </dd>
</dl>
<p>The caller must call Ready on the returned value before it falls out of scope in order to ensure that the checkout is eventually committed. The checkout will be committed when it falls out of scope if so marked. </p>

</div>
</div>
<a class="anchor" id="a828d9a72ac228f36087723cca4f93e13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decorates this packet with a particular type </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the internally persisted object</dd></dl>
<p>Unlike Publish, the Decorate method is unconditional and will install the passed value regardless of whether any subscribers exist. </p>

</div>
</div>
<a class="anchor" id="a65dd9447cf3094e6cadb319ccfe60982"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decoration method specialized for shared pointer types </p>
<p>This decoration method has the additional benefit that it will make direct use of the passed shared pointer. </p>

</div>
</div>
<a class="anchor" id="ac016b40fd64cf3e9df03627de240448a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::DecorateImmediate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>immed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>immeds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribers respond to the decoration arguments immediately or never for this packet. Optional argument resolution is forced for any subscriber requiring at least one argument of this method </p>
<p>Unlike Decorate, the arguments of DecorateImmediate are not copied. Each decoration is only valid for AutoFilters which are valid during this call. If multiple values are specified, all will be simultaneously made valid and then invalidated. </p>

</div>
</div>
<a class="anchor" id="adf54c5ecd5cd943820475cbe051a9570"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects the desired type, or throws an exception if such a type cannot be found </p>

</div>
</div>
<a class="anchor" id="aec0a7cec8c6689c756b35af4cffd24a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">const T *&amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this pipeline packet contains an entry of the specified type </p>

</div>
</div>
<a class="anchor" id="a967bcbe811ccef75857a358ab0fd1af5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; *&amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared pointer specialization, used to obtain the underlying shared pointer for some type T </p>
<p>This specialization cannot be used to obtain a decoration which has been attached to this packet via DecorateImmediate </p>

</div>
</div>
<a class="anchor" id="ab486082f7387a45d05dbc6eb04590a59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Has </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this packet posesses a decoration of the specified type </dd></dl>

</div>
</div>
<a class="anchor" id="a76af6d953ba5968fffd20cb736ad0cbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::HasSubscribers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the indicated type has been requested for use by some consumer </dd></dl>
<p>This method is used to determine whether an AutoFilter recipient existed for the specified type at the time the packet was created </p>

</div>
</div>
<a class="anchor" id="a2b9788e64105fee4f967e53871c4d93b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Unsatisfiable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the named decoration as unsatisfiable </p>
<p>Marking a decoration as unsatisfiable immediately causes any filters with an optional input on this type to be called, if the remainder of their inputs are available. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>autowiring/<a class="el" href="_auto_packet_8h_source.html">AutoPacket.h</a></li>
<li>src/autowiring/AutoPacket.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 7 2014 11:13:20 for Autowiring by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
