<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Autowiring: AutoPacket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.4.1</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_auto_packet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AutoPacket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A decorator-style processing packet  
 <a href="class_auto_packet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_auto_packet_8h_source.html">AutoPacket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AutoPacket:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_auto_packet.png" usemap="#AutoPacket_map" alt=""/>
  <map id="AutoPacket_map" name="AutoPacket_map">
<area href="class_teardown_notifier.html" title="Maintains a list of lambdas to be invoked when the enclosing object is being destroyed ..." alt="TeardownNotifier" shape="rect" coords="274,0,538,24"/>
<area href="class_auto_packet_internal.html" title="Internal representation type for AutoPacket, provides methods for exclusive use with a packet factory..." alt="AutoPacketInternal" shape="rect" coords="137,112,401,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_auto_packet_1_1_recipient.html">Recipient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0a2dd10a361bc335cf2d23b602f14e27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a2dd10a361bc335cf2d23b602f14e27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AutoPacket</b> (<a class="el" href="class_auto_packet_factory.html">AutoPacketFactory</a> &amp;factory, std::shared_ptr&lt; void &gt; &amp;&amp;outstanding)</td></tr>
<tr class="separator:a0a2dd10a361bc335cf2d23b602f14e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749ec811977357ea7165b8e77be65932"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a749ec811977357ea7165b8e77be65932"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a749ec811977357ea7165b8e77be65932">Has</a> (int tshift=0) const </td></tr>
<tr class="separator:a749ec811977357ea7165b8e77be65932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2ea2311961fd3e9f92c6b5dc40887d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afc2ea2311961fd3e9f92c6b5dc40887d"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#afc2ea2311961fd3e9f92c6b5dc40887d">Get</a> (int tshift=0) const </td></tr>
<tr class="memdesc:afc2ea2311961fd3e9f92c6b5dc40887d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects the desired type, or throws an exception if such a type cannot be found  <a href="#afc2ea2311961fd3e9f92c6b5dc40887d">More...</a><br /></td></tr>
<tr class="separator:afc2ea2311961fd3e9f92c6b5dc40887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cde58980c81a1c47cd683dd820ff2b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a43cde58980c81a1c47cd683dd820ff2b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a43cde58980c81a1c47cd683dd820ff2b">Get</a> (const T *&amp;out, int tshift=0) const </td></tr>
<tr class="memdesc:a43cde58980c81a1c47cd683dd820ff2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this pipeline packet contains an entry of the specified type  <a href="#a43cde58980c81a1c47cd683dd820ff2b">More...</a><br /></td></tr>
<tr class="separator:a43cde58980c81a1c47cd683dd820ff2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac1d4d5bedb9e5db1e8e91da85fc29a"><td class="memTemplParams" colspan="2"><a class="anchor" id="afac1d4d5bedb9e5db1e8e91da85fc29a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afac1d4d5bedb9e5db1e8e91da85fc29a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DEPRECATED</b> (<a class="el" href="class_auto_packet.html#afc2ea2311961fd3e9f92c6b5dc40887d">Get</a>(const std::shared_ptr&lt; T &gt; *&amp;out) const,&quot;This version of <a class="el" href="class_auto_packet.html#afc2ea2311961fd3e9f92c6b5dc40887d">Get</a> is deprecated due to the dangers it implies, do not use&quot;)</td></tr>
<tr class="separator:afac1d4d5bedb9e5db1e8e91da85fc29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfb2068e9ff2f88e632a74259745b5d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aedfb2068e9ff2f88e632a74259745b5d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aedfb2068e9ff2f88e632a74259745b5d">Get</a> (const std::shared_ptr&lt; const T &gt; *&amp;out, int tshift=0) const </td></tr>
<tr class="memdesc:aedfb2068e9ff2f88e632a74259745b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer specialization of const T*&amp;, used to obtain the underlying shared pointer for some type T  <a href="#aedfb2068e9ff2f88e632a74259745b5d">More...</a><br /></td></tr>
<tr class="separator:aedfb2068e9ff2f88e632a74259745b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434994156ef4debce252bb124ba2d5e7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a434994156ef4debce252bb124ba2d5e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a434994156ef4debce252bb124ba2d5e7">Get</a> (std::shared_ptr&lt; const T &gt; &amp;out, int tshift=0) const </td></tr>
<tr class="memdesc:a434994156ef4debce252bb124ba2d5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer specialization, used to obtain the underlying shared pointer for some type T  <a href="#a434994156ef4debce252bb124ba2d5e7">More...</a><br /></td></tr>
<tr class="separator:a434994156ef4debce252bb124ba2d5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ffe5eccd1062bb2676c1951ab6d561"><td class="memTemplParams" colspan="2"><a class="anchor" id="af3ffe5eccd1062bb2676c1951ab6d561"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af3ffe5eccd1062bb2676c1951ab6d561"><td class="memTemplItemLeft" align="right" valign="top">const std::shared_ptr&lt; const T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetShared</b> (void) const </td></tr>
<tr class="separator:af3ffe5eccd1062bb2676c1951ab6d561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139f7015e781a094f43c9a30051d8b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a139f7015e781a094f43c9a30051d8b3d">Put</a> (const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;key, <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;&amp;in)</td></tr>
<tr class="memdesc:a139f7015e781a094f43c9a30051d8b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-templated placement method  <a href="#a139f7015e781a094f43c9a30051d8b3d">More...</a><br /></td></tr>
<tr class="separator:a139f7015e781a094f43c9a30051d8b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88913247c596018f77b29f2de9e2cd73"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a88913247c596018f77b29f2de9e2cd73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a88913247c596018f77b29f2de9e2cd73">Put</a> (T *in)</td></tr>
<tr class="memdesc:a88913247c596018f77b29f2de9e2cd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers ownership of argument to <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a>  <a href="#a88913247c596018f77b29f2de9e2cd73">More...</a><br /></td></tr>
<tr class="separator:a88913247c596018f77b29f2de9e2cd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e83b2de56c678b5d5c6e2933fcfad6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a68e83b2de56c678b5d5c6e2933fcfad6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a68e83b2de56c678b5d5c6e2933fcfad6">Put</a> (std::shared_ptr&lt; T &gt; in)</td></tr>
<tr class="memdesc:a68e83b2de56c678b5d5c6e2933fcfad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shares ownership of argument with <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a>  <a href="#a68e83b2de56c678b5d5c6e2933fcfad6">More...</a><br /></td></tr>
<tr class="separator:a68e83b2de56c678b5d5c6e2933fcfad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664edd114a9489c90020ed3467cc9642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a664edd114a9489c90020ed3467cc9642">ForwardAll</a> (std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt; recipient) const </td></tr>
<tr class="memdesc:a664edd114a9489c90020ed3467cc9642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shares all broadcast data from this packet with the recipient packet <a href="#a664edd114a9489c90020ed3467cc9642">More...</a><br /></td></tr>
<tr class="separator:a664edd114a9489c90020ed3467cc9642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9788e64105fee4f967e53871c4d93b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2b9788e64105fee4f967e53871c4d93b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a2b9788e64105fee4f967e53871c4d93b">Unsatisfiable</a> (void)</td></tr>
<tr class="memdesc:a2b9788e64105fee4f967e53871c4d93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the named decoration as unsatisfiable  <a href="#a2b9788e64105fee4f967e53871c4d93b">More...</a><br /></td></tr>
<tr class="separator:a2b9788e64105fee4f967e53871c4d93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828d9a72ac228f36087723cca4f93e13"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a828d9a72ac228f36087723cca4f93e13"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a828d9a72ac228f36087723cca4f93e13">Decorate</a> (T t)</td></tr>
<tr class="memdesc:a828d9a72ac228f36087723cca4f93e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorates this packet with a particular type  <a href="#a828d9a72ac228f36087723cca4f93e13">More...</a><br /></td></tr>
<tr class="separator:a828d9a72ac228f36087723cca4f93e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4488588d00ac475ae3e9a0e079961774"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4488588d00ac475ae3e9a0e079961774"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a4488588d00ac475ae3e9a0e079961774">Decorate</a> (std::shared_ptr&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a4488588d00ac475ae3e9a0e079961774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decoration method specialized for shared pointer types  <a href="#a4488588d00ac475ae3e9a0e079961774">More...</a><br /></td></tr>
<tr class="separator:a4488588d00ac475ae3e9a0e079961774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac016b40fd64cf3e9df03627de240448a"><td class="memTemplParams" colspan="2">template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:ac016b40fd64cf3e9df03627de240448a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ac016b40fd64cf3e9df03627de240448a">DecorateImmediate</a> (const T &amp;immed, const Ts &amp;...immeds)</td></tr>
<tr class="memdesc:ac016b40fd64cf3e9df03627de240448a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribers respond to the decoration arguments immediately or never for this packet. Optional argument resolution is forced for any subscriber requiring at least one argument of this method  <a href="#ac016b40fd64cf3e9df03627de240448a">More...</a><br /></td></tr>
<tr class="separator:ac016b40fd64cf3e9df03627de240448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62311d54b21229bfce44bee6442ace9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_auto_packet_1_1_recipient.html">Recipient</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ad62311d54b21229bfce44bee6442ace9">AddRecipient</a> (const <a class="el" href="struct_auto_filter_descriptor.html">AutoFilterDescriptor</a> &amp;descriptor)</td></tr>
<tr class="memdesc:ad62311d54b21229bfce44bee6442ace9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a recipient for data associated only with this issuance of the packet.  <a href="#ad62311d54b21229bfce44bee6442ace9">More...</a><br /></td></tr>
<tr class="separator:ad62311d54b21229bfce44bee6442ace9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d83c084026aa7a19a20335bcab44c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ad2d83c084026aa7a19a20335bcab44c0">RemoveRecipient</a> (<a class="el" href="struct_auto_packet_1_1_recipient.html">Recipient</a> &amp;&amp;recipient)</td></tr>
<tr class="memdesc:ad2d83c084026aa7a19a20335bcab44c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added packet recipient  <a href="#ad2d83c084026aa7a19a20335bcab44c0">More...</a><br /></td></tr>
<tr class="separator:ad2d83c084026aa7a19a20335bcab44c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2386a188fa820b5ae4de667110dabc05"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a2386a188fa820b5ae4de667110dabc05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_auto_packet_1_1_recipient.html">Recipient</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a2386a188fa820b5ae4de667110dabc05">operator+=</a> (Fx &amp;&amp;fx)</td></tr>
<tr class="memdesc:a2386a188fa820b5ae4de667110dabc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload, identical in behavior to AddRecipient  <a href="#a2386a188fa820b5ae4de667110dabc05">More...</a><br /></td></tr>
<tr class="separator:a2386a188fa820b5ae4de667110dabc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420bcbfa461af904ecbdaef771f9f702"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a420bcbfa461af904ecbdaef771f9f702"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_auto_packet.html">AutoPacket</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a420bcbfa461af904ecbdaef771f9f702">operator+=</a> (Fx &amp;&amp;fx) const </td></tr>
<tr class="memdesc:a420bcbfa461af904ecbdaef771f9f702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload, provided to allow the attachment of receive-only filters to a const <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a>  <a href="#a420bcbfa461af904ecbdaef771f9f702">More...</a><br /></td></tr>
<tr class="separator:a420bcbfa461af904ecbdaef771f9f702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8152052798e49283c8297886c62ffe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1e8152052798e49283c8297886c62ffe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="struct_sat_counter.html">SatCounter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a1e8152052798e49283c8297886c62ffe">GetSatisfaction</a> (void) const </td></tr>
<tr class="separator:a1e8152052798e49283c8297886c62ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e334e9056a3743fd8c96dc7169a827c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e334e9056a3743fd8c96dc7169a827c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4e334e9056a3743fd8c96dc7169a827c"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="struct_sat_counter.html">SatCounter</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a4e334e9056a3743fd8c96dc7169a827c">GetSubscribers</a> (void) const </td></tr>
<tr class="memdesc:a4e334e9056a3743fd8c96dc7169a827c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>All subscribers to the specified data</dd></dl>
<br /></td></tr>
<tr class="separator:a4e334e9056a3743fd8c96dc7169a827c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16660e7ea8af64b3e3c4a30e957961f2"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a16660e7ea8af64b3e3c4a30e957961f2">GetDispositions</a> () const </td></tr>
<tr class="separator:a16660e7ea8af64b3e3c4a30e957961f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1727aa9cf3f70d55bf8dcbcd40ae77"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8b1727aa9cf3f70d55bf8dcbcd40ae77"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a8b1727aa9cf3f70d55bf8dcbcd40ae77">GetDispositions</a> (void) const </td></tr>
<tr class="separator:a8b1727aa9cf3f70d55bf8dcbcd40ae77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f242a08b6a3d900039309f031d17e8f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a0f242a08b6a3d900039309f031d17e8f">Successor</a> (void)</td></tr>
<tr class="memdesc:a0f242a08b6a3d900039309f031d17e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next packet that will be issued by the packet factory in this context relative to this context  <a href="#a0f242a08b6a3d900039309f031d17e8f">More...</a><br /></td></tr>
<tr class="separator:a0f242a08b6a3d900039309f031d17e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af6d953ba5968fffd20cb736ad0cbc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a76af6d953ba5968fffd20cb736ad0cbc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a76af6d953ba5968fffd20cb736ad0cbc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a76af6d953ba5968fffd20cb736ad0cbc">HasSubscribers</a> (void) const </td></tr>
<tr class="memdesc:a76af6d953ba5968fffd20cb736ad0cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>True if the indicated type has been requested for use by some consumer</dd></dl>
<br /></td></tr>
<tr class="separator:a76af6d953ba5968fffd20cb736ad0cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967bcbe811ccef75857a358ab0fd1af5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a967bcbe811ccef75857a358ab0fd1af5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a967bcbe811ccef75857a358ab0fd1af5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Get</b> (const std::shared_ptr&lt; T &gt; *&amp;out) const </td></tr>
<tr class="separator:a967bcbe811ccef75857a358ab0fd1af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_teardown_notifier"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_teardown_notifier')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_teardown_notifier.html">TeardownNotifier</a></td></tr>
<tr class="memitem:afc05f0790c0f3e3bdebbcb171556bdca inherit pub_methods_class_teardown_notifier"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:afc05f0790c0f3e3bdebbcb171556bdca inherit pub_methods_class_teardown_notifier"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_teardown_notifier.html#afc05f0790c0f3e3bdebbcb171556bdca">AddTeardownListener</a> (Fx &amp;&amp;listener)</td></tr>
<tr class="memdesc:afc05f0790c0f3e3bdebbcb171556bdca inherit pub_methods_class_teardown_notifier"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the passed listener to be called when teardown is occurring for this object  <a href="#afc05f0790c0f3e3bdebbcb171556bdca">More...</a><br /></td></tr>
<tr class="separator:afc05f0790c0f3e3bdebbcb171556bdca inherit pub_methods_class_teardown_notifier"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a7a74b561dd828ffda294601c5a552f05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a74b561dd828ffda294601c5a552f05"></a>
typedef std::unordered_map&lt; <a class="el" href="struct_decoration_key.html">DecorationKey</a>, <a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>t_decorationMap</b></td></tr>
<tr class="separator:a7a74b561dd828ffda294601c5a552f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3b36a8b61f6c8a6d37c76a13292d1bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a3b36a8b61f6c8a6d37c76a13292d1bdb">DecorateImmediateUnsafe</a> (const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;key, const void *pvImmed)</td></tr>
<tr class="memdesc:a3b36a8b61f6c8a6d37c76a13292d1bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks out the decoration named by the specified type information and attaches the specified immediate pointer to it  <a href="#a3b36a8b61f6c8a6d37c76a13292d1bdb">More...</a><br /></td></tr>
<tr class="separator:a3b36a8b61f6c8a6d37c76a13292d1bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f3ad679665c5013e8e9daa85909ab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ae0f3ad679665c5013e8e9daa85909ab4">AddSatCounter</a> (<a class="el" href="struct_sat_counter.html">SatCounter</a> &amp;satCounter)</td></tr>
<tr class="memdesc:ae0f3ad679665c5013e8e9daa85909ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all AutoFilter argument information for a recipient  <a href="#ae0f3ad679665c5013e8e9daa85909ab4">More...</a><br /></td></tr>
<tr class="separator:ae0f3ad679665c5013e8e9daa85909ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869ced7b173bef150666505d734dd9e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a869ced7b173bef150666505d734dd9e8">RemoveSatCounter</a> (const <a class="el" href="struct_sat_counter.html">SatCounter</a> &amp;satCounter)</td></tr>
<tr class="memdesc:a869ced7b173bef150666505d734dd9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all AutoFilter argument information for a recipient  <a href="#a869ced7b173bef150666505d734dd9e8">More...</a><br /></td></tr>
<tr class="separator:a869ced7b173bef150666505d734dd9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f7dcf03fe916c5566ca61afcc19782"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a29f7dcf03fe916c5566ca61afcc19782">MarkUnsatisfiable</a> (const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;key)</td></tr>
<tr class="memdesc:a29f7dcf03fe916c5566ca61afcc19782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the specified entry as being unsatisfiable  <a href="#a29f7dcf03fe916c5566ca61afcc19782">More...</a><br /></td></tr>
<tr class="separator:a29f7dcf03fe916c5566ca61afcc19782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bf152b18a9e20c701661706fcce9c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a64bf152b18a9e20c701661706fcce9c9">MarkSuccessorsUnsatisfiable</a> (<a class="el" href="struct_decoration_key.html">DecorationKey</a> type)</td></tr>
<tr class="memdesc:a64bf152b18a9e20c701661706fcce9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks timeshifted decorations on successor packets as unsatisfiable  <a href="#a64bf152b18a9e20c701661706fcce9c9">More...</a><br /></td></tr>
<tr class="separator:a64bf152b18a9e20c701661706fcce9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd63ec1de0c74d9e20889983b700db03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#afd63ec1de0c74d9e20889983b700db03">UpdateSatisfaction</a> (const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;info)</td></tr>
<tr class="memdesc:afd63ec1de0c74d9e20889983b700db03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates subscriber statuses given that the specified type information has been satisfied  <a href="#afd63ec1de0c74d9e20889983b700db03">More...</a><br /></td></tr>
<tr class="separator:afd63ec1de0c74d9e20889983b700db03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90a9d17516b284059a0f30249656d56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aa90a9d17516b284059a0f30249656d56">PulseSatisfaction</a> (<a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a> *pTypeSubs[], size_t nInfos)</td></tr>
<tr class="memdesc:aa90a9d17516b284059a0f30249656d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a "satisfaction pulse", which will avoid notifying any deferred filters  <a href="#aa90a9d17516b284059a0f30249656d56">More...</a><br /></td></tr>
<tr class="separator:aa90a9d17516b284059a0f30249656d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0758dc93f396121900cc5de17f46dcbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a0758dc93f396121900cc5de17f46dcbf">HasUnsafe</a> (const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;key) const </td></tr>
<tr class="memdesc:a0758dc93f396121900cc5de17f46dcbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsynchronized runtime counterpart to Has <a href="#a0758dc93f396121900cc5de17f46dcbf">More...</a><br /></td></tr>
<tr class="separator:a0758dc93f396121900cc5de17f46dcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5f39ae8ecf04fe0e2d5f0d462e5ea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a1d5f39ae8ecf04fe0e2d5f0d462e5ea4">DecorateUnsafeNoPriors</a> (const <a class="el" href="struct_any_shared_pointer.html">AnySharedPointer</a> &amp;ptr, const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;key)</td></tr>
<tr class="memdesc:a1d5f39ae8ecf04fe0e2d5f0d462e5ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a decoration operation but does not attach priors to successors.  <a href="#a1d5f39ae8ecf04fe0e2d5f0d462e5ea4">More...</a><br /></td></tr>
<tr class="separator:a1d5f39ae8ecf04fe0e2d5f0d462e5ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cab6182ed3149b78b023a303467d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a58cab6182ed3149b78b023a303467d39">Decorate</a> (const <a class="el" href="struct_any_shared_pointer.html">AnySharedPointer</a> &amp;ptr, <a class="el" href="struct_decoration_key.html">DecorationKey</a> key)</td></tr>
<tr class="memdesc:a58cab6182ed3149b78b023a303467d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime counterpart to Decorate <a href="#a58cab6182ed3149b78b023a303467d39">More...</a><br /></td></tr>
<tr class="separator:a58cab6182ed3149b78b023a303467d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbabcc26a87524dbd833390d6dff5f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a0dbabcc26a87524dbd833390d6dff5f3">UnsafeComplete</a> (const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;data)</td></tr>
<tr class="memdesc:a0dbabcc26a87524dbd833390d6dff5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked from a checkout when a checkout has completed  <a href="#a0dbabcc26a87524dbd833390d6dff5f3">More...</a><br /></td></tr>
<tr class="separator:a0dbabcc26a87524dbd833390d6dff5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540c67c32e4975180741b0c5a1a3721f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a540c67c32e4975180741b0c5a1a3721f">SuccessorUnsafe</a> (void)</td></tr>
<tr class="memdesc:a540c67c32e4975180741b0c5a1a3721f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The portion of Successor that must run under a lock  <a href="#a540c67c32e4975180741b0c5a1a3721f">More...</a><br /></td></tr>
<tr class="separator:a540c67c32e4975180741b0c5a1a3721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ee60bdebcff2da1929c496b1b0bee1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a95ee60bdebcff2da1929c496b1b0bee1">GetDisposition</a> (const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;ti) const </td></tr>
<tr class="memdesc:a95ee60bdebcff2da1929c496b1b0bee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the decoration disposition corresponding to some type  <a href="#a95ee60bdebcff2da1929c496b1b0bee1">More...</a><br /></td></tr>
<tr class="separator:a95ee60bdebcff2da1929c496b1b0bee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520b94e0c318d3fb57b921aa4c0fe55d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a520b94e0c318d3fb57b921aa4c0fe55d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a520b94e0c318d3fb57b921aa4c0fe55d">HasSubscribers</a> (const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;key) const </td></tr>
<tr class="memdesc:a520b94e0c318d3fb57b921aa4c0fe55d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>True if the indicated type has been requested for use by some consumer</dd></dl>
<br /></td></tr>
<tr class="separator:a520b94e0c318d3fb57b921aa4c0fe55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82afbe50176be895f7216683e196ef92"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_sat_counter.html">SatCounter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a82afbe50176be895f7216683e196ef92">GetSatisfaction</a> (const std::type_info &amp;subscriber) const </td></tr>
<tr class="separator:a82afbe50176be895f7216683e196ef92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e33e413771c6a5db3e95b383be01ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2e33e413771c6a5db3e95b383be01ce"></a>
std::list&lt; <a class="el" href="struct_sat_counter.html">SatCounter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aa2e33e413771c6a5db3e95b383be01ce">GetSubscribers</a> (const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;key) const </td></tr>
<tr class="memdesc:aa2e33e413771c6a5db3e95b383be01ce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>All subscribers to the specified data</dd></dl>
<br /></td></tr>
<tr class="separator:aa2e33e413771c6a5db3e95b383be01ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ef8e3e2abfbdab636a44fb666a5031"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ad8ef8e3e2abfbdab636a44fb666a5031">GetDispositions</a> (const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;key) const </td></tr>
<tr class="separator:ad8ef8e3e2abfbdab636a44fb666a5031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_teardown_notifier"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_teardown_notifier')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_teardown_notifier.html">TeardownNotifier</a></td></tr>
<tr class="memitem:af64030a83f068f3aed13ad374932f239 inherit pro_methods_class_teardown_notifier"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teardown_notifier.html#af64030a83f068f3aed13ad374932f239">NotifyTeardownListeners</a> (void)</td></tr>
<tr class="memdesc:af64030a83f068f3aed13ad374932f239 inherit pro_methods_class_teardown_notifier"><td class="mdescLeft">&#160;</td><td class="mdescRight">May be invoked prospectively by a derived instance to prematurely notify teardown listeners  <a href="#af64030a83f068f3aed13ad374932f239">More...</a><br /></td></tr>
<tr class="separator:af64030a83f068f3aed13ad374932f239 inherit pro_methods_class_teardown_notifier"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4c8efaaec332e201f8fb493df2d2fc inherit pro_methods_class_teardown_notifier"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_teardown_notifier.html#abc4c8efaaec332e201f8fb493df2d2fc">AddTeardownListenerInternal</a> (<a class="el" href="struct_teardown_notifier_1_1_entry_base.html">EntryBase</a> *listener)</td></tr>
<tr class="memdesc:abc4c8efaaec332e201f8fb493df2d2fc inherit pro_methods_class_teardown_notifier"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime version of AddTeardownListener  <a href="#abc4c8efaaec332e201f8fb493df2d2fc">More...</a><br /></td></tr>
<tr class="separator:abc4c8efaaec332e201f8fb493df2d2fc inherit pro_methods_class_teardown_notifier"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a86abd368d9425cf5ef2b942884b3a1b5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a86abd368d9425cf5ef2b942884b3a1b5">ThrowNotDecoratedException</a> (const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;key)</td></tr>
<tr class="memdesc:a86abd368d9425cf5ef2b942884b3a1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a formatted runtime error corresponding to the case where an absent decoration was demanded  <a href="#a86abd368d9425cf5ef2b942884b3a1b5">More...</a><br /></td></tr>
<tr class="separator:a86abd368d9425cf5ef2b942884b3a1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1ffb7e14e468a83d6cfbcd8fee995afb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ffb7e14e468a83d6cfbcd8fee995afb"></a>
const std::shared_ptr&lt; <a class="el" href="class_auto_packet_factory.html">AutoPacketFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_parentFactory</b></td></tr>
<tr class="separator:a1ffb7e14e468a83d6cfbcd8fee995afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48aaf0b65dcd5f1dc02331d53e07e7b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48aaf0b65dcd5f1dc02331d53e07e7b1"></a>
std::shared_ptr&lt; <a class="el" href="class_auto_packet_internal.html">AutoPacketInternal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_successor</b></td></tr>
<tr class="separator:a48aaf0b65dcd5f1dc02331d53e07e7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da3777d62ec9bc47130a8a41cf7db0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9da3777d62ec9bc47130a8a41cf7db0d"></a>
std::chrono::high_resolution_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><b>m_initTime</b></td></tr>
<tr class="separator:a9da3777d62ec9bc47130a8a41cf7db0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27c1251818d3d4526450632c3dc86ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae27c1251818d3d4526450632c3dc86ab"></a>
const std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_outstanding</b></td></tr>
<tr class="separator:ae27c1251818d3d4526450632c3dc86ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e58292f4ea97eaf10c861d43c166fd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e58292f4ea97eaf10c861d43c166fd9"></a>
std::list&lt; <a class="el" href="struct_sat_counter.html">SatCounter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_satCounters</b></td></tr>
<tr class="separator:a6e58292f4ea97eaf10c861d43c166fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe322933fa23a85589c44dc085e9b18c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe322933fa23a85589c44dc085e9b18c"></a>
t_decorationMap&#160;</td><td class="memItemRight" valign="bottom"><b>m_decorations</b></td></tr>
<tr class="separator:abe322933fa23a85589c44dc085e9b18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1233ed20667fdb0a410bfffd330b0ce7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1233ed20667fdb0a410bfffd330b0ce7"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>m_lock</b></td></tr>
<tr class="separator:a1233ed20667fdb0a410bfffd330b0ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_teardown_notifier"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_teardown_notifier')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_teardown_notifier.html">TeardownNotifier</a></td></tr>
<tr class="memitem:a22ae6bc94ba1db7b31fbc2b687f5494c inherit pro_attribs_class_teardown_notifier"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22ae6bc94ba1db7b31fbc2b687f5494c"></a>
<a class="el" href="struct_teardown_notifier_1_1_entry_base.html">EntryBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_pFirstTeardownListener</b></td></tr>
<tr class="separator:a22ae6bc94ba1db7b31fbc2b687f5494c inherit pro_attribs_class_teardown_notifier"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A decorator-style processing packet </p>
<p>A processing packet may be decorated with additional types as desired by the user. The pipeline packet is not a type of context; querying the packet for an element of a particular type will look for an element of precisely that type, not an inherited type or a related interface.</p>
<p>Consumers who wish to advertise a particular field under multiple types must do so manually with the Advertise function. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad62311d54b21229bfce44bee6442ace9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_auto_packet_1_1_recipient.html">AutoPacket::Recipient</a> AutoPacket::AddRecipient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_auto_filter_descriptor.html">AutoFilterDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>descriptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a recipient for data associated only with this issuance of the packet. </p>
<p>This method is not idempotent. The returned <a class="el" href="struct_auto_packet_1_1_recipient.html">Recipient</a> structure may be used to remove the recipient safely at any point. The caller MUST NOT attempt </p>

</div>
</div>
<a class="anchor" id="ae0f3ad679665c5013e8e9daa85909ab4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::AddSatCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sat_counter.html">SatCounter</a> &amp;&#160;</td>
          <td class="paramname"><em>satCounter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all AutoFilter argument information for a recipient </p>

</div>
</div>
<a class="anchor" id="a58cab6182ed3149b78b023a303467d39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_any_shared_pointer.html">AnySharedPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_decoration_key.html">DecorationKey</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runtime counterpart to Decorate</p>

</div>
</div>
<a class="anchor" id="a828d9a72ac228f36087723cca4f93e13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decorates this packet with a particular type </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the internally persisted object</dd></dl>
<p>The Decorate method is unconditional and will install the passed value regardless of whether any subscribers exist. </p>

</div>
</div>
<a class="anchor" id="a4488588d00ac475ae3e9a0e079961774"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decoration method specialized for shared pointer types </p>
<p>This decoration method has the additional benefit that it will make direct use of the passed shared pointer. </p>
<p>Injunction to prevent existential loops: </p>

</div>
</div>
<a class="anchor" id="ac016b40fd64cf3e9df03627de240448a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::DecorateImmediate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>immed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>immeds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribers respond to the decoration arguments immediately or never for this packet. Optional argument resolution is forced for any subscriber requiring at least one argument of this method </p>
<p>Unlike Decorate, the arguments of DecorateImmediate are not copied. Each decoration is only valid for AutoFilters which are valid during this call. If multiple values are specified, all will be simultaneously made valid and then invalidated. </p>

</div>
</div>
<a class="anchor" id="a3b36a8b61f6c8a6d37c76a13292d1bdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a> &amp; AutoPacket::DecorateImmediateUnsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvImmed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks out the decoration named by the specified type information and attaches the specified immediate pointer to it </p>
<p>An immediate checkout differs from a standard checkout in that the internally held decoration is only temporarily available. Thus, callers are either satisfied at the point of decoration, or will not be satisfied for that type. </p>

</div>
</div>
<a class="anchor" id="a1d5f39ae8ecf04fe0e2d5f0d462e5ea4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::DecorateUnsafeNoPriors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_any_shared_pointer.html">AnySharedPointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a decoration operation but does not attach priors to successors. </p>

</div>
</div>
<a class="anchor" id="a664edd114a9489c90020ed3467cc9642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::ForwardAll </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt;&#160;</td>
          <td class="paramname"><em>recipient</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shares all broadcast data from this packet with the recipient packet</p>
<p>This method should ONLY be called during the final-call sequence. This method is expected to be used to bridge data to a sibling context. Therefore, only broadcast data will be shared, since pipes between sibling contexts cannot be defined. Furthermore, types that are unsatisfied in this context will not be marked as unsatisfied in the recipient - only present data will be provided. </p>

</div>
</div>
<a class="anchor" id="afc2ea2311961fd3e9f92c6b5dc40887d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects the desired type, or throws an exception if such a type cannot be found </p>

</div>
</div>
<a class="anchor" id="a43cde58980c81a1c47cd683dd820ff2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">const T *&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this pipeline packet contains an entry of the specified type </p>
<p>This method is also used by DecorateImmediate to extract pointers to data that is valid ONLY during recursive satisfaction calls. </p>

</div>
</div>
<a class="anchor" id="aedfb2068e9ff2f88e632a74259745b5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const T &gt; *&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared pointer specialization of const T*&amp;, used to obtain the underlying shared pointer for some type T </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tshift</td><td>The number back to retrieve</td></tr>
  </table>
  </dd>
</dl>
<p>This specialization cannot be used to obtain a decoration which has been attached to this packet via DecorateImmediate. </p>

</div>
</div>
<a class="anchor" id="a434994156ef4debce252bb124ba2d5e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared pointer specialization, used to obtain the underlying shared pointer for some type T </p>
<p>This method can return an argument of DecorateImmediate as a shared_ptr&lt;T&gt; without a deleter. PROBLEM: This use case implies that holding shared_ptr references to decorations is NOT SAFE. </p>

</div>
</div>
<a class="anchor" id="a95ee60bdebcff2da1929c496b1b0bee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a> * AutoPacket::GetDisposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the decoration disposition corresponding to some type </p>
<dl class="section return"><dt>Returns</dt><dd>The disposition, if the decoration exists and is satisfied, otherwise nullptr</dd></dl>

</div>
</div>
<a class="anchor" id="ad8ef8e3e2abfbdab636a44fb666a5031"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a> &gt; AutoPacket::GetDispositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>All decoration dispositions associated with the data type</dd></dl>
<p>This method is useful for determining whether flow conditions (broadcast, pipes immediate decorations) resulted in missed data. </p>

</div>
</div>
<a class="anchor" id="a16660e7ea8af64b3e3c4a30e957961f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a> &gt; AutoPacket::GetDispositions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>All decoration dispositions</dd></dl>
<p>This method is useful for getting a picture of the entire disposition graph </p>

</div>
</div>
<a class="anchor" id="a8b1727aa9cf3f70d55bf8dcbcd40ae77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a>&gt; AutoPacket::GetDispositions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>All decoration dispositions associated with the data type</dd></dl>
<p>This method is useful for determining whether flow conditions (broadcast, pipes immediate decorations) resulted in missed data. </p>

</div>
</div>
<a class="anchor" id="a82afbe50176be895f7216683e196ef92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_sat_counter.html">SatCounter</a> &amp; AutoPacket::GetSatisfaction </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>subscriber</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A reference to the satisfaction counter for the specified type</dd></dl>
<p>If the type is not a subscriber <a class="el" href="class_auto_packet.html#a1e8152052798e49283c8297886c62ffe">GetSatisfaction()</a>.GetType() == nullptr will be true </p>

</div>
</div>
<a class="anchor" id="a1e8152052798e49283c8297886c62ffe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_sat_counter.html">SatCounter</a>&amp; AutoPacket::GetSatisfaction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A reference to the satisfaction counter for the specified type</dd></dl>
<p>If the type is not a subscriber <a class="el" href="class_auto_packet.html#a1e8152052798e49283c8297886c62ffe">GetSatisfaction()</a>.GetType() == nullptr will be true </p>

</div>
</div>
<a class="anchor" id="a749ec811977357ea7165b8e77be65932"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Has </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this packet posesses a decoration of the specified type </dd></dl>
<p>Although "AutoPacket &amp;" and "const AutoPacket&amp;" argument types will be satisfied, the <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> does not "have" these types. </p>

</div>
</div>
<a class="anchor" id="a0758dc93f396121900cc5de17f46dcbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::HasUnsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsynchronized runtime counterpart to Has</p>

</div>
</div>
<a class="anchor" id="a64bf152b18a9e20c701661706fcce9c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::MarkSuccessorsUnsatisfiable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_decoration_key.html">DecorationKey</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks timeshifted decorations on successor packets as unsatisfiable </p>

</div>
</div>
<a class="anchor" id="a29f7dcf03fe916c5566ca61afcc19782"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::MarkUnsatisfiable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the specified entry as being unsatisfiable </p>

</div>
</div>
<a class="anchor" id="a2386a188fa820b5ae4de667110dabc05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_auto_packet_1_1_recipient.html">Recipient</a> AutoPacket::operator+= </td>
          <td>(</td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience overload, identical in behavior to AddRecipient </p>

</div>
</div>
<a class="anchor" id="a420bcbfa461af904ecbdaef771f9f702"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_auto_packet.html">AutoPacket</a> &amp; AutoPacket::operator+= </td>
          <td>(</td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience overload, provided to allow the attachment of receive-only filters to a const <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> </p>

</div>
</div>
<a class="anchor" id="aa90a9d17516b284059a0f30249656d56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::PulseSatisfaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_decoration_disposition.html">DecorationDisposition</a> *&#160;</td>
          <td class="paramname"><em>pTypeSubs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInfos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a "satisfaction pulse", which will avoid notifying any deferred filters </p>
<p>A satisfaction pulse will call any AutoFilter instances which are satisfied by the decoration of the passed decoration types. Such filters will be called even if some optional inputs remain outstanding. </p>

</div>
</div>
<a class="anchor" id="a139f7015e781a094f43c9a30051d8b3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Put </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-templated placement method </p>

</div>
</div>
<a class="anchor" id="a88913247c596018f77b29f2de9e2cd73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Put </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfers ownership of argument to <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> </p>
<p>This method may throw an exception. Ownership is unconditionally transferred to this class even in the event an exception is thrown, thus the passed pointer is guaranteed to be cleaned up properly in all cases. </p>

</div>
</div>
<a class="anchor" id="a68e83b2de56c678b5d5c6e2933fcfad6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Put </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shares ownership of argument with <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> </p>
<p>This can be used to:</p><ul>
<li>place data on the AutoPack from an <a class="el" href="class_object_pool.html" title="Allows the management of a pool of objects based on an embedded factory. ">ObjectPool</a></li>
<li>move data from one <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> to another without copying</li>
<li>alias the type of a decoration on <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="ad2d83c084026aa7a19a20335bcab44c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::RemoveRecipient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_auto_packet_1_1_recipient.html">Recipient</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>recipient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a previously added packet recipient </p>

</div>
</div>
<a class="anchor" id="a869ced7b173bef150666505d734dd9e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::RemoveSatCounter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sat_counter.html">SatCounter</a> &amp;&#160;</td>
          <td class="paramname"><em>satCounter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all AutoFilter argument information for a recipient </p>

</div>
</div>
<a class="anchor" id="a0f242a08b6a3d900039309f031d17e8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt; AutoPacket::Successor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next packet that will be issued by the packet factory in this context relative to this context </p>

</div>
</div>
<a class="anchor" id="a540c67c32e4975180741b0c5a1a3721f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt; AutoPacket::SuccessorUnsafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The portion of Successor that must run under a lock </p>

</div>
</div>
<a class="anchor" id="a86abd368d9425cf5ef2b942884b3a1b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::ThrowNotDecoratedException </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws a formatted runtime error corresponding to the case where an absent decoration was demanded </p>

</div>
</div>
<a class="anchor" id="a0dbabcc26a87524dbd833390d6dff5f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::UnsafeComplete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked from a checkout when a checkout has completed </p>

</div>
</div>
<a class="anchor" id="a2b9788e64105fee4f967e53871c4d93b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Unsatisfiable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the named decoration as unsatisfiable </p>
<p>Marking a decoration as unsatisfiable immediately causes any filters with an optional input on this type to be called, if the remainder of their inputs are available. </p>

</div>
</div>
<a class="anchor" id="afd63ec1de0c74d9e20889983b700db03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::UpdateSatisfaction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_decoration_key.html">DecorationKey</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates subscriber statuses given that the specified type information has been satisfied </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The decoration which was just added to this packet</td></tr>
  </table>
  </dd>
</dl>
<p>This method results in a call to the AutoFilter method on any subscribers which are satisfied by this decoration. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>autowiring/<a class="el" href="_auto_packet_8h_source.html">AutoPacket.h</a></li>
<li>src/autowiring/AutoPacket.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 19 2015 11:57:29 for Autowiring by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
