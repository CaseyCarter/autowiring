<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Autowiring: AutoPacket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.5.4</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Developer's&#160;Guide</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_auto_packet.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="class_auto_packet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AutoPacket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A decorator-style processing packet  
 <a href="class_auto_packet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_auto_packet_8h_source.html">AutoPacket.h</a>&gt;</code></p>

<p>Inherits enable_shared_from_this&lt; AutoPacket &gt;, and TeardownNotifier.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a125a001b0cfb8f5bfca5cac6b291e2a9"><td class="memItemLeft" align="right" valign="top">const SatCounter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a125a001b0cfb8f5bfca5cac6b291e2a9">AddRecipient</a> (const AutoFilterDescriptor &amp;descriptor)</td></tr>
<tr class="memdesc:a125a001b0cfb8f5bfca5cac6b291e2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a recipient for data associated only with this issuance of the packet.  <a href="#a125a001b0cfb8f5bfca5cac6b291e2a9">More...</a><br /></td></tr>
<tr class="separator:a125a001b0cfb8f5bfca5cac6b291e2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828d9a72ac228f36087723cca4f93e13"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a828d9a72ac228f36087723cca4f93e13"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a828d9a72ac228f36087723cca4f93e13">Decorate</a> (T t)</td></tr>
<tr class="memdesc:a828d9a72ac228f36087723cca4f93e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorates this packet with a particular type  <a href="#a828d9a72ac228f36087723cca4f93e13">More...</a><br /></td></tr>
<tr class="separator:a828d9a72ac228f36087723cca4f93e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d46044bc68b565aa3772c67d961dea"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a92d46044bc68b565aa3772c67d961dea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a92d46044bc68b565aa3772c67d961dea">Decorate</a> (std::shared_ptr&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a92d46044bc68b565aa3772c67d961dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decoration method specialized for shared pointer types  <a href="#a92d46044bc68b565aa3772c67d961dea">More...</a><br /></td></tr>
<tr class="separator:a92d46044bc68b565aa3772c67d961dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e991ef12c4ca95d8c87c98442405f9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a73e991ef12c4ca95d8c87c98442405f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a73e991ef12c4ca95d8c87c98442405f9">Decorate</a> (std::shared_ptr&lt; const T &gt; ptr)</td></tr>
<tr class="memdesc:a73e991ef12c4ca95d8c87c98442405f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decoration method specialized for const shared pointer types  <a href="#a73e991ef12c4ca95d8c87c98442405f9">More...</a><br /></td></tr>
<tr class="separator:a73e991ef12c4ca95d8c87c98442405f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac016b40fd64cf3e9df03627de240448a"><td class="memTemplParams" colspan="2">template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:ac016b40fd64cf3e9df03627de240448a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ac016b40fd64cf3e9df03627de240448a">DecorateImmediate</a> (const T &amp;immed, const Ts &amp;...immeds)</td></tr>
<tr class="memdesc:ac016b40fd64cf3e9df03627de240448a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribers respond to the decoration arguments immediately or never for this packet. Optional argument resolution is forced for any subscriber requiring at least one argument of this method  <a href="#ac016b40fd64cf3e9df03627de240448a">More...</a><br /></td></tr>
<tr class="separator:ac016b40fd64cf3e9df03627de240448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664edd114a9489c90020ed3467cc9642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a664edd114a9489c90020ed3467cc9642">ForwardAll</a> (std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt; recipient) const </td></tr>
<tr class="memdesc:a664edd114a9489c90020ed3467cc9642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shares all broadcast data from this packet with the recipient packet <a href="#a664edd114a9489c90020ed3467cc9642">More...</a><br /></td></tr>
<tr class="separator:a664edd114a9489c90020ed3467cc9642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2ea2311961fd3e9f92c6b5dc40887d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afc2ea2311961fd3e9f92c6b5dc40887d"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#afc2ea2311961fd3e9f92c6b5dc40887d">Get</a> (int tshift=0) const </td></tr>
<tr class="memdesc:afc2ea2311961fd3e9f92c6b5dc40887d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects the desired type, or throws an exception if such a type cannot be found  <a href="#afc2ea2311961fd3e9f92c6b5dc40887d">More...</a><br /></td></tr>
<tr class="separator:afc2ea2311961fd3e9f92c6b5dc40887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cde58980c81a1c47cd683dd820ff2b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a43cde58980c81a1c47cd683dd820ff2b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a43cde58980c81a1c47cd683dd820ff2b">Get</a> (const T *&amp;out, int tshift=0) const </td></tr>
<tr class="memdesc:a43cde58980c81a1c47cd683dd820ff2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this pipeline packet contains an entry of the specified type  <a href="#a43cde58980c81a1c47cd683dd820ff2b">More...</a><br /></td></tr>
<tr class="separator:a43cde58980c81a1c47cd683dd820ff2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfb2068e9ff2f88e632a74259745b5d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aedfb2068e9ff2f88e632a74259745b5d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aedfb2068e9ff2f88e632a74259745b5d">Get</a> (const std::shared_ptr&lt; const T &gt; *&amp;out, int tshift=0) const </td></tr>
<tr class="memdesc:aedfb2068e9ff2f88e632a74259745b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer specialization of const T*&amp;, used to obtain the underlying shared pointer for some type T  <a href="#aedfb2068e9ff2f88e632a74259745b5d">More...</a><br /></td></tr>
<tr class="separator:aedfb2068e9ff2f88e632a74259745b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434994156ef4debce252bb124ba2d5e7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a434994156ef4debce252bb124ba2d5e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a434994156ef4debce252bb124ba2d5e7">Get</a> (std::shared_ptr&lt; const T &gt; &amp;out, int tshift=0) const </td></tr>
<tr class="memdesc:a434994156ef4debce252bb124ba2d5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer specialization, used to obtain the underlying shared pointer for some type T  <a href="#a434994156ef4debce252bb124ba2d5e7">More...</a><br /></td></tr>
<tr class="separator:a434994156ef4debce252bb124ba2d5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6f7ada47b79a2767051b65430595a8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aea6f7ada47b79a2767051b65430595a8"><td class="memTemplItemLeft" align="right" valign="top">const T **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aea6f7ada47b79a2767051b65430595a8">GetAll</a> (int tshift=0) const </td></tr>
<tr class="memdesc:aea6f7ada47b79a2767051b65430595a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a null-terminated temporary buffer containing all decorations  <a href="#aea6f7ada47b79a2767051b65430595a8">More...</a><br /></td></tr>
<tr class="separator:aea6f7ada47b79a2767051b65430595a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab194d4255c47b1d85d9b8b27a14f3f07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab194d4255c47b1d85d9b8b27a14f3f07"></a>
std::shared_ptr&lt; <a class="el" href="class_core_context.html">CoreContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ab194d4255c47b1d85d9b8b27a14f3f07">GetContext</a> (void) const </td></tr>
<tr class="memdesc:ab194d4255c47b1d85d9b8b27a14f3f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context of this packet (The context of the <a class="el" href="class_auto_packet_factory.html" title="A configurable factory class for pipeline packets with a built-in object pool ">AutoPacketFactory</a> that created this context) <br /></td></tr>
<tr class="separator:ab194d4255c47b1d85d9b8b27a14f3f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1235227e171d7229b72d3901e6d1042"><td class="memItemLeft" align="right" valign="top">t_decorationMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aa1235227e171d7229b72d3901e6d1042">GetDecorations</a> (void) const </td></tr>
<tr class="memdesc:aa1235227e171d7229b72d3901e6d1042"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>A copy of the decoration dispositions collection </dd></dl>
 <a href="#aa1235227e171d7229b72d3901e6d1042">More...</a><br /></td></tr>
<tr class="separator:aa1235227e171d7229b72d3901e6d1042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad162cefce3bd9980fa2984c29f2a2517"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad162cefce3bd9980fa2984c29f2a2517"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ad162cefce3bd9980fa2984c29f2a2517">GetDecorationTypeCount</a> (void) const </td></tr>
<tr class="memdesc:ad162cefce3bd9980fa2984c29f2a2517"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>The number of distinct decoration types on this packet </dd></dl>
<br /></td></tr>
<tr class="separator:ad162cefce3bd9980fa2984c29f2a2517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8152052798e49283c8297886c62ffe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1e8152052798e49283c8297886c62ffe"><td class="memTemplItemLeft" align="right" valign="top">const SatCounter &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a1e8152052798e49283c8297886c62ffe">GetSatisfaction</a> (void) const </td></tr>
<tr class="memdesc:a1e8152052798e49283c8297886c62ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>A reference to the satisfaction counter for the specified type</dd></dl>
 <a href="#a1e8152052798e49283c8297886c62ffe">More...</a><br /></td></tr>
<tr class="separator:a1e8152052798e49283c8297886c62ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5467f83887d63a602cb05d88c6893bc0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5467f83887d63a602cb05d88c6893bc0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5467f83887d63a602cb05d88c6893bc0"><td class="memTemplItemLeft" align="right" valign="top">const std::shared_ptr&lt; const T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a5467f83887d63a602cb05d88c6893bc0">GetShared</a> (int tshift=0) const </td></tr>
<tr class="memdesc:a5467f83887d63a602cb05d88c6893bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>The shared pointer decoration for the specified type and time shift, or nullptr if no such decoration exists </dd></dl>
<br /></td></tr>
<tr class="separator:a5467f83887d63a602cb05d88c6893bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749ec811977357ea7165b8e77be65932"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a749ec811977357ea7165b8e77be65932"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a749ec811977357ea7165b8e77be65932">Has</a> (int tshift=0) const </td></tr>
<tr class="memdesc:a749ec811977357ea7165b8e77be65932"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>True if this packet posesses a decoration of the specified type </dd></dl>
 <a href="#a749ec811977357ea7165b8e77be65932">More...</a><br /></td></tr>
<tr class="separator:a749ec811977357ea7165b8e77be65932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af6d953ba5968fffd20cb736ad0cbc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a76af6d953ba5968fffd20cb736ad0cbc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a76af6d953ba5968fffd20cb736ad0cbc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a76af6d953ba5968fffd20cb736ad0cbc">HasSubscribers</a> (void) const </td></tr>
<tr class="memdesc:a76af6d953ba5968fffd20cb736ad0cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>True if the indicated type has been requested for use by some consumer</dd></dl>
<br /></td></tr>
<tr class="separator:a76af6d953ba5968fffd20cb736ad0cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa96738dac77521d123698ad3f80a35"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a3fa96738dac77521d123698ad3f80a35"><td class="memTemplItemLeft" align="right" valign="top">const SatCounter *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a3fa96738dac77521d123698ad3f80a35">operator+=</a> (Fx &amp;&amp;fx)</td></tr>
<tr class="memdesc:a3fa96738dac77521d123698ad3f80a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload, identical in behavior to AddRecipient  <a href="#a3fa96738dac77521d123698ad3f80a35">More...</a><br /></td></tr>
<tr class="separator:a3fa96738dac77521d123698ad3f80a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a84b4131245539806ff5a7738f04f3"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:a30a84b4131245539806ff5a7738f04f3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_auto_packet.html">AutoPacket</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a30a84b4131245539806ff5a7738f04f3">operator+=</a> (Fx &amp;&amp;fx) const </td></tr>
<tr class="memdesc:a30a84b4131245539806ff5a7738f04f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload, provided to allow the attachment of receive-only filters to a const <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a>  <a href="#a30a84b4131245539806ff5a7738f04f3">More...</a><br /></td></tr>
<tr class="separator:a30a84b4131245539806ff5a7738f04f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa302c91a39594f5ea0f58094ce4fea3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aa302c91a39594f5ea0f58094ce4fea3a">RemoveRecipient</a> (const SatCounter &amp;recipient)</td></tr>
<tr class="memdesc:aa302c91a39594f5ea0f58094ce4fea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added packet recipient  <a href="#aa302c91a39594f5ea0f58094ce4fea3a">More...</a><br /></td></tr>
<tr class="separator:aa302c91a39594f5ea0f58094ce4fea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e7dd1ee400c313c05d56d7642a0c87"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a99e7dd1ee400c313c05d56d7642a0c87">Successor</a> (void)</td></tr>
<tr class="memdesc:a99e7dd1ee400c313c05d56d7642a0c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next packet that will be issued by the packet factory in this context relative to this context  <a href="#a99e7dd1ee400c313c05d56d7642a0c87">More...</a><br /></td></tr>
<tr class="separator:a99e7dd1ee400c313c05d56d7642a0c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9788e64105fee4f967e53871c4d93b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2b9788e64105fee4f967e53871c4d93b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a2b9788e64105fee4f967e53871c4d93b">Unsatisfiable</a> (void)</td></tr>
<tr class="memdesc:a2b9788e64105fee4f967e53871c4d93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the named decoration as unsatisfiable  <a href="#a2b9788e64105fee4f967e53871c4d93b">More...</a><br /></td></tr>
<tr class="separator:a2b9788e64105fee4f967e53871c4d93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654e349d38d07225b64008a6ff0351c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a654e349d38d07225b64008a6ff0351c6">Wait</a> (std::condition_variable &amp;cv, const AutoFilterDescriptorInput *inputs, std::chrono::nanoseconds duration=std::chrono::nanoseconds::max())</td></tr>
<tr class="memdesc:a654e349d38d07225b64008a6ff0351c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until the specified descriptor is satisfied  <a href="#a654e349d38d07225b64008a6ff0351c6">More...</a><br /></td></tr>
<tr class="separator:a654e349d38d07225b64008a6ff0351c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde180a2515100943e2b33e999b7f6d3"><td class="memTemplParams" colspan="2">template&lt;class Fx &gt; </td></tr>
<tr class="memitem:adde180a2515100943e2b33e999b7f6d3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#adde180a2515100943e2b33e999b7f6d3">Wait</a> (std::condition_variable &amp;cv, Fx &amp;&amp;autoFilter, std::chrono::nanoseconds duration=std::chrono::nanoseconds::max())</td></tr>
<tr class="memdesc:adde180a2515100943e2b33e999b7f6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until the passed lambda function can be called  <a href="#adde180a2515100943e2b33e999b7f6d3">More...</a><br /></td></tr>
<tr class="separator:adde180a2515100943e2b33e999b7f6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5587ee9febad91417f6ee1f4c65d6282"><td class="memTemplParams" colspan="2">template&lt;class... Decorations&gt; </td></tr>
<tr class="memitem:a5587ee9febad91417f6ee1f4c65d6282"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a5587ee9febad91417f6ee1f4c65d6282">Wait</a> (std::condition_variable &amp;cv)</td></tr>
<tr class="memdesc:a5587ee9febad91417f6ee1f4c65d6282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delays until the specified decorations are satisfied  <a href="#a5587ee9febad91417f6ee1f4c65d6282">More...</a><br /></td></tr>
<tr class="separator:a5587ee9febad91417f6ee1f4c65d6282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8aea3ddb3ab167ec745f5f7cb6dd3a"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a0b8aea3ddb3ab167ec745f5f7cb6dd3a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a0b8aea3ddb3ab167ec745f5f7cb6dd3a">Wait</a> (std::chrono::nanoseconds duration, std::condition_variable &amp;cv)</td></tr>
<tr class="memdesc:a0b8aea3ddb3ab167ec745f5f7cb6dd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed version of Wait  <a href="#a0b8aea3ddb3ab167ec745f5f7cb6dd3a">More...</a><br /></td></tr>
<tr class="separator:a0b8aea3ddb3ab167ec745f5f7cb6dd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a684e3e0747beb2f1d052e6e46f9da931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a684e3e0747beb2f1d052e6e46f9da931">AddSatCounterUnsafe</a> (SatCounter &amp;satCounter)</td></tr>
<tr class="memdesc:a684e3e0747beb2f1d052e6e46f9da931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all AutoFilter argument information for a recipient  <a href="#a684e3e0747beb2f1d052e6e46f9da931">More...</a><br /></td></tr>
<tr class="separator:a684e3e0747beb2f1d052e6e46f9da931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cab6182ed3149b78b023a303467d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a58cab6182ed3149b78b023a303467d39">Decorate</a> (const AnySharedPointer &amp;ptr, DecorationKey key)</td></tr>
<tr class="memdesc:a58cab6182ed3149b78b023a303467d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime counterpart to Decorate <a href="#a58cab6182ed3149b78b023a303467d39">More...</a><br /></td></tr>
<tr class="separator:a58cab6182ed3149b78b023a303467d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff5b7454dc3bcfb943d74e8738efe72"><td class="memItemLeft" align="right" valign="top">DecorationDisposition &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#afff5b7454dc3bcfb943d74e8738efe72">DecorateImmediateUnsafe</a> (const DecorationKey &amp;key, const void *pvImmed)</td></tr>
<tr class="memdesc:afff5b7454dc3bcfb943d74e8738efe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks out the decoration named by the specified type information and attaches the specified immediate pointer to it  <a href="#afff5b7454dc3bcfb943d74e8738efe72">More...</a><br /></td></tr>
<tr class="separator:afff5b7454dc3bcfb943d74e8738efe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721c9e5f19dcc05c8d408901615fcea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a721c9e5f19dcc05c8d408901615fcea5">DecorateNoPriors</a> (const AnySharedPointer &amp;ptr, DecorationKey key)</td></tr>
<tr class="memdesc:a721c9e5f19dcc05c8d408901615fcea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a decoration operation but does not attach priors to successors.  <a href="#a721c9e5f19dcc05c8d408901615fcea5">More...</a><br /></td></tr>
<tr class="separator:a721c9e5f19dcc05c8d408901615fcea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ffd3b386863a7874866aa5a6b0429"><td class="memItemLeft" align="right" valign="top">const DecorationDisposition *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#af40ffd3b386863a7874866aa5a6b0429">GetDisposition</a> (const DecorationKey &amp;ti) const </td></tr>
<tr class="memdesc:af40ffd3b386863a7874866aa5a6b0429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the decoration disposition corresponding to some type  <a href="#af40ffd3b386863a7874866aa5a6b0429">More...</a><br /></td></tr>
<tr class="separator:af40ffd3b386863a7874866aa5a6b0429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367921514045be484e134b34b4d6460d"><td class="memItemLeft" align="right" valign="top">const SatCounter &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a367921514045be484e134b34b4d6460d">GetSatisfaction</a> (const std::type_info &amp;subscriber) const </td></tr>
<tr class="memdesc:a367921514045be484e134b34b4d6460d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>A reference to the satisfaction counter for the specified type</dd></dl>
 <a href="#a367921514045be484e134b34b4d6460d">More...</a><br /></td></tr>
<tr class="separator:a367921514045be484e134b34b4d6460d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520b94e0c318d3fb57b921aa4c0fe55d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a520b94e0c318d3fb57b921aa4c0fe55d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a520b94e0c318d3fb57b921aa4c0fe55d">HasSubscribers</a> (const DecorationKey &amp;key) const </td></tr>
<tr class="memdesc:a520b94e0c318d3fb57b921aa4c0fe55d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><dl class="section return"><dt>Returns</dt><dd>True if the indicated type has been requested for use by some consumer</dd></dl>
<br /></td></tr>
<tr class="separator:a520b94e0c318d3fb57b921aa4c0fe55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0758dc93f396121900cc5de17f46dcbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a0758dc93f396121900cc5de17f46dcbf">HasUnsafe</a> (const DecorationKey &amp;key) const </td></tr>
<tr class="memdesc:a0758dc93f396121900cc5de17f46dcbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsynchronized runtime counterpart to Has <a href="#a0758dc93f396121900cc5de17f46dcbf">More...</a><br /></td></tr>
<tr class="separator:a0758dc93f396121900cc5de17f46dcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bf152b18a9e20c701661706fcce9c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a64bf152b18a9e20c701661706fcce9c9">MarkSuccessorsUnsatisfiable</a> (DecorationKey type)</td></tr>
<tr class="memdesc:a64bf152b18a9e20c701661706fcce9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks timeshifted decorations on successor packets as unsatisfiable  <a href="#a64bf152b18a9e20c701661706fcce9c9">More...</a><br /></td></tr>
<tr class="separator:a64bf152b18a9e20c701661706fcce9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f7dcf03fe916c5566ca61afcc19782"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a29f7dcf03fe916c5566ca61afcc19782">MarkUnsatisfiable</a> (const DecorationKey &amp;key)</td></tr>
<tr class="memdesc:a29f7dcf03fe916c5566ca61afcc19782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the specified entry as being unsatisfiable  <a href="#a29f7dcf03fe916c5566ca61afcc19782">More...</a><br /></td></tr>
<tr class="separator:a29f7dcf03fe916c5566ca61afcc19782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90a9d17516b284059a0f30249656d56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#aa90a9d17516b284059a0f30249656d56">PulseSatisfaction</a> (DecorationDisposition *pTypeSubs[], size_t nInfos)</td></tr>
<tr class="memdesc:aa90a9d17516b284059a0f30249656d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a "satisfaction pulse", which will avoid notifying any deferred filters  <a href="#aa90a9d17516b284059a0f30249656d56">More...</a><br /></td></tr>
<tr class="separator:aa90a9d17516b284059a0f30249656d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d82f8536c4a1b847a5ba0efb9b99d6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#af7d82f8536c4a1b847a5ba0efb9b99d6">SuccessorUnsafe</a> (void)</td></tr>
<tr class="memdesc:af7d82f8536c4a1b847a5ba0efb9b99d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The portion of Successor that must run under a lock  <a href="#af7d82f8536c4a1b847a5ba0efb9b99d6">More...</a><br /></td></tr>
<tr class="separator:af7d82f8536c4a1b847a5ba0efb9b99d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbabcc26a87524dbd833390d6dff5f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a0dbabcc26a87524dbd833390d6dff5f3">UnsafeComplete</a> (const DecorationKey &amp;data)</td></tr>
<tr class="memdesc:a0dbabcc26a87524dbd833390d6dff5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked from a checkout when a checkout has completed  <a href="#a0dbabcc26a87524dbd833390d6dff5f3">More...</a><br /></td></tr>
<tr class="separator:a0dbabcc26a87524dbd833390d6dff5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112ba05a6a371322e297676d64c5358f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a112ba05a6a371322e297676d64c5358f">UpdateSatisfactionUnsafe</a> (std::unique_lock&lt; std::mutex &gt; &amp;&amp;lk, const DecorationDisposition &amp;disposition)</td></tr>
<tr class="memdesc:a112ba05a6a371322e297676d64c5358f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates subscriber statuses given that the specified type information has been satisfied  <a href="#a112ba05a6a371322e297676d64c5358f">More...</a><br /></td></tr>
<tr class="separator:a112ba05a6a371322e297676d64c5358f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a876a04e499194ec2c8960ee9aa655b0b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#a876a04e499194ec2c8960ee9aa655b0b">ThrowMultiplyDecoratedException</a> (const DecorationKey &amp;key)</td></tr>
<tr class="memdesc:a876a04e499194ec2c8960ee9aa655b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a formatted runtime error corresponding to the case where a decoration was demanded and more than one such decoration was present  <a href="#a876a04e499194ec2c8960ee9aa655b0b">More...</a><br /></td></tr>
<tr class="separator:a876a04e499194ec2c8960ee9aa655b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77d4e6ff2c9fe5fb19dcd43c91fbc57"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_packet.html#ad77d4e6ff2c9fe5fb19dcd43c91fbc57">ThrowNotDecoratedException</a> (const DecorationKey &amp;key)</td></tr>
<tr class="memdesc:ad77d4e6ff2c9fe5fb19dcd43c91fbc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a formatted runtime error corresponding to the case where an absent decoration was demanded  <a href="#ad77d4e6ff2c9fe5fb19dcd43c91fbc57">More...</a><br /></td></tr>
<tr class="separator:ad77d4e6ff2c9fe5fb19dcd43c91fbc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A decorator-style processing packet </p>
<p>A processing packet may be decorated with additional types as desired by the user. The pipeline packet is not a type of context; querying the packet for an element of a particular type will look for an element of precisely that type, not an inherited type or a related interface.</p>
<p>Consumers who wish to advertise a particular field under multiple types must do so manually with the Advertise function. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a125a001b0cfb8f5bfca5cac6b291e2a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SatCounter* AutoPacket::AddRecipient </td>
          <td>(</td>
          <td class="paramtype">const AutoFilterDescriptor &amp;&#160;</td>
          <td class="paramname"><em>descriptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a recipient for data associated only with this issuance of the packet. </p>
<p>This method is not idempotent. The returned Recipient structure may be used to remove the recipient safely at any point. The caller MUST NOT attempt </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a3fa96738dac77521d123698ad3f80a35">operator+=()</a>.</p>

</div>
</div>
<a class="anchor" id="a684e3e0747beb2f1d052e6e46f9da931"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::AddSatCounterUnsafe </td>
          <td>(</td>
          <td class="paramtype">SatCounter &amp;&#160;</td>
          <td class="paramname"><em>satCounter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all AutoFilter argument information for a recipient </p>

</div>
</div>
<a class="anchor" id="a58cab6182ed3149b78b023a303467d39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">const AnySharedPointer &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DecorationKey&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runtime counterpart to Decorate</p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a828d9a72ac228f36087723cca4f93e13">Decorate()</a>.</p>

</div>
</div>
<a class="anchor" id="a828d9a72ac228f36087723cca4f93e13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decorates this packet with a particular type </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the internally persisted object</dd></dl>
<p>The Decorate method is unconditional and will install the passed value regardless of whether any subscribers exist. </p>

</div>
</div>
<a class="anchor" id="a92d46044bc68b565aa3772c67d961dea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decoration method specialized for shared pointer types </p>
<p>This decoration method has the additional benefit that it will make direct use of the passed shared pointer.</p>
<p>If the passed value is null, the corresponding value will be marked unsatisfiable. </p>

</div>
</div>
<a class="anchor" id="a73e991ef12c4ca95d8c87c98442405f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Decorate </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decoration method specialized for const shared pointer types </p>
<p>This decoration method has the additional benefit that it will make direct use of the passed shared pointer. </p>

</div>
</div>
<a class="anchor" id="ac016b40fd64cf3e9df03627de240448a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::DecorateImmediate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>immed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>immeds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribers respond to the decoration arguments immediately or never for this packet. Optional argument resolution is forced for any subscriber requiring at least one argument of this method </p>
<p>Unlike Decorate, the arguments of DecorateImmediate are not copied. Each decoration is only valid for AutoFilters which are valid during this call. If multiple values are specified, all will be simultaneously made valid and then invalidated. </p>

</div>
</div>
<a class="anchor" id="afff5b7454dc3bcfb943d74e8738efe72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DecorationDisposition&amp; AutoPacket::DecorateImmediateUnsafe </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvImmed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks out the decoration named by the specified type information and attaches the specified immediate pointer to it </p>
<p>An immediate checkout differs from a standard checkout in that the internally held decoration is only temporarily available. Thus, callers are either satisfied at the point of decoration, or will not be satisfied for that type. </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#ac016b40fd64cf3e9df03627de240448a">DecorateImmediate()</a>.</p>

</div>
</div>
<a class="anchor" id="a721c9e5f19dcc05c8d408901615fcea5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::DecorateNoPriors </td>
          <td>(</td>
          <td class="paramtype">const AnySharedPointer &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DecorationKey&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a decoration operation but does not attach priors to successors. </p>

</div>
</div>
<a class="anchor" id="a664edd114a9489c90020ed3467cc9642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::ForwardAll </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_auto_packet.html">AutoPacket</a> &gt;&#160;</td>
          <td class="paramname"><em>recipient</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shares all broadcast data from this packet with the recipient packet</p>
<p>This method should ONLY be called during the final-call sequence. This method is expected to be used to bridge data to a sibling context. Therefore, only broadcast data will be shared, since pipes between sibling contexts cannot be defined. Furthermore, types that are unsatisfied in this context will not be marked as unsatisfied in the recipient - only present data will be provided. </p>

</div>
</div>
<a class="anchor" id="afc2ea2311961fd3e9f92c6b5dc40887d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects the desired type, or throws an exception if such a type cannot be found </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a5467f83887d63a602cb05d88c6893bc0">GetShared()</a>.</p>

</div>
</div>
<a class="anchor" id="a43cde58980c81a1c47cd683dd820ff2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">const T *&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this pipeline packet contains an entry of the specified type </p>
<p>This method is also used by DecorateImmediate to extract pointers to data that is valid ONLY during recursive satisfaction calls. </p>

</div>
</div>
<a class="anchor" id="aedfb2068e9ff2f88e632a74259745b5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const T &gt; *&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared pointer specialization of const T*&amp;, used to obtain the underlying shared pointer for some type T </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tshift</td><td>The number back to retrieve</td></tr>
  </table>
  </dd>
</dl>
<p>This specialization cannot be used to obtain a decoration which has been attached to this packet via DecorateImmediate.</p>
<p>This method will throw an exception if the requested decoration is multiply present on the packet </p>

</div>
</div>
<a class="anchor" id="a434994156ef4debce252bb124ba2d5e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Get </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared pointer specialization, used to obtain the underlying shared pointer for some type T </p>
<p>This method can return an argument of DecorateImmediate as a shared_ptr&lt;T&gt; without a deleter. PROBLEM: This use case implies that holding shared_ptr references to decorations is NOT SAFE. </p>

</div>
</div>
<a class="anchor" id="aea6f7ada47b79a2767051b65430595a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T** AutoPacket::GetAll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a null-terminated temporary buffer containing all decorations </p>
<dl class="section return"><dt>Returns</dt><dd>The null-terminated temporary buffer</dd></dl>
<p>The returned buffer must be freed with std::return_temporary_buffer </p>

</div>
</div>
<a class="anchor" id="aa1235227e171d7229b72d3901e6d1042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">t_decorationMap AutoPacket::GetDecorations </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><dl class="section return"><dt>Returns</dt><dd>A copy of the decoration dispositions collection </dd></dl>
</p>
<p>This is a diagnostic method, users are recommended to avoid the use of this routine where possible </p>

</div>
</div>
<a class="anchor" id="af40ffd3b386863a7874866aa5a6b0429"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DecorationDisposition* AutoPacket::GetDisposition </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the decoration disposition corresponding to some type </p>
<dl class="section return"><dt>Returns</dt><dd>The disposition, if the decoration exists and is satisfied, otherwise nullptr</dd></dl>

<p>Referenced by <a class="el" href="class_auto_packet.html#a43cde58980c81a1c47cd683dd820ff2b">Get()</a>.</p>

</div>
</div>
<a class="anchor" id="a367921514045be484e134b34b4d6460d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SatCounter&amp; AutoPacket::GetSatisfaction </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>subscriber</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><dl class="section return"><dt>Returns</dt><dd>A reference to the satisfaction counter for the specified type</dd></dl>
</p>
<p>If the type is not a subscriber <a class="el" href="class_auto_packet.html#a1e8152052798e49283c8297886c62ffe" title="A reference to the satisfaction counter for the specified type">GetSatisfaction()</a>.GetType() == nullptr will be true </p>

</div>
</div>
<a class="anchor" id="a1e8152052798e49283c8297886c62ffe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SatCounter&amp; AutoPacket::GetSatisfaction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><dl class="section return"><dt>Returns</dt><dd>A reference to the satisfaction counter for the specified type</dd></dl>
</p>
<p>If the type is not a subscriber <a class="el" href="class_auto_packet.html#a1e8152052798e49283c8297886c62ffe" title="A reference to the satisfaction counter for the specified type">GetSatisfaction()</a>.GetType() == nullptr will be true </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a1e8152052798e49283c8297886c62ffe">GetSatisfaction()</a>.</p>

</div>
</div>
<a class="anchor" id="a749ec811977357ea7165b8e77be65932"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Has </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tshift</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><dl class="section return"><dt>Returns</dt><dd>True if this packet posesses a decoration of the specified type </dd></dl>
</p>
<p>Although "AutoPacket &amp;" and "const AutoPacket&amp;" argument types will be satisfied, the <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> does not "have" these types. </p>

</div>
</div>
<a class="anchor" id="a0758dc93f396121900cc5de17f46dcbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::HasUnsafe </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsynchronized runtime counterpart to Has</p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a749ec811977357ea7165b8e77be65932">Has()</a>.</p>

</div>
</div>
<a class="anchor" id="a64bf152b18a9e20c701661706fcce9c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::MarkSuccessorsUnsatisfiable </td>
          <td>(</td>
          <td class="paramtype">DecorationKey&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks timeshifted decorations on successor packets as unsatisfiable </p>

</div>
</div>
<a class="anchor" id="a29f7dcf03fe916c5566ca61afcc19782"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::MarkUnsatisfiable </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the specified entry as being unsatisfiable </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a92d46044bc68b565aa3772c67d961dea">Decorate()</a>, <a class="el" href="class_auto_packet.html#ac016b40fd64cf3e9df03627de240448a">DecorateImmediate()</a>, and <a class="el" href="class_auto_packet.html#a2b9788e64105fee4f967e53871c4d93b">Unsatisfiable()</a>.</p>

</div>
</div>
<a class="anchor" id="a3fa96738dac77521d123698ad3f80a35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SatCounter* AutoPacket::operator+= </td>
          <td>(</td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience overload, identical in behavior to AddRecipient </p>

</div>
</div>
<a class="anchor" id="a30a84b4131245539806ff5a7738f04f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_auto_packet.html">AutoPacket</a>&amp; AutoPacket::operator+= </td>
          <td>(</td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience overload, provided to allow the attachment of receive-only filters to a const <a class="el" href="class_auto_packet.html" title="A decorator-style processing packet ">AutoPacket</a> </p>

</div>
</div>
<a class="anchor" id="aa90a9d17516b284059a0f30249656d56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::PulseSatisfaction </td>
          <td>(</td>
          <td class="paramtype">DecorationDisposition *&#160;</td>
          <td class="paramname"><em>pTypeSubs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInfos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a "satisfaction pulse", which will avoid notifying any deferred filters </p>
<p>A satisfaction pulse will call any AutoFilter instances which are satisfied by the decoration of the passed decoration types. </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#ac016b40fd64cf3e9df03627de240448a">DecorateImmediate()</a>.</p>

</div>
</div>
<a class="anchor" id="aa302c91a39594f5ea0f58094ce4fea3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::RemoveRecipient </td>
          <td>(</td>
          <td class="paramtype">const SatCounter &amp;&#160;</td>
          <td class="paramname"><em>recipient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a previously added packet recipient </p>

</div>
</div>
<a class="anchor" id="a99e7dd1ee400c313c05d56d7642a0c87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_auto_packet.html">AutoPacket</a>&gt; AutoPacket::Successor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next packet that will be issued by the packet factory in this context relative to this context </p>

</div>
</div>
<a class="anchor" id="af7d82f8536c4a1b847a5ba0efb9b99d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_auto_packet.html">AutoPacket</a>&gt; AutoPacket::SuccessorUnsafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The portion of Successor that must run under a lock </p>

</div>
</div>
<a class="anchor" id="a876a04e499194ec2c8960ee9aa655b0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void AutoPacket::ThrowMultiplyDecoratedException </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws a formatted runtime error corresponding to the case where a decoration was demanded and more than one such decoration was present </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#a43cde58980c81a1c47cd683dd820ff2b">Get()</a>.</p>

</div>
</div>
<a class="anchor" id="ad77d4e6ff2c9fe5fb19dcd43c91fbc57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void AutoPacket::ThrowNotDecoratedException </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws a formatted runtime error corresponding to the case where an absent decoration was demanded </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#afc2ea2311961fd3e9f92c6b5dc40887d">Get()</a>.</p>

</div>
</div>
<a class="anchor" id="a0dbabcc26a87524dbd833390d6dff5f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::UnsafeComplete </td>
          <td>(</td>
          <td class="paramtype">const DecorationKey &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked from a checkout when a checkout has completed </p>

</div>
</div>
<a class="anchor" id="a2b9788e64105fee4f967e53871c4d93b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::Unsatisfiable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the named decoration as unsatisfiable </p>
<p>Marking a decoration as unsatisfiable immediately causes any filters with an input of the form std::shared_ptr&lt;const T&gt; to be called, if the remainder of their inputs are available. </p>

</div>
</div>
<a class="anchor" id="a112ba05a6a371322e297676d64c5358f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutoPacket::UpdateSatisfactionUnsafe </td>
          <td>(</td>
          <td class="paramtype">std::unique_lock&lt; std::mutex &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecorationDisposition &amp;&#160;</td>
          <td class="paramname"><em>disposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates subscriber statuses given that the specified type information has been satisfied </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The decoration which was just added to this packet</td></tr>
  </table>
  </dd>
</dl>
<p>This method results in a call to the AutoFilter method on any subscribers which are satisfied by this decoration. This method must be called with m_lock held. </p>

</div>
</div>
<a class="anchor" id="a654e349d38d07225b64008a6ff0351c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Wait </td>
          <td>(</td>
          <td class="paramtype">std::condition_variable &amp;&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AutoFilterDescriptorInput *&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>duration</em> = <code>std::chrono::nanoseconds::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks until the specified descriptor is satisfied </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The amount of time to wait. If set to std::chrono::nanoseconds::max, this method will block indefinitely </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if a timeout occurred, true otherwise</dd></dl>
<p>This method considers the arguments described by "inputs" and will block until all decorations that are needed by this filter have been satisfied on this packet. When this function returns, the specified filter will have been called. </p>

<p>Referenced by <a class="el" href="class_auto_packet.html#adde180a2515100943e2b33e999b7f6d3">Wait()</a>.</p>

</div>
</div>
<a class="anchor" id="adde180a2515100943e2b33e999b7f6d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Wait </td>
          <td>(</td>
          <td class="paramtype">std::condition_variable &amp;&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fx &amp;&amp;&#160;</td>
          <td class="paramname"><em>autoFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>duration</em> = <code>std::chrono::nanoseconds::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks until the passed lambda function can be called </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cv</td><td>A condition variable that can be signalled when the wait condition has expired</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false if a timeout occurred </dd></dl>
<p>This method will invoke the passed autoFilter function once all of its arguments are present on the packet this routine generates internally. This method will not return until the specified autoFilter is called. If the autoFilter cannot be called because the required decorations are not present on the packet on teardown, this method will throw an exception.</p>
<p>The passed autoFilter routine must not attach any decorations to the packet, nor may it accept a non-const AutoFilter as an input argument. </p>

</div>
</div>
<a class="anchor" id="a5587ee9febad91417f6ee1f4c65d6282"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Decorations&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Wait </td>
          <td>(</td>
          <td class="paramtype">std::condition_variable &amp;&#160;</td>
          <td class="paramname"><em>cv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delays until the specified decorations are satisfied </p>

</div>
</div>
<a class="anchor" id="a0b8aea3ddb3ab167ec745f5f7cb6dd3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoPacket::Wait </td>
          <td>(</td>
          <td class="paramtype">std::chrono::nanoseconds&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::condition_variable &amp;&#160;</td>
          <td class="paramname"><em>cv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timed version of Wait </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autowiring/<a class="el" href="_auto_packet_8h_source.html">AutoPacket.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_auto_packet.html">AutoPacket</a></li>
    <li class="footer">Generated on Mon Jun 1 2015 14:37:45 for Autowiring by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
