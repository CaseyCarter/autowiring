<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Autowiring: SharedPointerSlot Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Autowiring
   &#160;<span id="projectnumber">0.4.1</span>
   </div>
   <div id="projectbrief">A C++ Inversion of Control Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="struct_shared_pointer_slot-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SharedPointerSlot Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Specialized space-invariant implementation of boost::any for shared pointers  
 <a href="struct_shared_pointer_slot.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_shared_pointer_slot_8h_source.html">SharedPointerSlot.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SharedPointerSlot:</div>
<div class="dyncontent">
 <div class="center">
  <img src="struct_shared_pointer_slot.png" usemap="#SharedPointerSlot_map" alt=""/>
  <map id="SharedPointerSlot_map" name="SharedPointerSlot_map">
<area href="struct_shared_pointer_slot_t_3_01_t_00_01false_01_4.html" alt="SharedPointerSlotT&lt; T, false &gt;" shape="rect" coords="0,56,188,80"/>
<area href="struct_shared_pointer_slot_t_3_01_t_00_01true_01_4.html" alt="SharedPointerSlotT&lt; T, true &gt;" shape="rect" coords="0,112,188,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa262b092af3a0bd0d686a0ee4c875948"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa262b092af3a0bd0d686a0ee4c875948"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SharedPointerSlot</b> (const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;rhs)</td></tr>
<tr class="separator:aa262b092af3a0bd0d686a0ee4c875948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63f4aa89685ee5c189e9bdcd3462636"><td class="memTemplParams" colspan="2"><a class="anchor" id="af63f4aa89685ee5c189e9bdcd3462636"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af63f4aa89685ee5c189e9bdcd3462636"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SharedPointerSlot</b> (const std::shared_ptr&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:af63f4aa89685ee5c189e9bdcd3462636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018575b6c3815015a4ddd95d54d144fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a018575b6c3815015a4ddd95d54d144fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator bool</b> (void) const </td></tr>
<tr class="separator:a018575b6c3815015a4ddd95d54d144fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10e797d86752eeeefbf14373a4499a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae10e797d86752eeeefbf14373a4499a5"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>operator std::shared_ptr&lt; Object &gt;</b> (void) const </td></tr>
<tr class="separator:ae10e797d86752eeeefbf14373a4499a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1758822996544b1a796b33bdf808de6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1758822996544b1a796b33bdf808de6f"></a>
virtual void *&#160;</td><td class="memItemRight" valign="bottom"><b>ptr</b> (void)</td></tr>
<tr class="separator:a1758822996544b1a796b33bdf808de6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d7802ec44e4e2825f696e4f8b0db72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42d7802ec44e4e2825f696e4f8b0db72"></a>
virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><b>ptr</b> (void) const </td></tr>
<tr class="separator:a42d7802ec44e4e2825f696e4f8b0db72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9355745051aca3eb7ab05cf8ee25d1e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#a9355745051aca3eb7ab05cf8ee25d1e3">New</a> (void *pSpace, size_t nBytes) const </td></tr>
<tr class="memdesc:a9355745051aca3eb7ab05cf8ee25d1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a placement new on the specified space with a type matching the current instance  <a href="#a9355745051aca3eb7ab05cf8ee25d1e3">More...</a><br /></td></tr>
<tr class="separator:a9355745051aca3eb7ab05cf8ee25d1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9ad9e76105f72e459c253bfef788d5"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#acc9ad9e76105f72e459c253bfef788d5">shared_ptr</a> (void) const </td></tr>
<tr class="separator:acc9ad9e76105f72e459c253bfef788d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f347f4158070752ef55ee91c4b9232"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#ad6f347f4158070752ef55ee91c4b9232">try_assign</a> (const std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad6f347f4158070752ef55ee91c4b9232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to dynamically assign this slot to the specified object without changing the current type  <a href="#ad6f347f4158070752ef55ee91c4b9232">More...</a><br /></td></tr>
<tr class="separator:ad6f347f4158070752ef55ee91c4b9232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a64c1fa173076432457e2daf338645"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a98a64c1fa173076432457e2daf338645"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#a98a64c1fa173076432457e2daf338645">init</a> (void)</td></tr>
<tr class="memdesc:a98a64c1fa173076432457e2daf338645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alters the type of this slot to match the specified type  <a href="#a98a64c1fa173076432457e2daf338645">More...</a><br /></td></tr>
<tr class="separator:a98a64c1fa173076432457e2daf338645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b712a390824888d5c47ad6457a6182"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#a79b712a390824888d5c47ad6457a6182">empty</a> (void) const </td></tr>
<tr class="separator:a79b712a390824888d5c47ad6457a6182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de1cdba907ea7e17a8dbb2d6885f838"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9de1cdba907ea7e17a8dbb2d6885f838"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#a9de1cdba907ea7e17a8dbb2d6885f838">is</a> (void) const </td></tr>
<tr class="separator:a9de1cdba907ea7e17a8dbb2d6885f838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cf3e7ce37b3bc0300b5c6ae14c658b"><td class="memItemLeft" align="right" valign="top">virtual const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#a29cf3e7ce37b3bc0300b5c6ae14c658b">type</a> (void) const </td></tr>
<tr class="separator:a29cf3e7ce37b3bc0300b5c6ae14c658b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac632a9c0092b7fce3b33d87c4c3fc28a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#ac632a9c0092b7fce3b33d87c4c3fc28a">reset</a> (void)</td></tr>
<tr class="memdesc:ac632a9c0092b7fce3b33d87c4c3fc28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears this type, if a shared pointer is currently held  <a href="#ac632a9c0092b7fce3b33d87c4c3fc28a">More...</a><br /></td></tr>
<tr class="separator:ac632a9c0092b7fce3b33d87c4c3fc28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab135e5951b24757881c4005dfb013136"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab135e5951b24757881c4005dfb013136"><td class="memTemplItemLeft" align="right" valign="top">const std::shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#ab135e5951b24757881c4005dfb013136">as</a> (void) const </td></tr>
<tr class="memdesc:ab135e5951b24757881c4005dfb013136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to coerce this type to the specified type  <a href="#ab135e5951b24757881c4005dfb013136">More...</a><br /></td></tr>
<tr class="separator:ab135e5951b24757881c4005dfb013136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83666325668d9b69903698cc910b7219"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a83666325668d9b69903698cc910b7219"><td class="memTemplItemLeft" align="right" valign="top">const std::shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#a83666325668d9b69903698cc910b7219">as_unsafe</a> (void) const </td></tr>
<tr class="memdesc:a83666325668d9b69903698cc910b7219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="struct_shared_pointer_slot.html#ab135e5951b24757881c4005dfb013136" title="Attempts to coerce this type to the specified type ">as()</a>, but performs no type safety checks  <a href="#a83666325668d9b69903698cc910b7219">More...</a><br /></td></tr>
<tr class="separator:a83666325668d9b69903698cc910b7219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251406c973c5692a0c61aae91dd7743e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#a251406c973c5692a0c61aae91dd7743e">operator==</a> (const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a251406c973c5692a0c61aae91dd7743e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison by reference. Comparison of unequal types always fails, even when different type casts of the same instance are referenced.  <a href="#a251406c973c5692a0c61aae91dd7743e">More...</a><br /></td></tr>
<tr class="separator:a251406c973c5692a0c61aae91dd7743e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d43c7400abd1fe94ccb88cf7035ca0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad7d43c7400abd1fe94ccb88cf7035ca0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#ad7d43c7400abd1fe94ccb88cf7035ca0">operator==</a> (const std::shared_ptr&lt; T &gt; &amp;rhs) const </td></tr>
<tr class="memdesc:ad7d43c7400abd1fe94ccb88cf7035ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison by reference. Comparison of unequal types always fails, even when different type casts of the same instance are referenced.  <a href="#ad7d43c7400abd1fe94ccb88cf7035ca0">More...</a><br /></td></tr>
<tr class="separator:ad7d43c7400abd1fe94ccb88cf7035ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7c8c8b0e99aba6170a005fd897c6fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#adc7c8c8b0e99aba6170a005fd897c6fb">operator==</a> (const std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt; &amp;rhs) const </td></tr>
<tr class="memdesc:adc7c8c8b0e99aba6170a005fd897c6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the <a class="el" href="class_object.html" title="General object base, used to make conversions possible between various shared pointer implementations...">Object</a> base type  <a href="#adc7c8c8b0e99aba6170a005fd897c6fb">More...</a><br /></td></tr>
<tr class="separator:adc7c8c8b0e99aba6170a005fd897c6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90e9a742733fff299b97359ece214ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#ad90e9a742733fff299b97359ece214ee">operator=</a> (const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;rhs)</td></tr>
<tr class="memdesc:ad90e9a742733fff299b97359ece214ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator  <a href="#ad90e9a742733fff299b97359ece214ee">More...</a><br /></td></tr>
<tr class="separator:ad90e9a742733fff299b97359ece214ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0768ebe7541b74a5f2b67a9fda91d87"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa0768ebe7541b74a5f2b67a9fda91d87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#aa0768ebe7541b74a5f2b67a9fda91d87">operator=</a> (const std::shared_ptr&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa0768ebe7541b74a5f2b67a9fda91d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place polymorphic transformer  <a href="#aa0768ebe7541b74a5f2b67a9fda91d87">More...</a><br /></td></tr>
<tr class="separator:aa0768ebe7541b74a5f2b67a9fda91d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a175eed4187135bf01b7fbecc660aa5a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_shared_pointer_slot.html#a175eed4187135bf01b7fbecc660aa5a3">assign</a> (const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;rhs)</td></tr>
<tr class="memdesc:a175eed4187135bf01b7fbecc660aa5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment routine  <a href="#a175eed4187135bf01b7fbecc660aa5a3">More...</a><br /></td></tr>
<tr class="separator:a175eed4187135bf01b7fbecc660aa5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a15ab96610a199d153df370121286feae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15ab96610a199d153df370121286feae"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>m_space</b> [sizeof(std::shared_ptr&lt; void &gt;)]</td></tr>
<tr class="separator:a15ab96610a199d153df370121286feae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Specialized space-invariant implementation of boost::any for shared pointers </p>
<p>This implementation is superior to boost::any because it does not require the use of the heap for allocations, and is slightly faster under teardown for the same reason. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab135e5951b24757881c4005dfb013136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template const std::shared_ptr&lt; <a class="el" href="class_auto_packet_factory.html">AutoPacketFactory</a> &gt; &amp; SharedPointerSlot::as&lt; <a class="el" href="class_auto_packet_factory.html">AutoPacketFactory</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to coerce this type to the specified type </p>

</div>
</div>
<a class="anchor" id="a83666325668d9b69903698cc910b7219"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;T&gt;&amp; SharedPointerSlot::as_unsafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="struct_shared_pointer_slot.html#ab135e5951b24757881c4005dfb013136" title="Attempts to coerce this type to the specified type ">as()</a>, but performs no type safety checks </p>

</div>
</div>
<a class="anchor" id="a175eed4187135bf01b7fbecc660aa5a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SharedPointerSlot::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment routine </p>
<p>If this method is called, there will be a strong guarantee that the type of rhs will be precisely equal to the type of this.</p>
<p>Implementors MUST treat this as a type of constructor replacement. The contents of m_space are indeterminate and certainly invalid, and should be treated as uninitialized memory. </p>

<p>Reimplemented in <a class="el" href="struct_shared_pointer_slot_t_3_01_t_00_01false_01_4.html#afce8e299cce59ac436e0dbc83137e1df">SharedPointerSlotT&lt; T, false &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a79b712a390824888d5c47ad6457a6182"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SharedPointerSlot::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this slot holds nothing </dd></dl>

<p>Reimplemented in <a class="el" href="struct_shared_pointer_slot_t_3_01_t_00_01false_01_4.html#a04d535eb84e577f7907031c5af46c278">SharedPointerSlotT&lt; T, false &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a98a64c1fa173076432457e2daf338645"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt;T&gt;&amp; SharedPointerSlot::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alters the type of this slot to match the specified type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type to initialize this slot into</td></tr>
  </table>
  </dd>
</dl>
<p>This operation releases any previously held value, and causes the slot to hold nullptr with the specified type </p>

</div>
</div>
<a class="anchor" id="a9de1cdba907ea7e17a8dbb2d6885f838"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SharedPointerSlot::is </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this pointer slot holds an instance of the specified type </dd></dl>

</div>
</div>
<a class="anchor" id="a9355745051aca3eb7ab05cf8ee25d1e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SharedPointerSlot::New </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a placement new on the specified space with a type matching the current instance </p>
<p>This method will also initialize the returned space with a copy of the shared pointer held by this slot. </p>

<p>Reimplemented in <a class="el" href="struct_shared_pointer_slot_t_3_01_t_00_01true_01_4.html#ab788b4b5aa3556a6c533b1c10a27f96c">SharedPointerSlotT&lt; T, true &gt;</a>, and <a class="el" href="struct_shared_pointer_slot_t_3_01_t_00_01false_01_4.html#aa3ab2027f805758aaaab6d8318d87faf">SharedPointerSlotT&lt; T, false &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad90e9a742733fff299b97359ece214ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a>&amp; SharedPointerSlot::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator </p>
<p>Consumer beware: This is a transformative assignment. The true polymorphic type will be carried from the right-hand side into this element, which is a different behavior from how things are normally done during assignment. Other than that, however, the behavior is very similar to boost::any's assignment implementation. </p>

</div>
</div>
<a class="anchor" id="aa0768ebe7541b74a5f2b67a9fda91d87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_shared_pointer_slot_t.html">SharedPointerSlotT</a>&lt;T&gt;&amp; SharedPointerSlot::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place polymorphic transformer </p>

</div>
</div>
<a class="anchor" id="a251406c973c5692a0c61aae91dd7743e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SharedPointerSlot::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_shared_pointer_slot.html">SharedPointerSlot</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison by reference. Comparison of unequal types always fails, even when different type casts of the same instance are referenced. </p>

</div>
</div>
<a class="anchor" id="ad7d43c7400abd1fe94ccb88cf7035ca0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SharedPointerSlot::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison by reference. Comparison of unequal types always fails, even when different type casts of the same instance are referenced. </p>

</div>
</div>
<a class="anchor" id="adc7c8c8b0e99aba6170a005fd897c6fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SharedPointerSlot::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization for the <a class="el" href="class_object.html" title="General object base, used to make conversions possible between various shared pointer implementations...">Object</a> base type </p>

</div>
</div>
<a class="anchor" id="ac632a9c0092b7fce3b33d87c4c3fc28a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SharedPointerSlot::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears this type, if a shared pointer is currently held </p>
<p>This method will preserve the polymorphic type of this slot&ndash;IE, it does not change the return value of this-&gt;<a class="el" href="struct_shared_pointer_slot.html#a29cf3e7ce37b3bc0300b5c6ae14c658b">type()</a> </p>

<p>Reimplemented in <a class="el" href="struct_shared_pointer_slot_t_3_01_t_00_01false_01_4.html#abd880aaaf049830df0f95630e0271b3b">SharedPointerSlotT&lt; T, false &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="acc9ad9e76105f72e459c253bfef788d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* SharedPointerSlot::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A void pointer to the underlying shared pointer implementation </dd></dl>
<p>Use this method with great caution. The return value may be safely cast to type std::shared_ptr&lt;T&gt; <em>if</em> the correct type for T is known at compile time, but if this pointer is shared at runtime between modules, compilation differences can change the layout of the shared pointer in subtle ways. Generally speaking, this function should only be called by modules which are guaranteed to have been statically linked in the same executable. </p>

</div>
</div>
<a class="anchor" id="ad6f347f4158070752ef55ee91c4b9232"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SharedPointerSlot::try_assign </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to dynamically assign this slot to the specified object without changing the current type </p>
<dl class="section return"><dt>Returns</dt><dd>True if the assignment succeeds</dd></dl>

<p>Reimplemented in <a class="el" href="struct_shared_pointer_slot_t_3_01_t_00_01true_01_4.html#a5d4fd9d7ce24b503895a662a9cdba3fd">SharedPointerSlotT&lt; T, true &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a29cf3e7ce37b3bc0300b5c6ae14c658b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::type_info&amp; SharedPointerSlot::type </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns the template type of the shared pointer held in this slot, or typeid(void) if empty </dd></dl>

<p>Reimplemented in <a class="el" href="struct_shared_pointer_slot_t_3_01_t_00_01false_01_4.html#aad145d013b880ad02d32cf6ca3baa275">SharedPointerSlotT&lt; T, false &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>autowiring/<a class="el" href="_shared_pointer_slot_8h_source.html">SharedPointerSlot.h</a></li>
<li>autowiring/<a class="el" href="_auto_packet_factory_8h_source.html">AutoPacketFactory.h</a></li>
<li>src/autowiring/AutoPacketFactory.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 19 2015 11:57:30 for Autowiring by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
